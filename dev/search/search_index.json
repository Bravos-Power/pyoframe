{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyoframe: A loved alternative to GAMS, Pyomo, and Linopy","text":"<ul> <li>Builds linear, non-linear, quadratic, continuous and mixed-integer optimization problems.</li> <li>Seamlessly integrates with pandas thanks to its dataframe-centric design.</li> <li>Extremely fast and memory efficient (even for sparse problems) thanks to Polars, Rust, and Pyoptinterface.</li> <li>Clear Pythonic syntax for writing mathematical models.</li> <li>Supports Gurobi, HiGHS, Ipopt and COPT solvers.</li> <li>Continuously used in high-stakes production environments.</li> <li>100% open-source (MIT License).</li> </ul> <ul> <li> <p> Learn</p> <p>Install <code>pyoframe</code> and learn the library's basics.</p> <p> Get started</p> </li> <li> <p> Examples</p> <p>Jump right in with our annotated examples.</p> <p> Examples</p> </li> </ul> <ul> <li> <p> API Reference</p> <p>Your go-to reference for understanding our API.</p> <p> Reference</p> </li> <li> <p> Ask a question</p> <p>Ask questions and discuss on our forum.</p> <p> GitHub Discussions</p> </li> <li> <p> Report a bug</p> <p>Bugs and feature requests can be submitted on GitHub.</p> <p> GitHub Issues</p> </li> </ul>"},{"location":"contribute/","title":"Contribute","text":"<p>Contributions are more than welcome! Submit a pull request, or open an issue and I (Martin) will gladly answer your questions on how to contribute.</p>"},{"location":"contribute/#setup-a-development-environment","title":"Setup a development environment","text":"<ol> <li> <p>Clone this repository. <pre><code>git clone https://github.com/Bravos-Power/pyoframe\n</code></pre></p> </li> <li> <p>Install the dependencies.  <pre><code>pip install --editable .[dev,docs]\n</code></pre></p> </li> <li> <p>Install the pre-commit hooks.  <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"contribute/#running-the-test-suite","title":"Running the test suite","text":"<p>Run <code>pytest</code> to execute the test suite. (If you'd like to view coverage information add the flag <code>--cov</code> and then run <code>coverage html</code>.)</p> <p>The only errors you should see when running the test suite are those related to a solver not being installed.</p> <p>Pyoframe has several types of tests.</p> <ol> <li> <p>Your typical unit tests under the <code>tests/</code> folder.</p> </li> <li> <p>Integration tests in <code>tests/test_examples.py</code>. These tests will run all the models in <code>tests/examples</code> and make sure that your changes haven't altered the model results (stored under <code>tests/examples/&lt;model&gt;/results</code>). In the rare cases where you want the model results to change (e.g. if you've changed the model), you can regenerate the results using <code>python -m tests.test_examples</code>.</p> </li> <li> <p>Doctests in the docstrings of the source code (<code>src/</code>).</p> </li> <li> <p>Documentation tests (in <code>docs/</code>). All Python code blocks in the documentation are run to ensure the documentation doesn't become outdated. This is done using Sybil. Refer to the Sybil documentation to learn how to create setup code or skip code blocks you don't wish to test.</p> </li> </ol> <p>Non-breaking spaces</p> <p>Be aware that Pyoframe uses non-breaking spaces to improve the formatting of expressions. If your Sybil tests are unexpectedly failing, make sure that the expected output contains all the needed non-breaking spaces.</p>"},{"location":"contribute/#writing-documentation","title":"Writing documentation","text":"<p>You can preview the documentation website by running <code>mkdocs serve</code> and navigating to <code>http://127.0.0.1:8000/pyoframe/</code>.</p> <p>We use Material Docs for documentation with several plugins to enable features like automatically compiling the docstrings into the reference API. Please follow the Google docstring style and the Google style guide. We use Mike to allow readers to view the documentation for previous releases (preview available via <code>mike serve</code>).</p>"},{"location":"contribute/#linting-and-formatting","title":"Linting and formatting","text":"<p>We use Ruff for linting and formatting. The pre-commit hooks will run <code>ruff format</code> on commit. You should also make sure <code>ruff check</code> returns no errors before submitting a PR. To format code blocks in the documentation run: <code>doccmd --language=python --no-pad-file --command=\"ruff format\" docs/</code>.</p>"},{"location":"contribute/#additional-tips","title":"Additional tips","text":"<p>I recommend skimming or reading the Internal Details page for some background on how Pyoframe works.</p> <p>For core developers:</p> <ul> <li>If you use <code>.unique</code>, <code>.join</code>, <code>.sort</code>, or <code>.group_by</code> on a Polars dataframe, make sure to set the <code>maintain_order</code> parameter appropriately (typically, <code>maintain_order=Config.maintain_order</code>).</li> </ul> <p>For repository maintainers:</p> <ul> <li>Our CI pipeline on Github Actions requires a Gurobi and COPT license to run. If the Gurobi license expires, generate a new one and copy the contents of the <code>guorbi.lic</code> file into the <code>GUROBI_WLS</code> Github secret (Settings -&gt; Secrets and variables -&gt; actions). Similarly, if the COPT license expires, request a new academic license (or email COPT sales for a free one) and copy the contents of both license files to the matching Github secrets.</li> </ul>"},{"location":"examples/","title":"List of Examples","text":"Example Description Diet problem A simple linear program about optimizing your diet. Production planning A simple linear program about optimizing a production line. Facility location A problem with quadratic constraints about placing facilities nearest to customers. Portfolio optimization A problem with a quadratic objective about minimizing risk in an investment portfolio."},{"location":"examples/diet/","title":"Diet problem","text":""},{"location":"examples/diet/#problem-statement","title":"Problem statement","text":"<p>Given a list of potential foods, their costs, and their availability (<code>foods.csv</code>), and a list of the nutrients (e.g., protein, fats, etc.) contained in each food (<code>foods_to_nutrients.csv</code>), how can you satisfy your dietary requirements (<code>nutrients.csv</code>) while minimizing total costs?</p>"},{"location":"examples/diet/#model","title":"Model","text":"<pre><code>import pandas as pd\n\nimport pyoframe as pf\n\n# Import data\nfood = pd.read_csv(\"foods.csv\")\nnutrients = pd.read_csv(\"nutrients.csv\")\nfood_nutrients = pd.read_csv(\"foods_to_nutrients.csv\")\n\n# Construct model\nm = pf.Model()\nm.Buy = pf.Variable(food[\"food\"], lb=0, ub=food[[\"food\", \"stock\"]])\n\nnutrient_intake = (m.Buy * food_nutrients).sum_by(\"category\")\nm.min_nutrients = (\n    nutrients[[\"category\", \"min\"]] &lt;= nutrient_intake.drop_extras()  # (1)!\n)\nm.max_nutrients = nutrient_intake.drop_extras() &lt;= nutrients[[\"category\", \"max\"]]\n\ntotal_cost = (m.Buy * food[[\"food\", \"cost\"]]).sum()\nm.minimize = total_cost\n\n# Solve model\nm.optimize()\n</code></pre> <ol> <li><code>.drop_extras()</code> ensures that if <code>min_nutrient</code> is <code>null</code> for certain foods, no constraint will be created for those foods. Learn more</li> </ol> <p>So the solution is...</p> <pre><code>&gt;&gt;&gt; total_cost.evaluate()\n12.060249999999998\n&gt;&gt;&gt; m.Buy.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food      \u2506 solution \u2502\n\u2502 ---       \u2506 ---      \u2502\n\u2502 str       \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 hamburger \u2506 0.555263 \u2502\n\u2502 chicken   \u2506 0.0      \u2502\n\u2502 hot_dog   \u2506 0.0      \u2502\n\u2502 fries     \u2506 0.0      \u2502\n\u2502 macaroni  \u2506 0.0      \u2502\n\u2502 pizza     \u2506 0.0      \u2502\n\u2502 salad     \u2506 0.0      \u2502\n\u2502 milk      \u2506 6.8      \u2502\n\u2502 ice_cream \u2506 2.909211 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Not a very balanced diet .</p>"},{"location":"examples/facility_location/","title":"Facility location Problem","text":""},{"location":"examples/facility_location/#problem-statement","title":"Problem statement","text":"<p>As described in this paper, the facility location problem seeks to find the optimal <code>(x,y)</code> location for a set of <code>F</code> facilities such that the maximum distance between any customer and its nearest facility is minimized. Customers are spread out evenly on a <code>G</code>-by-<code>G</code> grid.</p>"},{"location":"examples/facility_location/#model","title":"Model","text":"<pre><code>import pandas as pd\n\nimport pyoframe as pf\n\nG = 4\nF = 3\n\n# Construct model\nmodel = pf.Model()\n\n# Define sets\nmodel.facilities = pf.Set(f=range(F))\nmodel.x_axis = pf.Set(x=range(G))\nmodel.y_axis = pf.Set(y=range(G))\nmodel.axis = pf.Set(axis=[\"x\", \"y\"])\nmodel.customers = model.x_axis * model.y_axis  # (1)!\n\n\nmodel.facility_position = pf.Variable(model.facilities, model.axis, lb=0, ub=1)\nmodel.customer_position_x = pf.Param(\n    {\"x\": range(G), \"x_pos\": [step / (G - 1) for step in range(G)]}\n)\nmodel.customer_position_y = pf.Param(\n    {\"y\": range(G), \"y_pos\": [step / (G - 1) for step in range(G)]}\n)\n\nmodel.max_distance = pf.Variable(lb=0)\n\nmodel.is_closest = pf.Variable(model.customers, model.facilities, vtype=\"binary\")\nmodel.con_only_one_closest = model.is_closest.sum(\"f\") == 1\n\nmodel.dist_x = pf.Variable(model.x_axis, model.facilities)\nmodel.dist_y = pf.Variable(model.y_axis, model.facilities)\nmodel.con_dist_x = model.dist_x == model.customer_position_x.over(\n    \"f\"\n) - model.facility_position.pick(axis=\"x\").over(\"x\")\nmodel.con_dist_y = model.dist_y == model.customer_position_y.over(\n    \"f\"\n) - model.facility_position.pick(axis=\"y\").over(\"y\")\nmodel.dist = pf.Variable(model.x_axis, model.y_axis, model.facilities, lb=0)\nmodel.con_dist = model.dist**2 == (model.dist_x**2).over(\"y\") + (model.dist_y**2).over(\n    \"x\"\n)\n\nM = 2 * 1.414\nmodel.con_max_distance = model.max_distance.over(\"x\", \"y\", \"f\") &gt;= model.dist - M * (\n    1 - model.is_closest\n)\n\nmodel.minimize = model.max_distance\n\n# Solve model\nmodel.optimize()\n</code></pre> <ol> <li>Multiplying Sets returns their cartesian product.</li> </ol> <p>So what's the maximum distance from a customer to its nearest facility?</p> <pre><code>&gt;&gt;&gt; model.objective.value\n0.5\n</code></pre>"},{"location":"examples/portfolio_optimization/","title":"Portfolio optimization","text":""},{"location":"examples/portfolio_optimization/#problem-statement","title":"Problem statement","text":"<p>Given a list of assets, their covariance, and some portfolio parameters, select the portfolio weights that minimize risk (i.e. variance) while achieving a target return.</p>"},{"location":"examples/portfolio_optimization/#solution","title":"Solution","text":"<pre><code>import pandas as pd\nimport pyoframe as pf\n\n# Read input data\nassets = pd.read_csv(\"assets.csv\").set_index(\"asset\")\ncovariance = pd.read_csv(\"covariance.csv\").set_index([\"asset_i\", \"asset_j\"])\nparams = pd.read_csv(\"portfolio_params.csv\").set_index(\"param\")[\"value\"]\n\nm = pf.Model()\n\n# Decision variables: portfolio weights\nm.weight = pf.Variable(assets.index, lb=0, ub=params.loc[\"max_weight\"])\n\n# Constraint: weights must sum to 1\nm.con_weights_sum = m.weight.sum() == 1\n\n# Constraint: minimum expected return\nm.con_min_return = (m.weight * assets[\"expected_return\"]).sum() &gt;= params.loc[\n    \"min_return\"\n]\n\n# Objective: minimize portfolio variance (quadratic)\n# Variance = sum over i,j of weight_i * cov_ij * weight_j\n# We use 'rename' to make the dimensions match properly\nm.minimize = (\n    m.weight.rename({\"asset\": \"asset_i\"})\n    * covariance[\"covariance\"]\n    * m.weight.rename({\"asset\": \"asset_j\"})\n).sum()\n\nm.optimize()\n</code></pre> <p>And the result should be: <pre><code>&gt;&gt;&gt; m.weight.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 asset \u2506 solution \u2502\n\u2502 ---   \u2506 ---      \u2502\n\u2502 str   \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A     \u2506 0.36067  \u2502\n\u2502 B     \u2506 0.147212 \u2502\n\u2502 C     \u2506 0.209338 \u2502\n\u2502 D     \u2506 0.145308 \u2502\n\u2502 E     \u2506 0.137472 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.objective.value\n0.0195\n</code></pre></p>"},{"location":"examples/production/","title":"Production planning","text":""},{"location":"examples/production/#problem-statement","title":"Problem statement","text":"<p>This classical problem (Eiselt and Sandblom, p. 20) seeks to determine which products should be manufactured (and in what quantities) given that:</p> <ol> <li> <p>Each product must go through all the machines.</p> </li> <li> <p>Every machine takes a different amount of time to process every product (<code>processing_times.csv</code>).</p> </li> <li> <p>Machines have a maximum lifetime before needing maintenance (<code>machines_availability.csv</code>).</p> </li> <li> <p>Each product yields a different amount of profit (<code>products_profit.csv</code>).</p> </li> </ol>"},{"location":"examples/production/#model","title":"Model","text":"<pre><code>import pandas as pd\n\nimport pyoframe as pf\n\n\nprocessing_times = pd.read_csv(\"processing_times.csv\")\nmachines_availability = pd.read_csv(\"machines_availability.csv\")\nproducts_profit = pd.read_csv(\"products_profit.csv\")\n\nm = pf.Model()\nm.Production = pf.Variable(products_profit[\"products\"], lb=0)\n\nmachine_usage = m.Production * processing_times\nm.machine_capacity = machine_usage.sum_by(\"machines\") &lt;= machines_availability\n\nm.maximize = (products_profit * m.Production).sum()\n\nm.optimize()\n</code></pre> <pre><code>&gt;&gt;&gt; m.Production.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 products \u2506 solution \u2502\n\u2502 ---      \u2506 ---      \u2502\n\u2502 i64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1        \u2506 20.0     \u2502\n\u2502 2        \u2506 0.0      \u2502\n\u2502 3        \u2506 120.0    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/advanced-concepts/datastructure/","title":"Pyoframe's datastructure","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>So how does Pyoframe really work? Pyoframe uses dataframe operations to build your model's linear expressions. Here's what's happening under the hood.</p>"},{"location":"learn/advanced-concepts/internals/","title":"Internal details","text":"<p>Pyoframe's inner workings involve a few tricks that you should be aware of if you wish to contribute to Pyoframe's code base.</p>"},{"location":"learn/advanced-concepts/internals/#the-zero-variable","title":"The zero variable","text":"<p>Whenever a Model is instantiated, Pyoframe immediately creates a variable whose value is fixed to <code>1</code> and has a variable id of <code>0</code> \u2014 the Zero Variable. This allows Pyoframe to represent constant terms in mathematical expressions as  multiples of the Zero Variable. For example, the expression <code>3 * var_8 + 5</code> is represented as <code>3 * var_8 + 5 * var_0</code>. This eliminates the need to separately track constant terms and also simplifies the handling of quadratics.</p>"},{"location":"learn/advanced-concepts/internals/#quadratics","title":"Quadratics","text":"<p>Internally, Expression is used to represent both linear and quadratic mathematical expressions. When a quadratic expression is formed, column <code>__quadratic_variable_id</code> is added to Expression.data. If an expression's quadratic terms happen to cancel out (e.g. <code>(ab + c) - ab</code>), this column is automatically removed.</p> <p>Column <code>__quadratic_variable_id</code> records the ID of the second variable in a quadratic term (the <code>b</code> in <code>3ab</code>). For linear terms, which have no second variable, this column contains the Zero Variable.</p> <p>Quadratic terms are always stored such that the first term's variable ID (in column <code>__variable_id</code>) is greater or equal to the second term's variable id (in column <code>__quadratic_variable_id</code>). For example, <code>var_7 * var_8</code> would be rearranged and stored as <code>var_8 * var_7</code>. This helps simplify expressions and provides a useful guarantee: If the variable in the first column (<code>__variable_id</code>) is the Zero Variable (<code>var_0</code>) we know the variable in the second column must also be the Zero Variable and, thus, the term must be a constant.</p>"},{"location":"learn/advanced-concepts/internals/#division","title":"Division","text":"<p>Divisions are rearranged into multiplications when possible. Specifically, <code>a / b</code> is computed as <code>a * (1 / b)</code> (see <code>BaseOperableBlock.__truediv__</code>) except for the special case where <code>a</code> is a <code>float</code> or <code>int</code>. In that case, a Polars operation is used to compute the division (see <code>Expression.__rtruediv__</code>).</p>"},{"location":"learn/advanced-concepts/performance/","title":"Performance tips","text":"<p>Pyoframe is already one of the fastest and most memory-efficient libraries for formulating optimization models. However, if you'd like to squeeze out every bit of performance, here are some additional tips.</p>"},{"location":"learn/advanced-concepts/performance/#use-polars-instead-of-pandas","title":"Use polars instead of pandas","text":"<p>Polars is much faster than Pandas. Moreover, if you use Pandas, there will be a (very small) overhead because Pyoframe converts all DataFrames to Polars prior to computations.</p>"},{"location":"learn/advanced-concepts/performance/#use-integer-labels","title":"Use integer labels","text":"<p>Pyoframe works with any label data type (e.g. string labels, date labels, etc.), but integer labels are fastest and most memory efficient.</p>"},{"location":"learn/advanced-concepts/performance/#disable-maintain_order","title":"Disable <code>maintain_order</code>","text":"<p>By default, Pyoframe ensures that the order of variables, constraints, and mathematical terms is maintained across runs to ensure that your results are reproducible down to the very last decimal place. However, if you're not bothered by miniscule variations in your results due to numerical errors accumulating differently for different orderings, you should disable <code>maintain_order</code>:</p> <pre><code>pf.Config.maintain_order = False\n</code></pre>"},{"location":"learn/advanced-concepts/performance/#disable-checks-for-extra-values","title":"Disable checks for extra values","text":"<p>Disabling checks for extra values means that, instead of raising extra value exceptions, pyoframe will process sums with extra values as if <code>keep_extras</code> had been applied. While this may improve performance, it will silence potentially important errors meant to help you build your model. If you'd like to disable checks for extra values, we recommend you do so only after thoroughly testing your model and ensuring that all potential extra value exceptions have been handled.</p> <p>The following code disables checks for extra values:</p> <pre><code>pf.Config.disable_extras_checks = True\n</code></pre>"},{"location":"learn/advanced-concepts/quadratics/","title":"Quadratic expressions","text":"<p>Quadratic expressions work as you'd expect. Simply multiply two linear expression together (or square an expression with <code>**2</code>) and you'll get a quadratic. The quadratic can then be used in constraints or the objective.</p>"},{"location":"learn/advanced-concepts/quadratics/#example-1-maximize-area-of-box","title":"Example 1: Maximize area of box","text":"<p>Here's a short example that shows that a square maximizes the area of any box with a fixed perimeter.</p> <pre><code>import pyoframe as pf\n\nmodel = pf.Model()\nmodel.w = pf.Variable(lb=0)\nmodel.h = pf.Variable(lb=0)\nmodel.limit_perimter = 2 * (model.w + model.h) &lt;= 20\nmodel.maximize = model.w * model.h\nmodel.optimize()\nprint(f\"It's a square: {model.w.solution == model.h.solution}\")\nprint(f\"With area: {model.objective.value}\")\n\n# Outputs:\n# It's a square: True\n# With area: 25.0\n</code></pre>"},{"location":"learn/advanced-concepts/quadratics/#example-2-facility-location-problem","title":"Example 2: Facility location problem","text":"<p>See examples/facility_location.</p>"},{"location":"learn/advanced-concepts/troubleshooting/","title":"Troubleshooting","text":"<p>Here are some potential errors and how to resolve them.</p>"},{"location":"learn/advanced-concepts/troubleshooting/#datatypes-of-join-keys-dont-match","title":"<code>datatypes of join keys don't match</code>","text":"<p>Often, this error indicates that two columns in your input dataframes, although representing the same dimension, have different datatypes (e.g. 16bit integer and 64bit integer). This is not allowed and you should ensure that for the same dimensions, datatypes are identical.</p>"},{"location":"learn/concepts/addition/","title":"Addition and its quirks","text":"<p>In Pyoframe, <code>Expression</code> objects can be added using the <code>+</code> operator, as you might expect.</p> <p>However, sometimes an addition is ambiguous or indicative of a potential mistake in your model. In these situations, Pyoframe forces you to use addition modifiers to specify exactly how you'd like the addition to be performed. This safety feature helps prevent and quickly fix mistakes in your model.</p> <p>There are three common addition modifiers in Pyoframe: <code>.over(\u2026)</code>, <code>.keep_extras()</code>, and <code>.drop_extras()</code>.</p> <p>Before delving into these addition modifiers, please note that these addition rules also apply to subtraction as well as the <code>&lt;=</code> and <code>&gt;=</code> operators used to create constraints. This is because subtraction is actually computed as an addition (<code>a - b</code> is computed as <code>a + (-b)</code>). Similarly, creating a constraint with the <code>&lt;=</code> or <code>&gt;=</code> operators involves combining the left and right hand sides using addition (<code>a &lt;= b</code> becomes <code>a + (-b) &lt;= 0</code>). So, although I may only mention addition from now on, please remember that this page also applies to subtraction and to constraint creation.</p> <p>The rest of the page is organized as follows:</p> <ol> <li> <p>The <code>.over(\u2026)</code> addition modifier</p> </li> <li> <p>The <code>.keep_extras()</code> and <code>.drop_extras()</code> addition modifiers</p> </li> <li> <p>Important note on the order of operations of addition modifiers</p> </li> </ol>"},{"location":"learn/concepts/addition/#adding-expressions-with-differing-dimensions-using-over","title":"Adding expressions with differing dimensions using <code>.over(\u2026)</code>","text":"<p>To help catch mistakes, adding expressions with differing dimensions is disallowed by default. <code>.over(\u2026)</code> overrides this default and indicates that an addition should be performed by \"broadcasting\" the differing dimensions.</p> <p>The following examples help illustrate when <code>.over(\u2026)</code> should and shouldn't be used.</p>"},{"location":"learn/concepts/addition/#example-1-catching-a-mistake","title":"Example 1: Catching a mistake","text":"<p>Say you're developing an optimization model to study aviation emissions. You'd like to express the sum of in-flight emissions and on-the-ground (taxiing) emissions, for each flight, but when you try to add both <code>Expression</code> objects, you get an error:</p> <pre><code>&gt;&gt;&gt; model.flight_emissions = model.air_emissions + model.ground_emissions\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot add the two expressions below because their\n  dimensions are different (['flight_no'] != ['flight_number']).\nExpression 1:  air_emissions\nExpression 2:  ground_emissions\nIf this is intentional, use .over(\u2026) to broadcast. Learn more at\n  https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition/#adding-expressions-with-differing-dimensions-using-over\n</code></pre> <p>Do you understand what happened? The error informs us that <code>model.air_emissions</code> has dimension <code>flight_no</code>, but <code>model.ground_emissions</code> has dimension <code>flight_number</code>. Oops, the two datasets use slightly different spellings! You can use <code>.rename(\u2026)</code> to correct for the <code>Expression</code> objects having differing dimension names.</p> <pre><code>&gt;&gt;&gt; model.flight_emissions = model.air_emissions + model.ground_emissions.rename({\"flight_number\": \"flight_no\"})\n</code></pre> <p>Benign mistakes like these are relatively common and Pyoframe's error messages help you detect them early. Now, let's examine a case where <code>.over(\u2026)</code> is needed.</p>"},{"location":"learn/concepts/addition/#example-2-broadcasting-with-over","title":"Example 2: Broadcasting with <code>.over(\u2026)</code>","text":"<p>Say, you'd like to see what happens if, instead of minimizing total emissions, you were to minimize the emissions of the most emitting flight. Mathematically, this is equivalent to minimizing variable <code>E_max</code> where <code>E_max</code> is constrained to be greater or equal to the emissions of every flight.</p> <p>You try to express this constraint in Pyoframe, but get an error:</p> <pre><code>&gt;&gt;&gt; model.E_max = pf.Variable()\n&gt;&gt;&gt; model.minimize = model.E_max\n&gt;&gt;&gt; model.emission_constraint = model.E_max &gt;= model.flight_emissions\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot subtract the two expressions below because their\n    dimensions are different ([] != ['flight_no']).\nExpression 1:  E_max\nExpression 2:  flight_emissions\nIf this is intentional, use .over(\u2026) to broadcast. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition/#adding-expressions-with-differing-dimensions-using-over\n</code></pre> <p>The error indicates that <code>E_max</code> has no dimensions but <code>flight_emissions</code> has dimensions <code>flight_no</code>. The error is raised because, by default, combining terms with differing dimensions is not allowed (as explained in example 1).</p> <p>What we'd like to do is effectively 'copy' (aka. 'broadcast') <code>E_max</code> over every flight number. <code>E_max.over(\"flight_no\")</code> does just this:</p> <pre><code>&gt;&gt;&gt; model.E_max.over(\"flight_no\")\n&lt;Expression (linear) terms=1&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2506 expression \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 *         \u2506 E_max      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Notice how applying <code>.over(\"flight_no\")</code> added a dimension <code>flight_no</code> with value <code>*</code>. The asterix (<code>*</code>) indicates that <code>flight_no</code> will take the shape of whichever expression <code>E_max</code> is later combined with. Since <code>E_max</code> is being combined with <code>flight_emissions</code>, <code>*</code> will be replaced with an entry for every flight number in <code>flight_emissions</code>. Now creating our constraint works properly:</p> <pre><code>&gt;&gt;&gt; model.emission_constraint = model.E_max.over(\"flight_no\") &gt;= model.flight_emissions\n&gt;&gt;&gt; model.emission_constraint\n&lt;Constraint 'emission_constraint' (linear) height=2 terms=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2506 constraint                    \u2502\n\u2502 (2)       \u2506                               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A4543     \u2506 E_max -1.4\u00a0Fly[A4543] &gt;=\u00a00.02 \u2502\n\u2502 K937      \u2506 E_max -2.4\u00a0Fly[K937] &gt;=\u00a00.05  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/concepts/addition/#handling-extra-labels-with-keep_extras-and-drop_extras","title":"Handling 'extra' labels with <code>.keep_extras()</code> and <code>.drop_extras()</code>","text":"<p>Addition is performed by pairing the labels in the left <code>Expression</code> with those in the right <code>Expression</code>. But, what happens when the left and right labels differ?</p> <p>If one of the two expressions in an addition has extras labels not present in the other, <code>.keep_extras()</code> or <code>.drop_extras()</code> must be used to indicate how the extra labels should be handled.</p>"},{"location":"learn/concepts/addition/#example-3-deciding-how-to-handle-extra-labels","title":"Example 3: Deciding how to handle extra labels","text":"<p>Consider again example 1 where we added air emissions and ground emissions. Let's say that you fixed the error in example 1, but when you try the addition again you get the following error:</p> <pre><code>&gt;&gt;&gt; model.air_emissions + model.ground_emissions\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot add the two expressions below because expression 1 has extra labels.\nExpression 1:       air_emissions\nExpression 2:       ground_emissions\nExtra labels in expression 1:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 D2082     \u2502\n\u2502 D8432     \u2502\n\u2502 D1206     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nUse .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n</code></pre> <p>Do you understand what happened? The error explains that <code>air_emissions</code> contains flight numbers that are not present in <code>ground_emissions</code> (specifically flight numbers <code>D2082</code>, <code>D8432</code>, and <code>D1206</code>). Your ground emissions dataset is missing some flights!</p> <p>Pyoframe raised an error because it is unclear how you'd like the addition to be performed. In fact, you have three options:</p> <ol> <li>Decide to discard all flights with missing ground data (<code>model.air_emissions.drop_extras()</code>).</li> <li>Decide to keep all flights, assuming <code>0</code> ground emissions when the data is missing (<code>model.air_emissions.keep_extras()</code>).</li> <li>Go back to your data processing and fix the root cause of the missing data.</li> </ol> <p>After investigating, you realize that the data is missing because the ground emissions for those flights were negligible. As such, you decide to use <code>.keep_extras()</code> (option 2), effectively setting ground emissions to <code>0</code> whenever the data is missing.</p> <p>Let's try again!</p> <pre><code>&gt;&gt;&gt; model.air_emissions.keep_extras() + model.ground_emissions\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot add the two expressions below because expression 2 has extra labels.\nExpression 1:   air_emissions.keep_extras()\nExpression 2:   ground_emissions\nExtra labels in expression 2:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 B3420     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nUse .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n</code></pre> <p>Argh, another error! Do you understand what happened? This time <code>ground_emissions</code> has extra labels: flight <code>B3420</code> is present in <code>ground_emissions</code> but not <code>air_emissions</code>. Again, Pyoframe raised an error because it is unclear what should be done:</p> <ol> <li>Discard flight <code>B3420</code> because the air emissions data is missing.</li> <li>Keep flight <code>B3420</code>, assuming the air emissions data is <code>0</code>.</li> <li>Go back to your data processing and fix the root cause of the missing air emissions data.</li> </ol> <p>Option 2 hardly seems reasonable this time considering that air emissions make up the majority of a flight's emissions. You end up deciding to discard the flight entirely (option 1) using <code>.drop_extras()</code>. Now, the addition works perfectly!</p> <pre><code>&gt;&gt;&gt; model.air_emissions.keep_extras() + model.ground_emissions.drop_extras()\n&lt;Expression (parameter) height=5 terms=5&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2506 expression \u2502\n\u2502 (5)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A4543     \u2506 1.42       \u2502\n\u2502 K937      \u2506 2.45       \u2502\n\u2502 D2082     \u2506 4          \u2502\n\u2502 D8432     \u2506 7.6        \u2502\n\u2502 D1206     \u2506 4          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/concepts/addition/#order-of-operations-for-addition-modifiers","title":"Order of operations for addition modifiers","text":"<p>When an operation creates a new Expression, any previously applied addition modifiers are discarded to prevent unexpected behaviors. As such, addition modifiers only work if they're applied right before an addition. For example, <code>a.drop_extras().sum(\"time\") + b</code> won't work but <code>a.sum(\"time\").drop_extras() + b</code> will.</p> <p>There are two exceptions to this rule:</p> <ol> <li> <p>Negation. Negation preserves addition modifiers. If it weren't for this exception, <code>-my_obj.drop_extras()</code> wouldn't work as expected; you would have to write <code>(-my_obj).drop_extras()</code> which is unintuitive!</p> </li> <li> <p>Addition/subtraction. A <code>.keep_extras()</code> or <code>.drop_extras()</code> in the left and/or right side of an addition or subtraction is preserved in the result because this allows you to write     <pre><code>a.keep_extras() + b.keep_extras() + c.keep_extras()\n</code></pre>     instead of the annoyingly verbose,     <pre><code>(a.keep_extras() + b.keep_extras()).keep_extras() + c.keep_extras()\n</code></pre>     (If the left and right sides have conflicting addition modifiers, e.g., <code>a.keep_extras() + b.drop_extras()</code>, no addition modifiers are preserved. Also, if you'd like an addition or subtraction not to preserve addition modifiers, you can force the result back to the default of raising errors whenever there are extra labels by using <code>.raise_extras()</code>.)</p> </li> </ol>"},{"location":"learn/concepts/solver-access/","title":"Solver interface","text":"<p>Pyoframe provides a friendly API that allows you to read and set the various attributes and parameters your solver has to offer.</p>"},{"location":"learn/concepts/solver-access/#model-attributes","title":"Model attributes","text":"<p>Pyoframe lets you read and set solver attributes using <code>model.attr.&lt;your-attribute&gt;</code>. For example, if you'd like to prevent the solver from printing to the console you can do:</p> <pre><code>m = pf.Model()\nm.attr.Silent = True\n</code></pre> <p>Pyoframe supports a set of standard attributes as well as additional Gurobi attributes and COPT attributes.</p> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus  # PyOptInterface attribute (always available)\n&lt;TerminationStatusCode.OPTIMAL: 2&gt;\n&gt;&gt;&gt; m.attr.Status  # Gurobi attribute (only available with Gurobi)\n2\n</code></pre>"},{"location":"learn/concepts/solver-access/#model-parameters","title":"Model parameters","text":"<p>Every solver has a set of parameters that you can read or set using <code>model.params.&lt;your-param&gt;</code>.</p> GurobiCOPTHiGHSIpopt <p>Refer to the list of Gurobi parameters.</p> <pre><code>m = pf.Model(\"gurobi\")\nm.params.Method = 2  # Use barrier method\nm.params.TimeLimit = 100\n</code></pre> <p>Refer to the list of COPT parameters.</p> <pre><code>m = pf.Model(\"copt\")\nm.params.RelGap = 0.01\nm.params.TimeLimit = 100\n</code></pre> <p>Refer to the list of HiGHS options.</p> <pre><code>m = pf.Model(\"highs\")\nm.params.time_limit = 100.0\nm.params.mip_rel_gap = 0.01\n</code></pre> <p>Refer to the list of Ipopt options.</p> <pre><code>m = pf.Model(\"ipopt\")\nm.params.tol = 1e-6\nm.params.max_iter = 1000\n</code></pre> <p>Warning</p> <p>Ipopt does not support reading parameters (only setting them).</p>"},{"location":"learn/concepts/solver-access/#variable-and-constraint-attributes","title":"Variable and constraint attributes","text":"<p>Similar to above, Pyoframe allows directly accessing the PyOptInterface or the solver's variable and constraint attributes.</p> <pre><code>m = pf.Model()\nm.X = pf.Variable()\nm.X.attr.PrimalStart = 5  # Set initial value for warm start\n</code></pre> <p>If the variable or constraint is dimensioned, the attribute can accept/return a DataFrame instead of a constant.</p>"},{"location":"learn/concepts/solver-access/#license-configuration-copt-and-gurobi","title":"License configuration (COPT and Gurobi)","text":"<p>Both COPT and Gurobi support advanced license configurations through the <code>solver_env</code> parameter:</p> COPTGurobi <pre><code># Cluster configuration\nm = pf.Model(\"copt\", solver_env={\"CLIENT_CLUSTER\": \"cluster.example.com\"})\n</code></pre> <pre><code># Compute server\nm = pf.Model(\n    \"gurobi\",\n    solver_env={\"ComputeServer\": \"server.example.com\", \"ServerPassword\": \"password\"},\n)\n</code></pre>"},{"location":"learn/concepts/special-functions/","title":"Transforms","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>Pyoframe has a few special functions that make working with dataframes easy and intuitive. Here they are:</p>"},{"location":"learn/concepts/special-functions/#sum-and-sum_by","title":"<code>sum</code> and <code>sum_by</code>","text":""},{"location":"learn/concepts/special-functions/#expressionmap","title":"<code>Expression.map()</code>","text":""},{"location":"learn/get-started/basics/","title":"Learn the basics","text":"<p>Now that you've gotten a sense of what Pyoframe can do, it's time to learn how to build your own optimization models from scratch.</p> <p>Building a Pyoframe model involves only a few steps. Each of the following sections describes one of those steps.</p> <ol> <li>Create the <code>Model</code></li> <li>Add decision variables</li> <li>Formulate key mathematical expressions</li> <li>Add constraints</li> <li>Set the objective</li> <li>Optimize!</li> <li>Retrieve results</li> </ol>"},{"location":"learn/get-started/basics/#create-a-model","title":"Create a model","text":"<p>Creating a model is simple:</p> <pre><code>import pyoframe as pf\n\nm = pf.Model()\n</code></pre> <p>By default, Pyoframe will try to use whichever solver is installed on your computer. To specify a particular solver write, e.g.: <code>pf.Model(solver=\"highs\")</code>. Refer to Model for more configuration options.</p>"},{"location":"learn/get-started/basics/#define-variables","title":"Define variables","text":"<p>Like most Pyoframe objects, variables can either be dimensionless or dimensioned. Let's start with the simpler dimensionless case.</p>"},{"location":"learn/get-started/basics/#dimensionless-variables","title":"Dimensionless variables","text":"<p>The syntax to add a variable to a model is:</p> <pre><code>m.My_Var = pf.Variable()  # (1)!\n</code></pre> <ol> <li>Curious to know why this works? Pyoframe overrides the <code>__setattr__</code> method of the <code>Model</code> class such that whenever you set a new attribute (in this case <code>My_Var</code>), the <code>Model</code> object records it and adds it to your solver.</li> </ol> <p>By default, variables are unbounded. To set a lower or upper bound, use the <code>lb</code> or <code>ub</code> arguments:</p> <pre><code>m.My_Positive_Var = pf.Variable(lb=0)\n</code></pre> <p>Create integer or binary variables using the VType enum or simply a string:</p> <pre><code>m.My_Binary_Var = pf.Variable(vtype=\"binary\")\nm.My_Integer_Var = pf.Variable(vtype=\"integer\")\n</code></pre> <p>Naming variables</p> <p>I like to use upper case names for variables (i.e. <code>m.My_Var</code> instead of <code>m.my_var</code>) because it makes them easy to distinguish. But you're free to choose any name you like.</p>"},{"location":"learn/get-started/basics/#dimensioned-variables","title":"Dimensioned variables","text":"<p>Often, you'll want to create a variable for every row in your data. To do so, simply pass your data to <code>pf.Variable</code>.</p> <p>For example, in the following code, <code>m.WeekDay_Var</code> contains 5 variables, one for each weekday:</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"weekday\": [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"]})\n\nm.WeekDay_Var = pf.Variable(df)\n</code></pre> <p>You can confirm this by printing the variable:</p> <pre><code>&gt;&gt;&gt; m.WeekDay_Var\n&lt;Variable 'WeekDay_Var' height=5&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 weekday \u2506 variable         \u2502\n\u2502 (5)     \u2506                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Mon     \u2506 WeekDay_Var[Mon] \u2502\n\u2502 Tue     \u2506 WeekDay_Var[Tue] \u2502\n\u2502 Wed     \u2506 WeekDay_Var[Wed] \u2502\n\u2502 Thu     \u2506 WeekDay_Var[Thu] \u2502\n\u2502 Fri     \u2506 WeekDay_Var[Fri] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If you pass multiple arguments to <code>pf.Variable</code>, the cartesian product will be computed. For example:</p> <pre><code>&gt;&gt;&gt; chaoticness = pf.Set(chaoticness=[\"lawful\", \"neutral\", \"chaotic\"])\n&gt;&gt;&gt; goodness = pf.Set(goodness=[\"good\", \"neutral\", \"evil\"])\n&gt;&gt;&gt; m.Personality = pf.Variable(chaoticness, goodness)\n&gt;&gt;&gt; m.Personality\n&lt;Variable 'Personality' height=9&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 chaoticness \u2506 goodness \u2506 variable                     \u2502\n\u2502 (3)         \u2506 (3)      \u2506                              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 lawful      \u2506 good     \u2506 Personality[lawful,good]     \u2502\n\u2502 lawful      \u2506 neutral  \u2506 Personality[lawful,neutral]  \u2502\n\u2502 lawful      \u2506 evil     \u2506 Personality[lawful,evil]     \u2502\n\u2502 neutral     \u2506 good     \u2506 Personality[neutral,good]    \u2502\n\u2502 neutral     \u2506 neutral  \u2506 Personality[neutral,neutral] \u2502\n\u2502 neutral     \u2506 evil     \u2506 Personality[neutral,evil]    \u2502\n\u2502 chaotic     \u2506 good     \u2506 Personality[chaotic,good]    \u2502\n\u2502 chaotic     \u2506 neutral  \u2506 Personality[chaotic,neutral] \u2502\n\u2502 chaotic     \u2506 evil     \u2506 Personality[chaotic,evil]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>In this last example, we used <code>pf.Set</code> instead of a <code>DataFrame</code>. <code>Variable</code> actually accepts a variety of input data types. The following tabs show equivalent ways of creating the same variable.</p> <code>DataFrame</code><code>Series</code><code>Index</code><code>dict</code><code>Set</code> <p>A variable is created for ever row in the pandas or polars <code>DataFrame</code> and labelled according to the values in that row. Column names become the dimension names. Pandas indexes are ignored.</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"day\": [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"]})\nm.Example_1 = pf.Variable(df)\n</code></pre> <p>A pandas or polars <code>Series</code> is treated as a 1-column DataFrame. Pandas indexes are ignored.</p> <pre><code>import pandas as pd\n\nseries = pd.Series([\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"], name=\"day\")\nm.Example_2 = pf.Variable(series)\n</code></pre> <p>A pandas <code>Index</code> is treated like a <code>DataFrame</code>.</p> <pre><code>import pandas as pd\n\nseries = pd.Index([\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"], name=\"day\")\nm.Example_3 = pf.Variable(series)\n</code></pre> <p>Dictionaries are shortcuts for writing <code>pf.Variable(pl.DataFrame(dict_data))</code>.</p> <pre><code>m.Example_4 = pf.Variable({\"day\": [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"]})\n</code></pre> <p>Pyoframe offers a Set class to easily define dimensioned variables in a reusable way.</p> <pre><code>weekdays = pf.Set(day=[\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"])\nm.Example_5 = pf.Variable(weekdays)\n</code></pre>"},{"location":"learn/get-started/basics/#formulate-expressions","title":"Formulate expressions","text":"<p>Mathematical expressions are represented by the <code>Expression</code> class which is automatically formed when standard arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>) are used to combine variables with numbers, other variables, or other Expressions. When computing mathematical operations, Pyoframe will automatically align your labels and dimensions.</p> <p>For example, consider the following model:</p> <pre><code>import pyoframe as pf\n\nm = pf.Model()\nm.Hours_Worked = pf.Variable({\"day\": [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"]}, lb=0)\nm.Hours_Sleep = pf.Variable({\"day\": [\"Fri\", \"Thu\", \"Wed\", \"Tue\", \"Mon\"]}, lb=0)\nm.hours_remaining = 24 - m.Hours_Worked - m.Hours_Sleep\n</code></pre> <p>Notice how the order of the days in <code>Hours_Sleep</code> is reversed. This is no problem because Pyoframe detects that the dimensions match (since they're both named <code>day</code>) and will align the labels:</p> <pre><code>&gt;&gt;&gt; m.hours_remaining\n&lt;Expression (linear) height=5 terms=15&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 day \u2506 expression                                \u2502\n\u2502 (5) \u2506                                           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Mon \u2506 24 -\u00a0Hours_Worked[Mon] -\u00a0Hours_Sleep[Mon] \u2502\n\u2502 Tue \u2506 24 -\u00a0Hours_Worked[Tue] -\u00a0Hours_Sleep[Tue] \u2502\n\u2502 Wed \u2506 24 -\u00a0Hours_Worked[Wed] -\u00a0Hours_Sleep[Wed] \u2502\n\u2502 Thu \u2506 24 -\u00a0Hours_Worked[Thu] -\u00a0Hours_Sleep[Thu] \u2502\n\u2502 Fri \u2506 24 -\u00a0Hours_Worked[Fri] -\u00a0Hours_Sleep[Fri] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/get-started/basics/#using-parameters","title":"Using parameters","text":"<p>Often, our models need to incorporate external data. To do this, we need to use parameters.</p> <p>In Pyoframe, a parameter is actually just an Expression that does not contain any Variables (aka. a constant).</p> <p>You can convert your data to a parameter by passing it to <code>pf.Param(data)</code>. The last column of the data is always treated as the parameter value, and all other columns are treated as labels. (See Param for other ways to create parameters.)</p> <p>For example, consider the following code that integrates the <code>holidays</code> DataFrame into a pay calculation:</p> <pre><code>import pandas as pd\nimport pyoframe as pf\n\nholidays = pd.DataFrame(\n    {\"day\": [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"], \"is_holiday\": [0, 0, 0, 0, 1]}\n)\nbase_pay = 20\nholiday_bonus = 10\n\nm = pf.Model()\nm.is_holiday = pf.Param(holidays)\nm.Hours_Worked = pf.Variable(holidays[\"day\"], lb=0)\nm.pay = m.Hours_Worked * (base_pay + m.is_holiday * holiday_bonus)\n</code></pre> <p>Here, <code>m.is_holiday</code> is a parameter Expression:</p> <pre><code>&gt;&gt;&gt; m.is_holiday\n&lt;Expression (parameter) height=5 terms=5&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 day \u2506 expression \u2502\n\u2502 (5) \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Mon \u2506 0          \u2502\n\u2502 Tue \u2506 0          \u2502\n\u2502 Wed \u2506 0          \u2502\n\u2502 Thu \u2506 0          \u2502\n\u2502 Fri \u2506 1          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>And the resulting <code>m.pay</code> Expression correctly incorporates the holiday bonus only on Fridays:</p> <pre><code>&gt;&gt;&gt; m.pay\n&lt;Expression (linear) height=5 terms=5&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 day \u2506 expression           \u2502\n\u2502 (5) \u2506                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Mon \u2506 20\u00a0Hours_Worked[Mon] \u2502\n\u2502 Tue \u2506 20\u00a0Hours_Worked[Tue] \u2502\n\u2502 Wed \u2506 20\u00a0Hours_Worked[Wed] \u2502\n\u2502 Thu \u2506 20\u00a0Hours_Worked[Thu] \u2502\n\u2502 Fri \u2506 30\u00a0Hours_Worked[Fri] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Note that often, you can skip defining parameters because whenever a Pyoframe object is combined with a DataFrame, Pyoframe will automatically convert the DataFrame to a parameter Expression. For example, the following works just fine:</p> <pre><code>&gt;&gt;&gt; m.bonus_pay = m.Hours_Worked * holidays * holiday_bonus\n&gt;&gt;&gt; m.bonus_pay\n&lt;Expression (linear) height=5 terms=5&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 day \u2506 expression           \u2502\n\u2502 (5) \u2506                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Mon \u2506 0                    \u2502\n\u2502 Tue \u2506 0                    \u2502\n\u2502 Wed \u2506 0                    \u2502\n\u2502 Thu \u2506 0                    \u2502\n\u2502 Fri \u2506 10\u00a0Hours_Worked[Fri] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/get-started/basics/#transforms","title":"Transforms","text":"<p>The page on Transforms describes additional ways to formulate Expressions (e.g. using <code>.sum(\u2026)</code>, <code>.map(\u2026)</code>, <code>.next(\u2026)</code>).</p>"},{"location":"learn/get-started/basics/#add-constraints","title":"Add constraints","text":"<p>Create constraints by using the <code>&lt;=</code>, <code>&gt;=</code>, and <code>==</code> operators between Expressions. For example:</p> <pre><code>m.Con_Max_Weekly_Hours = m.Hours_Worked.sum() &lt;= 40\n</code></pre> <p>You can easily relax a constraint using the <code>.relax(cost, max)</code> method.</p> <p>(It might be helpful to know that, internally, Pyoframe rearranges all constraint <code>a &lt;= b</code> into the standard form <code>a - b &lt;= 0</code> so that only a single left-hand-side Expression needs to be stored.)</p> <p>Naming constraints</p> <p>I like prefixing constraint names with <code>Con_</code> to easily distinguish them from variables and expressions.</p>"},{"location":"learn/get-started/basics/#set-the-objective","title":"Set the objective","text":"<p>Set the objective by assigning an Expression to either the <code>.minimize</code> or <code>.maximize</code> attribute of the Model. For example:</p> <pre><code>m.minimize = m.Hours_Worked.sum()\n</code></pre> <p>Note that the objective Expression must be dimensionless; you cannot have multiple objectives with different labels. This is why we use <code>.sum()</code> to aggregate over all days.</p>"},{"location":"learn/get-started/basics/#optimize","title":"Optimize!","text":"<p>Optimizing your model is as simple as calling the <code>.optimize()</code> method:</p> <pre><code>m.optimize()\n</code></pre> <p>Read the Solver interface page for more information on configuring and using solvers.</p>"},{"location":"learn/get-started/basics/#retrieve-results","title":"Retrieve results","text":"<p>Use <code>.solution</code> to read the optimal values of Variables after optimization (e.g. <code>m.Hours_Worked.solution</code>). For dimensioned variables, <code>.solution</code> returns a polars DataFrame.</p> <p>Similarly, use <code>.dual</code> to read the dual values (aka. shadow prices) of Constraints (e.g. <code>m.Con_Max_Weekly_Hours.dual</code>).</p> <p>You can also output your model problem or solution using <code>.write(\u2026)</code>.</p> <p>Returning Pandas DataFrames</p> <p>Pyoframe currently always returns Polars DataFrames but you can easily convert them to Pandas using <code>.to_pandas()</code>. In the future, we plan to add support for automatically returning Pandas DataFrames. Upvote the issue if you'd like this feature.</p>"},{"location":"learn/get-started/installation/","title":"Install","text":""},{"location":"learn/get-started/installation/#step-1-install-pyoframe","title":"Step 1: Install Pyoframe","text":"<p>Install Pyoframe using your preferred package manager:</p> pipuv <pre><code>pip install pyoframe\n</code></pre> <pre><code>uv add pyoframe\n</code></pre>"},{"location":"learn/get-started/installation/#step-2-choose-a-solver","title":"Step 2: Choose a solver","text":"<p>Pyoframe makes it easy to build models, but a separate solver is needed to solve the model after it is built. Use the compatibility table below to choose a solver that fits your needs. If you're unsure, choose HiGHS. Note that both Gurobi and COPT offer free licenses for academics.</p> Compatibility table HiGHS (free) Gurobi (paid) COPT (paid) Ipopt (free) Linear programs (LPs) \u2705 \u2705 \u2705 \u2705 Mixed integer programs (MIPs) \u2705* \u2705 \u2705 \u274c Quadratic objective (convex) \u2705 \u2705 \u2705 \u2705 Quadratic objective (non-convex) \u274c \u2705 \u274c \u2705 Quadratic constraints (convex) \u274c \u2705 \u2705 \u2705 Quadratic constraints (non-convex) \u274c \u2705 \u274c \u2705 *Integer variables cannot be used with quadratic objectives. <p>Don't see your preferred solver?</p> <p>Don't hesitate to request another solver. We would gladly consider adding support for other solvers, particularly Mosek which would be easy to support given sufficient interest.</p>"},{"location":"learn/get-started/installation/#step-3-install-the-solver","title":"Step 3: Install the solver","text":"<p>Select your chosen solver and follow the installation instructions.</p> HiGHSGurobiCOPTIpopt <p>To install HiGHS run:</p> <pre><code>pip install pyoframe[highs]\n</code></pre> <p>To install Gurobi:</p> <ol> <li>Download Gurobi from their website (login required) and follow the installation instructions.</li> <li>Ensure you have a valid Gurobi license installed on your machine. (If you're using Gurobi Compute Server or other atypical licensing setups, refer to License configuration.)</li> </ol> <p>Do not install Gurobi using <code>pip</code></p> <p>You should not install Gurobi using <code>pip</code> because Pyoframe uses Gurobi's C API, which the <code>pip</code> installation does not include.</p> <p>To install COPT:</p> <ol> <li>Download COPT from the e-mail you received after requesting a license and follow the installation instructions.</li> <li>Ensure you have valid COPT license files on your machine. (If you're using floating, cluster, or web licenses refer to License configuration.)</li> <li>Set the <code>COPT_HOME</code> environment variable to point to your COPT installation directory.</li> </ol> <p>To install ipopt:</p> <ol> <li>Run: <pre><code>pip install pyoframe[ipopt]\n</code></pre></li> <li>Download the Ipopt binaries from GitHub. Version 3.14.x is recommended since it is the latest version that we've tested.</li> <li>On Windows, unpack the zip and add the <code>bin</code> folder to your Path variable. If not on Windows, you may have to build the solver from source, see further details here.</li> </ol>"},{"location":"learn/get-started/basic-example/example-with-dimensions/","title":"Integrate DataFrames","text":"<p>You are going to re-build the previous example using a dataset, <code>food_data.csv</code>, instead of hard-coded values. This way, you can add as many vegetarian proteins as you like without needing to write more code. If you're impatient, skip to the end to see the final result.</p> <p>Pyoframe is built on DataFrames</p> <p>Most other optimization libraries require you to convert your data from its <code>DataFrame</code> format to another format.<sup>1</sup> Not Pyoframe! DataFrames form the core of Pyoframe making it easy to seamlessly \u2014 and efficiently \u2014 integrate large datasets into your models.</p>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#the-data","title":"The data","text":"<p>You can download the CSV file from here or create it yourself with the following content:</p> <p><code>food_data.csv</code></p> food protein cost tofu_block 18 4 chickpea_can 15 3"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-1-load-the-data","title":"Step 1: Load the data","text":"<p>Load <code>food_data.csv</code> using Polars or Pandas.</p> PolarsPandas <pre><code>import polars as pl\n\ndata = pl.read_csv(\"food_data.csv\")\n</code></pre> <pre><code>import pandas as pd\n\ndata = pd.read_csv(\"food_data.csv\")\n</code></pre> <p>Pandas vs. Polars: Which should I use?</p> <p>Pyoframe works the same whether you're using Polars or Pandas, two similar libraries for manipulating data with DataFrames. We prefer using Polars because it is much faster (and generally better), but you can use whichever library you're most comfortable with.</p> <p>Note that, internally, Pyoframe always uses Polars during computations to ensure the best performance. If you're using Pandas, your DataFrames will automatically be converted to Polars prior to computations.</p>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-2-create-the-model","title":"Step 2: Create the model","text":"<pre><code>import pyoframe as pf\n\nm = pf.Model()\n</code></pre> <p>A <code>pyoframe.Model</code> instance sets the foundation of your optimization model onto which you can add optimization variables, constraints, and an objective.</p>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-3-create-a-dimensioned-variable","title":"Step 3: Create a dimensioned variable","text":"<p>Previously, you created two variables: <code>m.tofu_blocks</code> and <code>m.chickpea_cans</code>. Instead, create a single variable dimensioned over the column <code>food</code>.</p> <pre><code>m.Buy = pf.Variable(data[\"food\"], lb=0, vtype=\"integer\")\n</code></pre> <p>Printing the variable shows that it contains a <code>food</code> dimension with labels <code>tofu</code> and <code>chickpeas</code>!</p> <pre><code>&gt;&gt;&gt; m.Buy\n&lt;Variable 'Buy' lb=0 height=2&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food         \u2506 variable          \u2502\n\u2502 (2)          \u2506                   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 tofu_block   \u2506 Buy[tofu_block]   \u2502\n\u2502 chickpea_can \u2506 Buy[chickpea_can] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-3-create-the-objective-with-sum","title":"Step 3: Create the objective with <code>.sum()</code>","text":"<p>Previously you had:</p> <pre><code>m.minimize = 4 * m.tofu_blocks + 3 * m.chickpea_cans\n</code></pre> <p>How do you make use of the dimensioned variable <code>m.Buy</code> instead?</p> <p>First, multiply the variable by the protein amount.</p> <pre><code>&gt;&gt;&gt; data[[\"food\", \"cost\"]] * m.Buy\n&lt;Expression (linear) height=2 terms=2&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food         \u2506 expression          \u2502\n\u2502 (2)          \u2506                     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 tofu_block   \u2506 4\u00a0Buy[tofu_block]   \u2502\n\u2502 chickpea_can \u2506 3\u00a0Buy[chickpea_can] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>As you can see, Pyoframe with a bit of magic converted the <code>Variable</code> into an <code>Expression</code> where the coefficients are the protein amounts.</p> <p>Second, notice that the <code>Expression</code> still has the <code>food</code> dimension\u2014it really contains two separate expressions, one for tofu and one for chickpeas. All objective functions must be a single expression (without dimensions) so let's sum over the <code>food</code> dimension.</p> <pre><code>&gt;&gt;&gt; (data[[\"food\", \"cost\"]] * m.Buy).sum(\"food\")\n&lt;Expression (linear) terms=2&gt;\n4\u00a0Buy[tofu_block] +3\u00a0Buy[chickpea_can]\n</code></pre> <p>This works and since <code>food</code> is the only dimensions you don't even need to specify it. Putting it all together:</p> <pre><code>m.minimize = (data[[\"food\", \"cost\"]] * m.Buy).sum()\n</code></pre>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-4-add-the-constraint","title":"Step 4: Add the constraint","text":"<p>This is similar to how you created the objective, except now you're using <code>protein</code> and you turn the <code>Expression</code> into a <code>Constraint</code> with the <code>&gt;=</code> operation.</p> <pre><code>m.protein_constraint = (data[[\"food\", \"protein\"]] * m.Buy).sum() &gt;= 50\n</code></pre>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#put-it-all-together","title":"Put it all together","text":"<p>If you've followed the steps above your code should look like:</p> <pre><code>import pandas as pd\nimport pyoframe as pf\n\ndata = pd.read_csv(\"food_data.csv\")\n\nm = pf.Model()\nm.Buy = pf.Variable(data[\"food\"], lb=0, vtype=\"integer\")\nm.minimize = (data[[\"food\", \"cost\"]] * m.Buy).sum()\nm.protein_constraint = (data[[\"food\", \"protein\"]] * m.Buy).sum() &gt;= 50\n\nm.optimize()\n</code></pre> <p>And you can retrieve the problem's solution as follows:</p> <pre><code>&gt;&gt;&gt; m.Buy.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food         \u2506 solution \u2502\n\u2502 ---          \u2506 ---      \u2502\n\u2502 str          \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 tofu_block   \u2506 2        \u2502\n\u2502 chickpea_can \u2506 1        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Since <code>m.Buy</code> is dimensioned, <code>m.Buy.solution</code> returned a DataFrame with the solution for each of the labels!</p> <ol> <li> <p>For example, Pyomo converts your DataFrames to individual Python objects, Linopy uses multi-dimensional matrices via xarray, and gurobipy requires Python lists, dictionaries and tuples. While gurobipy-pandas uses dataframes, it only works with Gurobi!\u00a0\u21a9</p> </li> </ol>"},{"location":"learn/get-started/basic-example/example/","title":"Solve a simple problem","text":"<p>To start, you will solve a simple optimization problem with Pyoframe.</p> <p>Problem statement</p> <p>Imagine you're a vegetarian hesitating between tofu and chickpeas as a source of protein for tomorrow's dinner. You'd like to spend as little money as possible while still consuming at least 50g of protein. How many blocks of tofu ($4 each, 18g of protein) and cans of chickpeas ($3 each, 15g of protein) should you buy?</p> <p>Click on the  buttons below to understand the code, and then run it on your computer.</p> <pre><code>import pyoframe as pf\n\nm = pf.Model()\n\n# You can buy tofu or chickpeas\nm.tofu_blocks = pf.Variable(lb=0, vtype=\"integer\")  # (1)!\nm.chickpea_cans = pf.Variable(lb=0, vtype=\"integer\")\n\n# You want to minimize your cost\nm.minimize = 4 * m.tofu_blocks + 3 * m.chickpea_cans  # (2)!\n\n# But still consume enough protein\nm.protein_constraint = 18 * m.tofu_blocks + 15 * m.chickpea_cans &gt;= 50  # (3)!\n\nm.optimize()  # (4)!\n\nprint(\"Tofu blocks:\", m.tofu_blocks.solution)\nprint(\"Chickpea cans:\", m.chickpea_cans.solution)\n</code></pre> <ol> <li> <p><code>lb=0</code> set a lower bound so that you can't buy negative amounts of tofu. </p> <p><code>vtype=\"integer\"</code> ensures that you can't buy a fraction of a block.</p> </li> <li> <p><code>minimize</code> and <code>maximize</code> are reserved variable names that can be used to set the objective.</p> </li> <li>Pyoframe constraints are easily created with the <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code> operators.</li> <li>Pyoframe automatically detects the solver you have installed; no need to specify it!</li> </ol> <p>After running the code you should get:</p> <pre><code>Tofu blocks: 2\nChickpea cans: 1\n</code></pre> <p>On the next page, you'll resolve this problem but instead of hard-coded values, you'll use DataFrames, Pyoframe's secret sauce!</p>"},{"location":"learn/migrate/v1.0/","title":"Migrate to Pyoframe v1.0","text":"<p>Pyoframe version 1.0 brings major improvements </p> <ul> <li>New features including support for the Ipopt solver, the COPT solver, and the ability to improve performance with <code>pf.Config.maintain_order=False</code>.</li> <li>Bug fixes: notably with <code>Variable(equals=\u2026)</code> not properly parsing DataFrames.</li> <li>Improved performance after rewriting internal functions based on extensive benchmarking.</li> <li>Smoother developer experience, notably error messages explain the mathematical operations that led to an error and Pyoframe objects now print as legible tables.</li> <li>Improved documentation including a revamped API page, an examples page, new explanations of functions like <code>.over(\u2026)</code>, and the ability to view previous versions of the documentation.</li> <li>More readable syntax like our decision to rename <code>add_dim</code> to <code>over</code> and the changes to <code>.sum()</code> (see below).</li> </ul> <p>Unfortunately, these improvements involve some breaking changes. This page will guide you in migrating your code to v1.0.</p>"},{"location":"learn/migrate/v1.0/#breaking-changes","title":"Breaking changes","text":"<p>Summary:</p> <ol> <li><code>pf.Model(\u2026)</code> has a new signature</li> <li><code>pf.sum(\u2026, obj)</code> was replaced by <code>obj.sum(\u2026)</code></li> <li><code>add_dim(\u2026)</code> was renamed to <code>over(\u2026)</code></li> <li><code>keep_unmatched()</code> and <code>drop_unmatched</code> were renamed to <code>keep_extras()</code> and <code>drop_extras()</code></li> <li>Other less common breaking changes</li> </ol> <p>Follow the steps below to upgrade to v1.0.</p>"},{"location":"learn/migrate/v1.0/#1-update-all-calls-to-pfmodel","title":"1. Update all calls to <code>pf.Model(\u2026)</code>","text":"<p>The signature of <code>pf.Model(\u2026)</code> has changed from</p> <pre><code>Model(name=None, solver=None, solver_env=None, use_var_names=False, sense=None)\n</code></pre> <p>to</p> <pre><code>Model(solver=None, solver_env=None, *, name=None, solver_uses_variable_names=False, print_uses_variable_names=True, sense=None)\n</code></pre> <p>Importantly, notice how,</p> <ul> <li> <p><code>name</code> is now a named-only parameter (you must write <code>name=</code>), and</p> </li> <li> <p><code>use_var_names</code> was renamed to <code>solver_uses_variable_names</code> (to avoid confusion with the new option <code>print_uses_variable_names</code>).</p> </li> </ul> <p>Please update all calls to <code>pf.Model(\u2026)</code> accordingly.</p> <pre><code>import pyoframe as pf\n\npf.Model(\"my-model\")  # before\npf.Model(name=\"my-model\")  # after\n\npf.Model(use_var_names=True)  # before\npf.Model(solver_uses_variable_names=True)  # after\n</code></pre>"},{"location":"learn/migrate/v1.0/#2-replace-pfsum-obj-with-objsum","title":"2. Replace <code>pf.sum(\u2026, obj)</code> with <code>obj.sum(\u2026)</code>","text":"<p>To improve readability and align with Python best practices, both <code>pf.sum(\u2026, obj)</code> and <code>pf.sum_by(\u2026, obj)</code> have been replaced by <code>obj.sum(\u2026)</code> and <code>obj.sum_by(\u2026)</code>. Here <code>obj</code> represents any Pyoframe Variable or Expression.<sup>1</sup> For example:</p> <pre><code>pf.sum(m.X)  # before\nm.X.sum()  # after\n\npf.sum([\"day\", \"hour\"], m.X)  # before\nm.X.sum(\"day\", \"hour\")  # after\n\npf.sum_by(\"city\", m.X)  # before\nm.X.sum_by(\"city\")  # after\n</code></pre> <p>Please update all uses of <code>pf.sum</code> and <code>pf.sum_by</code> accordingly.</p>"},{"location":"learn/migrate/v1.0/#3-rename-add_dim-to-over","title":"3. Rename <code>.add_dim(\u2026)</code> to <code>.over(\u2026)</code>","text":"<p>For clarity, <code>.add_dim(\u2026)</code> was renamed to <code>.over(\u2026)</code>. Please update your code accordingly.</p> <pre><code>m.X.add_dim(\"time\")  # before\nm.X.over(\"time\")  # after\n</code></pre>"},{"location":"learn/migrate/v1.0/#4-rename-keep_unmatched-and-drop_unmatched-with-keep_extras-and-drop_extras","title":"4. Rename <code>.keep_unmatched()</code> and <code>.drop_unmatched()</code> with <code>.keep_extras()</code> and <code>.drop_extras()</code>","text":"<p>For clarity, <code>.keep_unmatched()</code> and <code>.drop_unmatched()</code> were renamed to <code>.keep_extras()</code> and <code>.drop_extras()</code>, respectively. Please update your code accordingly.</p> <pre><code>m.X.keep_unmatched()  # before\nm.X.keep_extras()  # after\n\nm.X.drop_unmatched()  # before\nm.X.drop_extras()  # after\n</code></pre>"},{"location":"learn/migrate/v1.0/#5-review-code-for-other-breaking-changes","title":"5. Review code for other breaking changes","text":"<p>Steps 1 to 3 should cover most breaking changes. For completeness, below are some additional breaking changes that you are less likely to encounter.</p> <ol> <li> <p>All submodules (e.g. <code>pyoframe.core</code>) and some attributes (<code>obj.unmatched_strategy</code>, <code>obj.allowed_new_dims</code>, <code>obj.dimensions_unsafe</code>, <code>Config.enable_is_duplicated_expression_safety_check</code>) have been renamed to begin with an underscore (e.g. now <code>pyoframe._core</code>) to indicate that these elements are no longer part of the public API.</p> </li> <li> <p>If you try to read <code>model.objective</code> before having defined an objective, an error will be raised. Prior to v1.0 <code>None</code> was returned.</p> </li> <li> <p><code>.over(\u2026)</code>, <code>.keep_extras()</code>, and <code>.drop_extras()</code> now have a well-defined \"order of operations.\" They must be applied after all other transforms. For example, <code>my_obj.drop_extras().sum(\"time\")</code> no longer works because <code>my_obj.sum(\"time\").drop_extras()</code> should be used instead. Learn more.</p> </li> <li> <p><code>pf.Config.print_max_set_elements</code>, <code>pf.Config.print_max_line_length</code>, and <code>pf.Config.print_max_lines</code> no longer exist. Use <code>pf.Config.print_max_terms</code> <code>pf.Config.print_polars_config</code> instead.</p> </li> <li> <p><code>pf.Config.print_uses_variable_names</code> no longer exists. Use the equivalent option in <code>pf.Model(\u2026)</code></p> </li> <li> <p><code>pf.Config.default_solver</code> now defaults to <code>\"auto\"</code> instead of <code>None</code> to clarify that by default, the solver will be automatically detected. Don't set <code>pf.Config.default_solver = None</code>.</p> </li> <li> <p><code>pf.Config.disable_unmatched_checks</code> has been renamed to <code>pf.Config.disable_extras_checks</code>.</p> </li> <li> <p>Gurobi users: <code>Model.write(\u2026)</code> is now only available when <code>solver_uses_variable_names=True</code>.</p> </li> <li> <p>Previously, passing a DataFrame to the <code>equals=</code> parameter of the <code>Variable</code> constructor would result in a Variable equal to 1. This bug has been fixed.</p> </li> </ol> <ol> <li> <p>If you were using <code>pf.sum</code> or <code>pf.sum_by</code> on a Polars or Pandas DataFrame instead of on a Pyoframe object, you should use the <code>.sum()</code> function native to Pandas/Polars.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/","title":"Overview of Pyoframe's API","text":"<p>Pyoframe's classes and subclasses are structured as follows:</p> <ul> <li>Model</li> <li>BaseBlock*<ul> <li>Constraint</li> <li>BaseOperableBlock*<ul> <li>Variable</li> <li>Expression<ul> <li>Objective</li> </ul> </li> <li>Set</li> </ul> </li> </ul> </li> <li>Config</li> </ul> <p>The following enums are also available:</p> <ul> <li>VType</li> <li>ObjSense</li> </ul> <p>Finally, PyoframeError is a Pyoframe custom error type. </p> <p>All the above classes (except those marked with an asterisk) can be imported via:</p> <pre><code>import pyoframe as pf\n</code></pre> <p>Additionally, importing Pyoframe patches Pandas and Polars such that calling for <code>df.to_expr()</code> is equivalent to <code>pf.Param(df)</code>. This also works for pandas Series.</p>"},{"location":"reference/bases/BaseBlock/","title":"BaseBlock","text":"<p>               Bases: <code>ABC</code></p> <p>The base class for elements of a Model such as  and .</p> <p>Methods:</p> Name Description <code>estimated_size</code> <p>Returns the estimated size of the object in bytes.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>DataFrame</code> <p>Returns the object's underlying Polars DataFrame.</p> <code>dimensionless</code> <code>bool</code> <p>Whether the object has no dimensions.</p> <code>dimensions</code> <code>list[str] | None</code> <p>The names of the data's dimensions.</p> <code>name</code> <code>str</code> <p>A user-friendly name that is displayed when printing the object or in error messages.</p> <code>shape</code> <code>dict[str, int]</code> <p>The number of distinct labels in each dimension.</p> Source code in <code>pyoframe/_model_element.py</code> <pre><code>def __init__(self, data: pl.DataFrame, name=\"unnamed\") -&gt; None:\n    # Sanity checks, no duplicate column names\n    assert len(data.columns) == len(set(data.columns)), (\n        \"Duplicate column names found.\"\n    )\n\n    cols = _get_dimensions(data)\n    if cols is None:\n        cols = []\n    cols += [col for col in RESERVED_COL_KEYS if col in data.columns]\n\n    # Reorder columns to keep things consistent\n    data = data.select(cols)\n\n    # Cast to proper dtype\n    if COEF_KEY in data.columns:\n        data = data.cast({COEF_KEY: pl.Float64})\n    if VAR_KEY in data.columns:\n        data = data.cast({VAR_KEY: Config.id_dtype})\n    if QUAD_VAR_KEY in data.columns:\n        data = data.cast({QUAD_VAR_KEY: Config.id_dtype})\n\n    self._data = data\n    self._model: Model | None = None\n    self.name: str = name  # gets overwritten if object is added to model\n    \"\"\"A user-friendly name that is displayed when printing the object or in error messages.\n    When an object is added to a model, this name is updated to the name used in the model.\"\"\"\n</code></pre>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.data","title":"<code>data: pl.DataFrame</code>","text":"<p>Returns the object's underlying Polars DataFrame.</p>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.dimensionless","title":"<code>dimensionless: bool</code>","text":"<p>Whether the object has no dimensions.</p> <p>Examples:</p> <p>A variable with no dimensions</p> <pre><code>&gt;&gt;&gt; pf.Variable().dimensionless\nTrue\n</code></pre> <p>A variable with dimensions of \"hour\" and \"city\"</p> <pre><code>&gt;&gt;&gt; pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... ).dimensionless\nFalse\n</code></pre>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.dimensions","title":"<code>dimensions: list[str] | None</code>","text":"<p>The names of the data's dimensions.</p> <p>Examples:</p> <p>A variable with no dimensions</p> <pre><code>&gt;&gt;&gt; pf.Variable().dimensions\n</code></pre> <p>A variable with dimensions of \"hour\" and \"city\"</p> <pre><code>&gt;&gt;&gt; pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... ).dimensions\n['hour', 'city']\n</code></pre>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.name","title":"<code>name: str = name</code>","text":"<p>A user-friendly name that is displayed when printing the object or in error messages. When an object is added to a model, this name is updated to the name used in the model.</p>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.shape","title":"<code>shape: dict[str, int]</code>","text":"<p>The number of distinct labels in each dimension.</p> <p>Examples:</p> <p>A variable with no dimensions</p> <pre><code>&gt;&gt;&gt; pf.Variable().shape\n{}\n</code></pre> <p>A variable with dimensions of \"hour\" and \"city\"</p> <pre><code>&gt;&gt;&gt; pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... ).shape\n{'hour': 4, 'city': 3}\n</code></pre>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.estimated_size","title":"<code>estimated_size(unit: pl.SizeUnit = 'b') -&gt; int | float</code>","text":"<p>Returns the estimated size of the object in bytes.</p> <p>Only considers the size of the underlying DataFrame(s) since other components (e.g., the object name) are negligible.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>SizeUnit</code> <p>See <code>polars.DataFrame.estimated_size</code>.</p> <code>'b'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n</code></pre> <p>A dimensionless variable contains just a 32 bit (4 bytes) unsigned integer (the variable ID).</p> <pre><code>&gt;&gt;&gt; m.x = pf.Variable()\n&gt;&gt;&gt; m.x.estimated_size()\n4\n</code></pre> <p>A dimensioned variable contains, for every row, a 32 bit ID and, in this case, a 64 bit <code>dim_x</code> value (1200 bytes total).</p> <pre><code>&gt;&gt;&gt; m.y = pf.Variable(pf.Set(dim_x=range(100)))\n&gt;&gt;&gt; m.y.estimated_size()\n1200\n</code></pre> Source code in <code>pyoframe/_model_element.py</code> <pre><code>def estimated_size(self, unit: pl.SizeUnit = \"b\") -&gt; int | float:\n    \"\"\"Returns the estimated size of the object in bytes.\n\n    Only considers the size of the underlying DataFrame(s) since other components (e.g., the object name) are negligible.\n\n    Parameters:\n        unit:\n            See [`polars.DataFrame.estimated_size`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.estimated_size.html).\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n\n        A dimensionless variable contains just a 32 bit (4 bytes) unsigned integer (the variable ID).\n\n        &gt;&gt;&gt; m.x = pf.Variable()\n        &gt;&gt;&gt; m.x.estimated_size()\n        4\n\n        A dimensioned variable contains, for every row, a 32 bit ID and, in this case, a 64 bit `dim_x` value (1200 bytes total).\n\n        &gt;&gt;&gt; m.y = pf.Variable(pf.Set(dim_x=range(100)))\n        &gt;&gt;&gt; m.y.estimated_size()\n        1200\n    \"\"\"\n    return self.data.estimated_size(unit)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/","title":"BaseOperableBlock","text":"<p>               Bases: <code>BaseBlock</code></p> <p>Any object that can be converted into an expression.</p> <p>Methods:</p> Name Description <code>add_dim</code> <p>Deprecated, use <code>over</code> instead.</p> <code>drop_extras</code> <p>Indicates that labels not present in the other expression should be discarded during addition, subtraction, or constraint creation.</p> <code>drop_unmatched</code> <p>Deprecated, use <code>drop_extras</code> instead.</p> <code>filter</code> <p>Creates a copy of the object containing only a subset of the original rows.</p> <code>keep_extras</code> <p>Indicates that labels not present in the other expression should be kept during addition, subtraction, or constraint creation.</p> <code>keep_unmatched</code> <p>Deprecated, use <code>keep_extras</code> instead.</p> <code>map</code> <p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.map</code>.</p> <code>over</code> <p>Indicates that the expression can be broadcasted over the given dimensions during addition and subtraction.</p> <code>pick</code> <p>Filters elements by the given criteria and then drops the filtered dimensions.</p> <code>raise_extras</code> <p>Indicates that labels not present in the other expression should raise an error during addition, subtraction, or constraint creation.</p> <code>rename</code> <p>Renames one or several of the object's dimensions.</p> <code>sum</code> <p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.sum</code>.</p> <code>sum_by</code> <p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.sum_by</code>.</p> <code>to_expr</code> <p>Converts the object to a Pyoframe Expression.</p> <code>with_columns</code> <p>Creates a new object with modified columns.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    self._extras_strategy = ExtrasStrategy.UNSET\n    self._allowed_new_dims: list[str] = []\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.add_dim","title":"<code>add_dim(*dims: str)</code>","text":"<p>Deprecated, use <code>over</code> instead.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def add_dim(self, *dims: str):  # pragma: no cover\n    \"\"\"Deprecated, use [`over`][pyoframe.Expression.over] instead.\"\"\"\n    warnings.warn(\n        \"'add_dim' has been renamed to 'over'. Please use 'over' instead.\",\n        DeprecationWarning,\n    )\n    return self.over(*dims)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.drop_extras","title":"<code>drop_extras()</code>","text":"<p>Indicates that labels not present in the other expression should be discarded during addition, subtraction, or constraint creation.</p> <p>Learn more about addition modifiers.</p> See Also <p><code>keep_extras</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def drop_extras(self):\n    \"\"\"Indicates that labels not present in the other expression should be discarded during addition, subtraction, or constraint creation.\n\n    [Learn more](../../learn/concepts/addition.md) about addition modifiers.\n\n    See Also:\n        [`keep_extras`][pyoframe.Expression.keep_extras].\n    \"\"\"\n    new = self._new(self.data, name=f\"{self.name}.drop_extras()\")\n    new._copy_flags(self)\n    new._extras_strategy = ExtrasStrategy.DROP\n    return new\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.drop_unmatched","title":"<code>drop_unmatched()</code>","text":"<p>Deprecated, use <code>drop_extras</code> instead.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def drop_unmatched(self):  # pragma: no cover\n    \"\"\"Deprecated, use [`drop_extras`][pyoframe.Expression.drop_extras] instead.\"\"\"\n    warnings.warn(\n        \"'drop_unmatched' has been renamed to 'drop_extras'. Please use 'drop_extras' instead.\",\n        DeprecationWarning,\n    )\n    return self.drop_extras()\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.filter","title":"<code>filter(*args, **kwargs)</code>","text":"<p>Creates a copy of the object containing only a subset of the original rows.</p> <p>Takes the same arguments as <code>polars.DataFrame.filter</code>.</p> See Also <p><code>Expression.pick</code> or <code>Variable.pick</code> if you wish to drop the filtered column in the process.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef filter(self, *args, **kwargs):\n    \"\"\"Creates a copy of the object containing only a subset of the original rows.\n\n    Takes the same arguments as [`polars.DataFrame.filter`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.filter.html).\n\n    See Also:\n        [`Expression.pick`][pyoframe.Expression.pick] or [`Variable.pick`][pyoframe.Variable.pick] if you wish to drop the filtered\n        column in the process.\n\n    \"\"\"\n    return self.data.filter(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.keep_extras","title":"<code>keep_extras()</code>","text":"<p>Indicates that labels not present in the other expression should be kept during addition, subtraction, or constraint creation.</p> <p>Learn more about addition modifiers.</p> See Also <p><code>drop_extras</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def keep_extras(self):\n    \"\"\"Indicates that labels not present in the other expression should be kept during addition, subtraction, or constraint creation.\n\n    [Learn more](../../learn/concepts/addition.md) about addition modifiers.\n\n    See Also:\n        [`drop_extras`][pyoframe.Expression.drop_extras].\n    \"\"\"\n    new = self._new(self.data, name=f\"{self.name}.keep_extras()\")\n    new._copy_flags(self)\n    new._extras_strategy = ExtrasStrategy.KEEP\n    return new\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.keep_unmatched","title":"<code>keep_unmatched()</code>","text":"<p>Deprecated, use <code>keep_extras</code> instead.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def keep_unmatched(self):  # pragma: no cover\n    \"\"\"Deprecated, use [`keep_extras`][pyoframe.Expression.keep_extras] instead.\"\"\"\n    warnings.warn(\n        \"'keep_unmatched' has been renamed to 'keep_extras'. Please use 'keep_extras' instead.\",\n        DeprecationWarning,\n    )\n    return self.keep_extras()\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.map","title":"<code>map(*args, **kwargs)</code>","text":"<p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.map</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def map(self, *args, **kwargs):\n    \"\"\"Converts the object to an expression (see `.to_expr()`) and then applies [`Expression.map`][pyoframe.Expression.map].\"\"\"\n    return self.to_expr().map(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.over","title":"<code>over(*dims: str)</code>","text":"<p>Indicates that the expression can be broadcasted over the given dimensions during addition and subtraction.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def over(self, *dims: str):\n    \"\"\"Indicates that the expression can be broadcasted over the given dimensions during addition and subtraction.\"\"\"\n    new = self._new(self.data, name=f\"{self.name}.over(\u2026)\")\n    new._copy_flags(self)\n    new._allowed_new_dims.extend(dims)\n    return new\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.pick","title":"<code>pick(**kwargs)</code>","text":"<p>Filters elements by the given criteria and then drops the filtered dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... )\n&gt;&gt;&gt; m.v.pick(hour=\"06:00\")\n&lt;Expression (linear) height=3 terms=3&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 city    \u2506 expression       \u2502\n\u2502 (3)     \u2506                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto \u2506 v[06:00,Toronto] \u2502\n\u2502 Berlin  \u2506 v[06:00,Berlin]  \u2502\n\u2502 Paris   \u2506 v[06:00,Paris]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.v.pick(hour=\"06:00\", city=\"Toronto\")\n&lt;Expression (linear) terms=1&gt;\nv[06:00,Toronto]\n</code></pre> See Also <p><code>Expression.filter</code> or <code>Variable.filter</code> if you don't wish to drop the filtered column.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef pick(self, **kwargs):\n    \"\"\"Filters elements by the given criteria and then drops the filtered dimensions.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable(\n        ...     [\n        ...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n        ...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n        ...     ]\n        ... )\n        &gt;&gt;&gt; m.v.pick(hour=\"06:00\")\n        &lt;Expression (linear) height=3 terms=3&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 city    \u2506 expression       \u2502\n        \u2502 (3)     \u2506                  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Toronto \u2506 v[06:00,Toronto] \u2502\n        \u2502 Berlin  \u2506 v[06:00,Berlin]  \u2502\n        \u2502 Paris   \u2506 v[06:00,Paris]   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; m.v.pick(hour=\"06:00\", city=\"Toronto\")\n        &lt;Expression (linear) terms=1&gt;\n        v[06:00,Toronto]\n\n    See Also:\n        [`Expression.filter`][pyoframe.Expression.filter] or [`Variable.filter`][pyoframe.Variable.filter] if you don't wish to drop the filtered column.\n    \"\"\"\n    return self.data.filter(**kwargs).drop(kwargs.keys())\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.raise_extras","title":"<code>raise_extras()</code>","text":"<p>Indicates that labels not present in the other expression should raise an error during addition, subtraction, or constraint creation.</p> <p>This is the default behavior and, as such, this addition modifier should only be used in the rare cases where you want to override a previous use of <code>keep_extras()</code> or <code>drop_extras()</code>.</p> <p>Learn more about addition modifiers.</p> See Also <p><code>keep_extras</code> and <code>drop_extras</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def raise_extras(self):\n    \"\"\"Indicates that labels not present in the other expression should raise an error during addition, subtraction, or constraint creation.\n\n    This is the default behavior and, as such, this addition modifier should only be used in the rare cases where you want to override a previous use of `keep_extras()` or `drop_extras()`.\n\n    [Learn more](../../learn/concepts/addition.md) about addition modifiers.\n\n    See Also:\n        [`keep_extras`][pyoframe.Expression.keep_extras] and [`drop_extras`][pyoframe.Expression.drop_extras].\n    \"\"\"\n    new = self._new(self.data, name=f\"{self.name}.raise_extras()\")\n    new._copy_flags(self)\n    new._extras_strategy = ExtrasStrategy.UNSET\n    return new\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.rename","title":"<code>rename(*args, **kwargs)</code>","text":"<p>Renames one or several of the object's dimensions.</p> <p>Takes the same arguments as <code>polars.DataFrame.rename</code>.</p> <p>See the portfolio optimization example for a usage example.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable(\n...     {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...     {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n... )\n&gt;&gt;&gt; m.v\n&lt;Variable 'v' height=12&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 hour  \u2506 city    \u2506 variable         \u2502\n\u2502 (4)   \u2506 (3)     \u2506                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00 \u2506 Toronto \u2506 v[00:00,Toronto] \u2502\n\u2502 00:00 \u2506 Berlin  \u2506 v[00:00,Berlin]  \u2502\n\u2502 00:00 \u2506 Paris   \u2506 v[00:00,Paris]   \u2502\n\u2502 06:00 \u2506 Toronto \u2506 v[06:00,Toronto] \u2502\n\u2502 06:00 \u2506 Berlin  \u2506 v[06:00,Berlin]  \u2502\n\u2502 \u2026     \u2506 \u2026       \u2506 \u2026                \u2502\n\u2502 12:00 \u2506 Berlin  \u2506 v[12:00,Berlin]  \u2502\n\u2502 12:00 \u2506 Paris   \u2506 v[12:00,Paris]   \u2502\n\u2502 18:00 \u2506 Toronto \u2506 v[18:00,Toronto] \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 v[18:00,Berlin]  \u2502\n\u2502 18:00 \u2506 Paris   \u2506 v[18:00,Paris]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; m.v.rename({\"city\": \"location\"})\n&lt;Expression (linear) height=12 terms=12&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 hour  \u2506 location \u2506 expression       \u2502\n\u2502 (4)   \u2506 (3)      \u2506                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00 \u2506 Toronto  \u2506 v[00:00,Toronto] \u2502\n\u2502 00:00 \u2506 Berlin   \u2506 v[00:00,Berlin]  \u2502\n\u2502 00:00 \u2506 Paris    \u2506 v[00:00,Paris]   \u2502\n\u2502 06:00 \u2506 Toronto  \u2506 v[06:00,Toronto] \u2502\n\u2502 06:00 \u2506 Berlin   \u2506 v[06:00,Berlin]  \u2502\n\u2502 \u2026     \u2506 \u2026        \u2506 \u2026                \u2502\n\u2502 12:00 \u2506 Berlin   \u2506 v[12:00,Berlin]  \u2502\n\u2502 12:00 \u2506 Paris    \u2506 v[12:00,Paris]   \u2502\n\u2502 18:00 \u2506 Toronto  \u2506 v[18:00,Toronto] \u2502\n\u2502 18:00 \u2506 Berlin   \u2506 v[18:00,Berlin]  \u2502\n\u2502 18:00 \u2506 Paris    \u2506 v[18:00,Paris]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef rename(self, *args, **kwargs):\n    \"\"\"Renames one or several of the object's dimensions.\n\n    Takes the same arguments as [`polars.DataFrame.rename`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.rename.html).\n\n    See the [portfolio optimization example](../../examples/portfolio_optimization.md) for a usage example.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable(\n        ...     {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n        ...     {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n        ... )\n        &gt;&gt;&gt; m.v\n        &lt;Variable 'v' height=12&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 hour  \u2506 city    \u2506 variable         \u2502\n        \u2502 (4)   \u2506 (3)     \u2506                  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 00:00 \u2506 Toronto \u2506 v[00:00,Toronto] \u2502\n        \u2502 00:00 \u2506 Berlin  \u2506 v[00:00,Berlin]  \u2502\n        \u2502 00:00 \u2506 Paris   \u2506 v[00:00,Paris]   \u2502\n        \u2502 06:00 \u2506 Toronto \u2506 v[06:00,Toronto] \u2502\n        \u2502 06:00 \u2506 Berlin  \u2506 v[06:00,Berlin]  \u2502\n        \u2502 \u2026     \u2506 \u2026       \u2506 \u2026                \u2502\n        \u2502 12:00 \u2506 Berlin  \u2506 v[12:00,Berlin]  \u2502\n        \u2502 12:00 \u2506 Paris   \u2506 v[12:00,Paris]   \u2502\n        \u2502 18:00 \u2506 Toronto \u2506 v[18:00,Toronto] \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 v[18:00,Berlin]  \u2502\n        \u2502 18:00 \u2506 Paris   \u2506 v[18:00,Paris]   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; m.v.rename({\"city\": \"location\"})\n        &lt;Expression (linear) height=12 terms=12&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 hour  \u2506 location \u2506 expression       \u2502\n        \u2502 (4)   \u2506 (3)      \u2506                  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 00:00 \u2506 Toronto  \u2506 v[00:00,Toronto] \u2502\n        \u2502 00:00 \u2506 Berlin   \u2506 v[00:00,Berlin]  \u2502\n        \u2502 00:00 \u2506 Paris    \u2506 v[00:00,Paris]   \u2502\n        \u2502 06:00 \u2506 Toronto  \u2506 v[06:00,Toronto] \u2502\n        \u2502 06:00 \u2506 Berlin   \u2506 v[06:00,Berlin]  \u2502\n        \u2502 \u2026     \u2506 \u2026        \u2506 \u2026                \u2502\n        \u2502 12:00 \u2506 Berlin   \u2506 v[12:00,Berlin]  \u2502\n        \u2502 12:00 \u2506 Paris    \u2506 v[12:00,Paris]   \u2502\n        \u2502 18:00 \u2506 Toronto  \u2506 v[18:00,Toronto] \u2502\n        \u2502 18:00 \u2506 Berlin   \u2506 v[18:00,Berlin]  \u2502\n        \u2502 18:00 \u2506 Paris    \u2506 v[18:00,Paris]   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    return self.data.rename(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.sum","title":"<code>sum(*args, **kwargs)</code>","text":"<p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.sum</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def sum(self, *args, **kwargs):\n    \"\"\"Converts the object to an expression (see `.to_expr()`) and then applies [`Expression.sum`][pyoframe.Expression.sum].\"\"\"\n    return self.to_expr().sum(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.sum_by","title":"<code>sum_by(*args, **kwargs)</code>","text":"<p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.sum_by</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def sum_by(self, *args, **kwargs):\n    \"\"\"Converts the object to an expression (see `.to_expr()`) and then applies [`Expression.sum_by`][pyoframe.Expression.sum_by].\"\"\"\n    return self.to_expr().sum_by(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.to_expr","title":"<code>to_expr() -&gt; Expression</code>","text":"<p>Converts the object to a Pyoframe Expression.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@abstractmethod\ndef to_expr(self) -&gt; Expression:\n    \"\"\"Converts the object to a Pyoframe Expression.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.with_columns","title":"<code>with_columns(*args, **kwargs)</code>","text":"<p>Creates a new object with modified columns.</p> <p>Takes the same arguments as <code>polars.DataFrame.with_columns</code>.</p> <p>Warning</p> <p>Only use this function if you know what you're doing. It is not recommended to manually modify the columns within a Pyoframe object.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef with_columns(self, *args, **kwargs):\n    \"\"\"Creates a new object with modified columns.\n\n    Takes the same arguments as [`polars.DataFrame.with_columns`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.with_columns.html).\n\n    !!! warning\n        Only use this function if you know what you're doing. It is not recommended to manually modify the columns\n        within a Pyoframe object.\n    \"\"\"\n    return self.data.with_columns(*args, **kwargs)\n</code></pre>"},{"location":"reference/public/Config/","title":"Config","text":"<p>Default values listed at the end of the page.</p> <p>General settings for Pyoframe (for advanced users).</p> <p>Accessible via <code>pf.Config</code> (see examples below).</p> <p>Methods:</p> Name Description <code>reset_defaults</code> <p>Resets all configuration options to their default values.</p> <p>Attributes:</p> Name Type Description <code>default_solver</code> <code>SUPPORTED_SOLVER_TYPES | _Solver | Literal['raise', 'auto']</code> <p>The solver to use when Model is instantiated without specifying a solver.</p> <code>disable_extras_checks</code> <code>bool</code> <p>When <code>True</code>, improves performance by skipping checks for extra values (not recommended).</p> <code>enable_is_duplicated_expression_safety_check</code> <code>bool</code> <p>Setting for internal testing purposes only.</p> <code>float_to_str_precision</code> <code>int | None</code> <p>Number of decimal places to use when displaying mathematical expressions.</p> <code>id_dtype</code> <p>The Polars data type to use for variable and constraint IDs.</p> <code>integer_tolerance</code> <code>float</code> <p>Tolerance for checking if a floating point value is an integer.</p> <code>maintain_order</code> <code>bool</code> <p>Whether the order of variables, constraints, and mathematical terms is to be identical across runs.</p> <code>print_max_terms</code> <code>int</code> <p>Maximum number of terms to print in an expression before truncating it.</p> <code>print_polars_config</code> <code>Config</code> <p><code>polars.Config</code> object to use when printing dimensioned Pyoframe objects.</p> Source code in <code>pyoframe/_constants.py</code> <pre><code>def __init__(self):\n    self._settings = ConfigDefaults()\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.default_solver","title":"<code>default_solver: SUPPORTED_SOLVER_TYPES | _Solver | Literal['raise', 'auto']</code>","text":"<p>The solver to use when Model is instantiated without specifying a solver.</p> <p>If <code>auto</code>, Pyoframe will try to use whichever solver is installed. If <code>raise</code>, an exception will be raised when Model is instantiated without specifying a solver.</p> <p>We recommend that users specify their solver when instantiating Model rather than relying on this option.</p>"},{"location":"reference/public/Config/#pyoframe._constants._Config.disable_extras_checks","title":"<code>disable_extras_checks: bool</code>","text":"<p>When <code>True</code>, improves performance by skipping checks for extra values (not recommended).</p> <p>When <code>True</code>, checks for extra values are disabled which effectively means that all expressions are treated as if they contained <code>.keep_extras()</code> (unless <code>.drop_extras()</code> was applied).</p> <p>Warning</p> <p>This might improve performance, but it will suppress the errors that alert you of unexpected behaviors (learn more). Only consider enabling after you have thoroughly tested your code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; population = pf.Param(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Montreal\"],\n...         \"pop\": [2_731_571, 631_486, 1_704_694],\n...     }\n... )\n&gt;&gt;&gt; population_influx = pf.Param(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Montreal\"],\n...         \"influx\": [100_000, 50_000, None],\n...     }\n... )\n</code></pre> <p>Normally, an error warns users that the two expressions have conflicting labels:</p> <pre><code>&gt;&gt;&gt; population + population_influx\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot add the two expressions below because expression 1 has extra labels.\nExpression 1:   pop\nExpression 2:   influx\nExtra labels in expression 1:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 city     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Montreal \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nUse .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n</code></pre> <p>But if <code>Config.disable_extras_checks = True</code>, the error is suppressed and the sum is considered to be <code>population.keep_extras() + population_influx.keep_extras()</code>:</p> <pre><code>&gt;&gt;&gt; pf.Config.disable_extras_checks = True\n&gt;&gt;&gt; population + population_influx\n&lt;Expression (parameter) height=3 terms=3&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 city      \u2506 expression \u2502\n\u2502 (3)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto   \u2506 2831571    \u2502\n\u2502 Vancouver \u2506 681486     \u2502\n\u2502 Montreal  \u2506 1704694    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.enable_is_duplicated_expression_safety_check","title":"<code>enable_is_duplicated_expression_safety_check: bool</code>","text":"<p>Setting for internal testing purposes only.</p> <p>When <code>True</code>, pyoframe checks that there are no bugs leading to duplicated terms in expressions.</p>"},{"location":"reference/public/Config/#pyoframe._constants._Config.float_to_str_precision","title":"<code>float_to_str_precision: int | None</code>","text":"<p>Number of decimal places to use when displaying mathematical expressions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Config.float_to_str_precision = 3\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; expr = 100.752038759 * m.X\n&gt;&gt;&gt; expr\n&lt;Expression (linear) terms=1&gt;\n100.752\u00a0X\n&gt;&gt;&gt; pf.Config.float_to_str_precision = None\n&gt;&gt;&gt; expr\n&lt;Expression (linear) terms=1&gt;\n100.752038759\u00a0X\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.id_dtype","title":"<code>id_dtype</code>","text":"<p>The Polars data type to use for variable and constraint IDs.</p> <p>Defaults to <code>pl.UInt32</code> which should be ideal for most users.</p> <p>Users with more than 4 billion variables or constraints can change this to <code>pl.UInt64</code>.</p> <p>Users concerned with memory usage and with fewer than 65k variables or constraints can change this to <code>pl.UInt16</code>.</p> <p>Warning</p> <p>Changing this setting after creating a model will lead to errors. You should only change this setting before creating any models.</p> <p>Examples:</p> <p>An error is automatically raised if the number of variables or constraints exceeds the chosen data type:</p> <pre><code>&gt;&gt;&gt; pf.Config.id_dtype = pl.UInt8\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; big_set = pf.Set(x=range(2**8 + 1))\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.constraint = m.X.over(\"x\") &lt;= big_set\nTraceback (most recent call last):\n...\nTypeError: Number of constraints exceeds the current data type (UInt8). Consider increasing the data type by changing Config.id_dtype.\n&gt;&gt;&gt; m.X_large = pf.Variable(big_set)\nTraceback (most recent call last):\n...\nTypeError: Number of variables exceeds the current data type (UInt8). Consider increasing the data type by changing Config.id_dtype.\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.integer_tolerance","title":"<code>integer_tolerance: float</code>","text":"<p>Tolerance for checking if a floating point value is an integer.</p> <p>Info</p> <p>For convenience, Pyoframe returns the solution of integer and binary variables as integers not floating point values. To do so, Pyoframe must convert the solver-provided floating point values to integers. To avoid unexpected rounding errors, Pyoframe uses this tolerance to check that the floating point result is an integer as expected. Overly tight tolerances can trigger unexpected errors. Setting the tolerance to zero disables the check.</p>"},{"location":"reference/public/Config/#pyoframe._constants._Config.maintain_order","title":"<code>maintain_order: bool</code>","text":"<p>Whether the order of variables, constraints, and mathematical terms is to be identical across runs.</p> <p>If <code>False</code>, performance is improved, but your results may vary every so slightly across runs since numerical errors can accumulate differently when the order of operations changes.</p>"},{"location":"reference/public/Config/#pyoframe._constants._Config.print_max_terms","title":"<code>print_max_terms: int</code>","text":"<p>Maximum number of terms to print in an expression before truncating it.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Config.print_max_terms = 3\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(pf.Set(x=range(100)), pf.Set(y=range(100)))\n&gt;&gt;&gt; m.X.sum(\"y\")\n&lt;Expression (linear) height=100 terms=10000&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x     \u2506 expression                    \u2502\n\u2502 (100) \u2506                               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 X[0,0] +\u00a0X[0,1] +\u00a0X[0,2] \u2026    \u2502\n\u2502 1     \u2506 X[1,0] +\u00a0X[1,1] +\u00a0X[1,2] \u2026    \u2502\n\u2502 2     \u2506 X[2,0] +\u00a0X[2,1] +\u00a0X[2,2] \u2026    \u2502\n\u2502 3     \u2506 X[3,0] +\u00a0X[3,1] +\u00a0X[3,2] \u2026    \u2502\n\u2502 4     \u2506 X[4,0] +\u00a0X[4,1] +\u00a0X[4,2] \u2026    \u2502\n\u2502 \u2026     \u2506 \u2026                             \u2502\n\u2502 95    \u2506 X[95,0] +\u00a0X[95,1] +\u00a0X[95,2] \u2026 \u2502\n\u2502 96    \u2506 X[96,0] +\u00a0X[96,1] +\u00a0X[96,2] \u2026 \u2502\n\u2502 97    \u2506 X[97,0] +\u00a0X[97,1] +\u00a0X[97,2] \u2026 \u2502\n\u2502 98    \u2506 X[98,0] +\u00a0X[98,1] +\u00a0X[98,2] \u2026 \u2502\n\u2502 99    \u2506 X[99,0] +\u00a0X[99,1] +\u00a0X[99,2] \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.X.sum()\n&lt;Expression (linear) terms=10000&gt;\nX[0,0] +\u00a0X[0,1] +\u00a0X[0,2] \u2026\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.print_polars_config","title":"<code>print_polars_config: pl.Config</code>","text":"<p><code>polars.Config</code> object to use when printing dimensioned Pyoframe objects.</p> <p>Examples:</p> <p>For example, to limit the number of rows printed in a table, use <code>set_tbl_rows</code>:</p> <pre><code>&gt;&gt;&gt; pf.Config.print_polars_config.set_tbl_rows(5)\n&lt;class 'polars.config.Config'&gt;\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(pf.Set(x=range(100)))\n&gt;&gt;&gt; m.X\n&lt;Variable 'X' height=100&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x     \u2506 variable \u2502\n\u2502 (100) \u2506          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 X[0]     \u2502\n\u2502 1     \u2506 X[1]     \u2502\n\u2502 2     \u2506 X[2]     \u2502\n\u2502 \u2026     \u2506 \u2026        \u2502\n\u2502 98    \u2506 X[98]    \u2502\n\u2502 99    \u2506 X[99]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.reset_defaults","title":"<code>reset_defaults()</code>","text":"<p>Resets all configuration options to their default values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Config.disable_extras_checks\nFalse\n&gt;&gt;&gt; pf.Config.disable_extras_checks = True\n&gt;&gt;&gt; pf.Config.disable_extras_checks\nTrue\n&gt;&gt;&gt; pf.Config.reset_defaults()\n&gt;&gt;&gt; pf.Config.disable_extras_checks\nFalse\n</code></pre> Source code in <code>pyoframe/_constants.py</code> <pre><code>def reset_defaults(self):\n    \"\"\"Resets all configuration options to their default values.\n\n    Examples:\n        &gt;&gt;&gt; pf.Config.disable_extras_checks\n        False\n        &gt;&gt;&gt; pf.Config.disable_extras_checks = True\n        &gt;&gt;&gt; pf.Config.disable_extras_checks\n        True\n        &gt;&gt;&gt; pf.Config.reset_defaults()\n        &gt;&gt;&gt; pf.Config.disable_extras_checks\n        False\n    \"\"\"\n    self._settings = ConfigDefaults()\n</code></pre>"},{"location":"reference/public/Config/#default-values","title":"Default values","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.default_solver","title":"<code>default_solver: SUPPORTED_SOLVER_TYPES | _Solver | Literal['raise', 'auto'] = 'auto'</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.disable_extras_checks","title":"<code>disable_extras_checks: bool = False</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.enable_is_duplicated_expression_safety_check","title":"<code>enable_is_duplicated_expression_safety_check: bool = False</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.float_to_str_precision","title":"<code>float_to_str_precision: int | None = 5</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.id_dtype","title":"<code>id_dtype = pl.UInt32</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.integer_tolerance","title":"<code>integer_tolerance: float = 1e-08</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.maintain_order","title":"<code>maintain_order: bool = True</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.print_max_terms","title":"<code>print_max_terms: int = 5</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.print_polars_config","title":"<code>print_polars_config: pl.Config = field(default_factory=(lambda: pl.Config(tbl_hide_column_data_types=True, tbl_hide_dataframe_shape=True, fmt_str_lengths=100, apply_on_context_enter=True)))</code>","text":""},{"location":"reference/public/Constraint/","title":"Constraint","text":"<p>               Bases: <code>BaseBlock</code></p> <p>An optimization constraint that can be added to a Model.</p> Implementation Note <p>Pyoframe simplifies constraints by moving all the constraint's mathematical terms to the left-hand side. This way, the right-hand side is always zero, and constraints only need to manage one expression.</p> Use <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code> operators to create constraints <p>Constraints should be created using the <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code> operators, not by directly calling the <code>Constraint</code> constructor.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expression</code> <p>The constraint's left-hand side expression.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required <p>Methods:</p> Name Description <code>estimated_size</code> <p>Returns the estimated size of the constraint.</p> <code>filter</code> <p>Syntactic sugar on <code>Constraint.lhs.data.filter()</code>, to help debugging.</p> <code>relax</code> <p>Allows the constraint to be violated at a <code>cost</code> and, optionally, up to a maximum.</p> <code>to_str</code> <p>Converts the constraint to a human-readable string, or several arranged in a table.</p> <p>Attributes:</p> Name Type Description <code>attr</code> <code>Container</code> <p>Allows reading and writing constraint attributes similarly to Model.attr.</p> <code>dual</code> <code>DataFrame | float</code> <p>Returns the constraint's dual values.</p> <code>lhs</code> <code>Expression</code> <code>sense</code> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(self, lhs: Expression, sense: ConstraintSense):\n    self.lhs: Expression = lhs\n    self._model = lhs._model\n    self.sense = sense\n    self._to_relax: FuncArgs | None = None\n    self._attr = Container(self._set_attribute, self._get_attribute)\n\n    dims = self.lhs.dimensions\n    data = (\n        pl.DataFrame()\n        if dims is None\n        else self.lhs.data.select(dims).unique(maintain_order=Config.maintain_order)\n    )\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.attr","title":"<code>attr: Container</code>","text":"<p>Allows reading and writing constraint attributes similarly to Model.attr.</p>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.dual","title":"<code>dual: pl.DataFrame | float</code>","text":"<p>Returns the constraint's dual values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.x = pf.Variable()\n&gt;&gt;&gt; m.y = pf.Variable()\n&gt;&gt;&gt; m.maximize = m.x - m.y\n</code></pre> <p>Notice that for every unit increase in the right-hand side, the objective only improves by 0.5.</p> <pre><code>&gt;&gt;&gt; m.constraint_x = 2 * m.x &lt;= 10\n&gt;&gt;&gt; m.constraint_y = 2 * m.y &gt;= 5\n&gt;&gt;&gt; m.optimize()\n</code></pre> <p>For every unit increase in the right-hand side of <code>constraint_x</code>, the objective improves by 0.5.</p> <pre><code>&gt;&gt;&gt; m.constraint_x.dual\n0.5\n</code></pre> <p>For every unit increase in the right-hand side of <code>constraint_y</code>, the objective worsens by 0.5.</p> <pre><code>&gt;&gt;&gt; m.constraint_y.dual\n-0.5\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.lhs","title":"<code>lhs: Expression = lhs</code>","text":""},{"location":"reference/public/Constraint/#pyoframe.Constraint.sense","title":"<code>sense = sense</code>","text":""},{"location":"reference/public/Constraint/#pyoframe.Constraint.estimated_size","title":"<code>estimated_size(*args, **kwargs)</code>","text":"<p>Returns the estimated size of the constraint.</p> <p>Includes the size of the underlying expression (<code>Constraint.lhs</code>).</p> <p>See <code>Expression.estimated_size</code> for details on signature and behavior.</p> <p>Examples:</p> <p>An dimensionless constraint has contains a 32 bit constraint id and, for each term, a 64 bit coefficient with a 32 bit variable id. For a two-term expression that is: (32 + 2 * (64 + 32)) = 224 bits = 28 bytes.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.x = pf.Variable()\n&gt;&gt;&gt; m.con = m.x &lt;= 4\n&gt;&gt;&gt; m.con.estimated_size()\n28\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def estimated_size(self, *args, **kwargs):\n    \"\"\"Returns the estimated size of the constraint.\n\n    Includes the size of the underlying expression (`Constraint.lhs`).\n\n    See [`Expression.estimated_size`][pyoframe.Expression.estimated_size] for details on signature and behavior.\n\n    Examples:\n        An dimensionless constraint has contains a 32 bit constraint id and, for each term, a 64 bit coefficient with a 32 bit variable id.\n        For a two-term expression that is: (32 + 2 * (64 + 32)) = 224 bits = 28 bytes.\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.x = pf.Variable()\n        &gt;&gt;&gt; m.con = m.x &lt;= 4\n        &gt;&gt;&gt; m.con.estimated_size()\n        28\n    \"\"\"\n    return super().estimated_size(*args, **kwargs) + self.lhs.estimated_size(\n        *args, **kwargs\n    )\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.filter","title":"<code>filter(*args, **kwargs) -&gt; pl.DataFrame</code>","text":"<p>Syntactic sugar on <code>Constraint.lhs.data.filter()</code>, to help debugging.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def filter(self, *args, **kwargs) -&gt; pl.DataFrame:\n    \"\"\"Syntactic sugar on `Constraint.lhs.data.filter()`, to help debugging.\"\"\"\n    return self.lhs.data.filter(*args, **kwargs)\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.relax","title":"<code>relax(cost: Operable, max: Operable | None = None) -&gt; Constraint</code>","text":"<p>Allows the constraint to be violated at a <code>cost</code> and, optionally, up to a maximum.</p> Warning <p><code>.relax()</code> must be called before the constraint is assigned to the Model (see examples below).</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Operable</code> <p>The cost of violating the constraint. Costs should be positive because Pyoframe will automatically make them negative for maximization problems.</p> required <code>max</code> <code>Operable | None</code> <p>The maximum value of the relaxation variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>The same constraint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.maximize = m.hours_day\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n16.0\n&gt;&gt;&gt; m.maximize += 2 * m.hours_day\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n19.0\n</code></pre> <p><code>relax</code> can only be called after the sense of the model has been defined.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\nTraceback (most recent call last):\n...\nValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n</code></pre> <p>One way to solve this is by setting the sense directly on the model. See how this works fine:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(sense=\"max\")\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n</code></pre> <p>And now an example with dimensions:</p> <pre><code>&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame(\n...     {\n...         \"project\": [\"A\", \"B\", \"C\"],\n...         \"cost_per_hour_underdelivered\": [10, 20, 30],\n...         \"hours_to_finish\": [9, 9, 9],\n...         \"max_underdelivered\": [1, 9, 9],\n...     }\n... )\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[\"project\"], lb=0)\n&gt;&gt;&gt; m.must_finish_project = (\n...     m.hours_spent\n...     &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n... ).relax(\n...     homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]],\n...     max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]],\n... )\n&gt;&gt;&gt; m.only_one_day = m.hours_spent.sum(\"project\") &lt;= 24\n&gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n&gt;&gt;&gt; m.only_one_day.relax(1)\nTraceback (most recent call last):\n...\nValueError: .relax() must be called before the Constraint is added to the model\n&gt;&gt;&gt; m.attr.Silent = True\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n-50.0\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 8.0      \u2502\n\u2502 B       \u2506 7.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def relax(self, cost: Operable, max: Operable | None = None) -&gt; Constraint:\n    \"\"\"Allows the constraint to be violated at a `cost` and, optionally, up to a maximum.\n\n    Warning:\n        `.relax()` must be called before the constraint is assigned to the [Model][pyoframe.Model] (see examples below).\n\n    Parameters:\n        cost:\n            The cost of violating the constraint. Costs should be positive because Pyoframe will automatically\n            make them negative for maximization problems.\n        max:\n            The maximum value of the relaxation variable.\n\n    Returns:\n        The same constraint\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.maximize = m.hours_day\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        16.0\n        &gt;&gt;&gt; m.maximize += 2 * m.hours_day\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        19.0\n\n        `relax` can only be called after the sense of the model has been defined.\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n\n        One way to solve this is by setting the sense directly on the model. See how this works fine:\n\n        &gt;&gt;&gt; m = pf.Model(sense=\"max\")\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n\n        And now an example with dimensions:\n\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame(\n        ...     {\n        ...         \"project\": [\"A\", \"B\", \"C\"],\n        ...         \"cost_per_hour_underdelivered\": [10, 20, 30],\n        ...         \"hours_to_finish\": [9, 9, 9],\n        ...         \"max_underdelivered\": [1, 9, 9],\n        ...     }\n        ... )\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[\"project\"], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = (\n        ...     m.hours_spent\n        ...     &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n        ... ).relax(\n        ...     homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]],\n        ...     max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]],\n        ... )\n        &gt;&gt;&gt; m.only_one_day = m.hours_spent.sum(\"project\") &lt;= 24\n        &gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n        &gt;&gt;&gt; m.only_one_day.relax(1)\n        Traceback (most recent call last):\n        ...\n        ValueError: .relax() must be called before the Constraint is added to the model\n        &gt;&gt;&gt; m.attr.Silent = True\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.maximize.value\n        -50.0\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 8.0      \u2502\n        \u2502 B       \u2506 7.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if self._has_ids:\n        raise ValueError(\n            \".relax() must be called before the Constraint is added to the model\"\n        )\n\n    m = self._model\n    if m is None:\n        self._to_relax = FuncArgs(args=[cost, max])\n        return self\n\n    var_name = f\"{self.name}_relaxation\"\n    assert not hasattr(m, var_name), (\n        \"Conflicting names, relaxation variable already exists on the model.\"\n    )\n    var = Variable(self, lb=0, ub=max)\n    setattr(m, var_name, var)\n\n    if self.sense == ConstraintSense.LE:\n        self.lhs -= var\n    elif self.sense == ConstraintSense.GE:\n        self.lhs += var\n    else:  # pragma: no cover\n        # TODO\n        raise NotImplementedError(\n            \"Relaxation for equalities has not yet been implemented. Submit a pull request!\"\n        )\n\n    penalty = var * cost\n    if self.dimensions:\n        penalty = penalty.sum()\n    if m.sense is None:\n        raise ValueError(\n            \"Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\"\n        )\n    elif m.sense == ObjSense.MAX:\n        penalty *= -1\n    if m.has_objective:\n        m.objective += penalty\n    else:\n        m.objective = penalty\n\n    return self\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.to_str","title":"<code>to_str(return_df: bool = False) -&gt; str | pl.DataFrame</code>","text":"<pre><code>to_str(return_df: Literal[False] = False) -&gt; str\n</code></pre><pre><code>to_str(return_df: Literal[True] = True) -&gt; pl.DataFrame\n</code></pre> <p>Converts the constraint to a human-readable string, or several arranged in a table.</p> <p>Long expressions are truncated according to <code>Config.print_max_terms</code> and <code>Config.print_polars_config</code>.</p> <p>Parameters:</p> Name Type Description Default <code>return_df</code> <code>bool</code> <p>If <code>True</code>, returns a DataFrame containing strings instead of the string representation of the DataFrame.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; x = pf.Set(x=range(1000))\n&gt;&gt;&gt; y = pf.Set(y=range(1000))\n&gt;&gt;&gt; m.V = pf.Variable(x, y)\n&gt;&gt;&gt; expr = 2 * m.V * m.V\n&gt;&gt;&gt; print((expr &lt;= 3).to_str())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x      \u2506 y      \u2506 constraint                     \u2502\n\u2502 (1000) \u2506 (1000) \u2506                                \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 0      \u2506 2\u00a0V[0,0] * V[0,0] &lt;=\u00a03         \u2502\n\u2502 0      \u2506 1      \u2506 2\u00a0V[0,1] * V[0,1] &lt;=\u00a03         \u2502\n\u2502 0      \u2506 2      \u2506 2\u00a0V[0,2] * V[0,2] &lt;=\u00a03         \u2502\n\u2502 0      \u2506 3      \u2506 2\u00a0V[0,3] * V[0,3] &lt;=\u00a03         \u2502\n\u2502 0      \u2506 4      \u2506 2\u00a0V[0,4] * V[0,4] &lt;=\u00a03         \u2502\n\u2502 \u2026      \u2506 \u2026      \u2506 \u2026                              \u2502\n\u2502 999    \u2506 995    \u2506 2\u00a0V[999,995] * V[999,995] &lt;=\u00a03 \u2502\n\u2502 999    \u2506 996    \u2506 2\u00a0V[999,996] * V[999,996] &lt;=\u00a03 \u2502\n\u2502 999    \u2506 997    \u2506 2\u00a0V[999,997] * V[999,997] &lt;=\u00a03 \u2502\n\u2502 999    \u2506 998    \u2506 2\u00a0V[999,998] * V[999,998] &lt;=\u00a03 \u2502\n\u2502 999    \u2506 999    \u2506 2\u00a0V[999,999] * V[999,999] &lt;=\u00a03 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr = expr.sum(\"x\")\n&gt;&gt;&gt; print((expr &gt;= 3).to_str())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 y      \u2506 constraint                                                                              \u2502\n\u2502 (1000) \u2506                                                                                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 2\u00a0V[0,0] * V[0,0] +2\u00a0V[1,0] * V[1,0] +2\u00a0V[2,0] * V[2,0] +2\u00a0V[3,0] * V[3,0] +2\u00a0V[4,0] *  \u2502\n\u2502        \u2506 V[4,0] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 1      \u2506 2\u00a0V[0,1] * V[0,1] +2\u00a0V[1,1] * V[1,1] +2\u00a0V[2,1] * V[2,1] +2\u00a0V[3,1] * V[3,1] +2\u00a0V[4,1] *  \u2502\n\u2502        \u2506 V[4,1] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 2      \u2506 2\u00a0V[0,2] * V[0,2] +2\u00a0V[1,2] * V[1,2] +2\u00a0V[2,2] * V[2,2] +2\u00a0V[3,2] * V[3,2] +2\u00a0V[4,2] *  \u2502\n\u2502        \u2506 V[4,2] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 3      \u2506 2\u00a0V[0,3] * V[0,3] +2\u00a0V[1,3] * V[1,3] +2\u00a0V[2,3] * V[2,3] +2\u00a0V[3,3] * V[3,3] +2\u00a0V[4,3] *  \u2502\n\u2502        \u2506 V[4,3] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 4      \u2506 2\u00a0V[0,4] * V[0,4] +2\u00a0V[1,4] * V[1,4] +2\u00a0V[2,4] * V[2,4] +2\u00a0V[3,4] * V[3,4] +2\u00a0V[4,4] *  \u2502\n\u2502        \u2506 V[4,4] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 \u2026      \u2506 \u2026                                                                                       \u2502\n\u2502 995    \u2506 2\u00a0V[0,995] * V[0,995] +2\u00a0V[1,995] * V[1,995] +2\u00a0V[2,995] * V[2,995] +2\u00a0V[3,995] *       \u2502\n\u2502        \u2506 V[3,995] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2502 996    \u2506 2\u00a0V[0,996] * V[0,996] +2\u00a0V[1,996] * V[1,996] +2\u00a0V[2,996] * V[2,996] +2\u00a0V[3,996] *       \u2502\n\u2502        \u2506 V[3,996] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2502 997    \u2506 2\u00a0V[0,997] * V[0,997] +2\u00a0V[1,997] * V[1,997] +2\u00a0V[2,997] * V[2,997] +2\u00a0V[3,997] *       \u2502\n\u2502        \u2506 V[3,997] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2502 998    \u2506 2\u00a0V[0,998] * V[0,998] +2\u00a0V[1,998] * V[1,998] +2\u00a0V[2,998] * V[2,998] +2\u00a0V[3,998] *       \u2502\n\u2502        \u2506 V[3,998] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2502 999    \u2506 2\u00a0V[0,999] * V[0,999] +2\u00a0V[1,999] * V[1,999] +2\u00a0V[2,999] * V[2,999] +2\u00a0V[3,999] *       \u2502\n\u2502        \u2506 V[3,999] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr = expr.sum(\"y\")\n&gt;&gt;&gt; print((expr == 3).to_str())\n2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] +2\u00a0V[0,4] * V[0,4] \u2026 =\u00a03\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_str(self, return_df: bool = False) -&gt; str | pl.DataFrame:\n    \"\"\"Converts the constraint to a human-readable string, or several arranged in a table.\n\n    Long expressions are truncated according to [`Config.print_max_terms`][pyoframe._Config.print_max_terms] and [`Config.print_polars_config`][pyoframe._Config.print_polars_config].\n\n    Parameters:\n        return_df:\n            If `True`, returns a DataFrame containing strings instead of the string representation of the DataFrame.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; x = pf.Set(x=range(1000))\n        &gt;&gt;&gt; y = pf.Set(y=range(1000))\n        &gt;&gt;&gt; m.V = pf.Variable(x, y)\n        &gt;&gt;&gt; expr = 2 * m.V * m.V\n        &gt;&gt;&gt; print((expr &lt;= 3).to_str())\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x      \u2506 y      \u2506 constraint                     \u2502\n        \u2502 (1000) \u2506 (1000) \u2506                                \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0      \u2506 0      \u2506 2\u00a0V[0,0] * V[0,0] &lt;=\u00a03         \u2502\n        \u2502 0      \u2506 1      \u2506 2\u00a0V[0,1] * V[0,1] &lt;=\u00a03         \u2502\n        \u2502 0      \u2506 2      \u2506 2\u00a0V[0,2] * V[0,2] &lt;=\u00a03         \u2502\n        \u2502 0      \u2506 3      \u2506 2\u00a0V[0,3] * V[0,3] &lt;=\u00a03         \u2502\n        \u2502 0      \u2506 4      \u2506 2\u00a0V[0,4] * V[0,4] &lt;=\u00a03         \u2502\n        \u2502 \u2026      \u2506 \u2026      \u2506 \u2026                              \u2502\n        \u2502 999    \u2506 995    \u2506 2\u00a0V[999,995] * V[999,995] &lt;=\u00a03 \u2502\n        \u2502 999    \u2506 996    \u2506 2\u00a0V[999,996] * V[999,996] &lt;=\u00a03 \u2502\n        \u2502 999    \u2506 997    \u2506 2\u00a0V[999,997] * V[999,997] &lt;=\u00a03 \u2502\n        \u2502 999    \u2506 998    \u2506 2\u00a0V[999,998] * V[999,998] &lt;=\u00a03 \u2502\n        \u2502 999    \u2506 999    \u2506 2\u00a0V[999,999] * V[999,999] &lt;=\u00a03 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr = expr.sum(\"x\")\n        &gt;&gt;&gt; print((expr &gt;= 3).to_str())\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 y      \u2506 constraint                                                                              \u2502\n        \u2502 (1000) \u2506                                                                                         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0      \u2506 2\u00a0V[0,0] * V[0,0] +2\u00a0V[1,0] * V[1,0] +2\u00a0V[2,0] * V[2,0] +2\u00a0V[3,0] * V[3,0] +2\u00a0V[4,0] *  \u2502\n        \u2502        \u2506 V[4,0] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 1      \u2506 2\u00a0V[0,1] * V[0,1] +2\u00a0V[1,1] * V[1,1] +2\u00a0V[2,1] * V[2,1] +2\u00a0V[3,1] * V[3,1] +2\u00a0V[4,1] *  \u2502\n        \u2502        \u2506 V[4,1] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 2      \u2506 2\u00a0V[0,2] * V[0,2] +2\u00a0V[1,2] * V[1,2] +2\u00a0V[2,2] * V[2,2] +2\u00a0V[3,2] * V[3,2] +2\u00a0V[4,2] *  \u2502\n        \u2502        \u2506 V[4,2] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 3      \u2506 2\u00a0V[0,3] * V[0,3] +2\u00a0V[1,3] * V[1,3] +2\u00a0V[2,3] * V[2,3] +2\u00a0V[3,3] * V[3,3] +2\u00a0V[4,3] *  \u2502\n        \u2502        \u2506 V[4,3] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 4      \u2506 2\u00a0V[0,4] * V[0,4] +2\u00a0V[1,4] * V[1,4] +2\u00a0V[2,4] * V[2,4] +2\u00a0V[3,4] * V[3,4] +2\u00a0V[4,4] *  \u2502\n        \u2502        \u2506 V[4,4] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 \u2026      \u2506 \u2026                                                                                       \u2502\n        \u2502 995    \u2506 2\u00a0V[0,995] * V[0,995] +2\u00a0V[1,995] * V[1,995] +2\u00a0V[2,995] * V[2,995] +2\u00a0V[3,995] *       \u2502\n        \u2502        \u2506 V[3,995] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2502 996    \u2506 2\u00a0V[0,996] * V[0,996] +2\u00a0V[1,996] * V[1,996] +2\u00a0V[2,996] * V[2,996] +2\u00a0V[3,996] *       \u2502\n        \u2502        \u2506 V[3,996] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2502 997    \u2506 2\u00a0V[0,997] * V[0,997] +2\u00a0V[1,997] * V[1,997] +2\u00a0V[2,997] * V[2,997] +2\u00a0V[3,997] *       \u2502\n        \u2502        \u2506 V[3,997] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2502 998    \u2506 2\u00a0V[0,998] * V[0,998] +2\u00a0V[1,998] * V[1,998] +2\u00a0V[2,998] * V[2,998] +2\u00a0V[3,998] *       \u2502\n        \u2502        \u2506 V[3,998] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2502 999    \u2506 2\u00a0V[0,999] * V[0,999] +2\u00a0V[1,999] * V[1,999] +2\u00a0V[2,999] * V[2,999] +2\u00a0V[3,999] *       \u2502\n        \u2502        \u2506 V[3,999] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr = expr.sum(\"y\")\n        &gt;&gt;&gt; print((expr == 3).to_str())\n        2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] +2\u00a0V[0,4] * V[0,4] \u2026 =\u00a03\n    \"\"\"\n    dims = self.dimensions\n    str_table = self.lhs.to_str(\n        include_const_term=False, return_df=True, str_col_name=\"constraint\"\n    )\n    rhs = self.lhs.constant_terms.with_columns(pl.col(COEF_KEY) * -1)\n    rhs = cast_coef_to_string(rhs, drop_ones=False, always_show_sign=False)\n    rhs = rhs.rename({COEF_KEY: \"rhs\"})\n    if dims:\n        constr_str = str_table.join(\n            rhs, on=dims, how=\"left\", maintain_order=\"left\", coalesce=True\n        )\n    else:\n        constr_str = pl.concat([str_table, rhs], how=\"horizontal\")\n    constr_str = constr_str.with_columns(\n        pl.concat_str(\"constraint\", pl.lit(f\" {self.sense.value}\u00a0\"), \"rhs\")\n    ).drop(\"rhs\")\n\n    if not return_df:\n        if self.dimensions is None:\n            constr_str = constr_str.item()\n        else:\n            constr_str = self._add_shape_to_columns(constr_str)\n            with Config.print_polars_config:\n                constr_str = repr(constr_str)\n\n    return constr_str\n</code></pre>"},{"location":"reference/public/Expression/","title":"Expression","text":"<p>               Bases: <code>BaseOperableBlock</code></p> <p>Represents a linear or quadratic mathematical expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame(\n...     {\n...         \"item\": [1, 1, 1, 2, 2],\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"cost\": [1, 2, 3, 4, 5],\n...     }\n... ).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.Time = pf.Variable(df.index)\n&gt;&gt;&gt; m.Size = pf.Variable(df.index)\n&gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n&gt;&gt;&gt; expr\n&lt;Expression (linear) height=5 terms=10&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 time \u2506 expression                   \u2502\n\u2502 (2)  \u2506 (3)  \u2506                              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 mon  \u2506 Time[1,mon] +\u00a0Size[1,mon]    \u2502\n\u2502 1    \u2506 tue  \u2506 2\u00a0Time[1,tue] +2\u00a0Size[1,tue] \u2502\n\u2502 1    \u2506 wed  \u2506 3\u00a0Time[1,wed] +3\u00a0Size[1,wed] \u2502\n\u2502 2    \u2506 mon  \u2506 4\u00a0Time[2,mon] +4\u00a0Size[2,mon] \u2502\n\u2502 2    \u2506 tue  \u2506 5\u00a0Time[2,tue] +5\u00a0Size[2,tue] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Methods:</p> Name Description <code>constant</code> <p>Creates a new expression equal to the given constant.</p> <code>degree</code> <p>Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).</p> <code>evaluate</code> <p>Computes the value of the expression using the variables' solutions.</p> <code>map</code> <p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <code>rolling_sum</code> <p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <code>sum</code> <p>Sums an expression over specified dimensions.</p> <code>sum_by</code> <p>Like <code>Expression.sum</code>, but the sum is taken over all dimensions except those specified in <code>by</code> (just like a <code>group_by().sum()</code> operation).</p> <code>to_expr</code> <p>Returns the expression itself.</p> <code>to_str</code> <p>Converts the expression to a human-readable string, or several arranged in a table.</p> <code>within</code> <p>Filters this expression to only include the dimensions within the provided set.</p> <p>Attributes:</p> Name Type Description <code>constant_terms</code> <code>DataFrame</code> <p>Returns all the constant terms in the expression.</p> <code>is_quadratic</code> <code>bool</code> <p>Returns <code>True</code> if the expression is quadratic, False otherwise.</p> <code>terms</code> <code>int</code> <p>The number of terms across all subexpressions.</p> <code>variable_terms</code> <code>DataFrame</code> <p>Returns all the non-constant terms in the expression.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(self, data: pl.DataFrame, name: str | None = None):\n    # Sanity checks, VAR_KEY and COEF_KEY must be present\n    assert VAR_KEY in data.columns, \"Missing variable column.\"\n    assert COEF_KEY in data.columns, \"Missing coefficient column.\"\n\n    # Sanity check no duplicates labels\n    if Config.enable_is_duplicated_expression_safety_check:\n        duplicated_mask = data.drop(COEF_KEY).is_duplicated()\n        # In theory this should never happen unless there's a bug in the library\n        if duplicated_mask.any():\n            duplicated_data = data.filter(duplicated_mask)\n            raise ValueError(\n                f\"Cannot create an expression with duplicate labels:\\n{duplicated_data}.\"\n            )\n\n    data = _simplify_expr_df(data)\n\n    if name is None:\n        warnings.warn(\n            \"Expression should be given a name to support troubleshooting.\",\n            UserWarning,\n        )\n\n        super().__init__(data)\n    else:\n        super().__init__(data, name=name)\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.constant_terms","title":"<code>constant_terms: pl.DataFrame</code>","text":"<p>Returns all the constant terms in the expression.</p>"},{"location":"reference/public/Expression/#pyoframe.Expression.is_quadratic","title":"<code>is_quadratic: bool</code>","text":"<p>Returns <code>True</code> if the expression is quadratic, False otherwise.</p> <p>Computes in O(1) since expressions are quadratic if and only if self.data contain the QUAD_VAR_KEY column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}) * m.v\n&gt;&gt;&gt; expr *= m.v\n&gt;&gt;&gt; expr.is_quadratic\nTrue\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.terms","title":"<code>terms: int</code>","text":"<p>The number of terms across all subexpressions.</p> <p>Expressions equal to zero count as one term.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable({\"t\": [1, 2]})\n&gt;&gt;&gt; coef = pl.DataFrame({\"t\": [1, 2], \"coef\": [0, 1]})\n&gt;&gt;&gt; coef * (m.v + 4)\n&lt;Expression (linear) height=2 terms=3&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 t   \u2506 expression \u2502\n\u2502 (2) \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0          \u2502\n\u2502 2   \u2506 4 +\u00a0v[2]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; (coef * (m.v + 4)).terms\n3\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.variable_terms","title":"<code>variable_terms: pl.DataFrame</code>","text":"<p>Returns all the non-constant terms in the expression.</p>"},{"location":"reference/public/Expression/#pyoframe.Expression.constant","title":"<code>constant(constant: int | float) -&gt; Expression</code>","text":"<p>Creates a new expression equal to the given constant.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Expression.constant(5)\n&lt;Expression (parameter) terms=1&gt;\n5\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@classmethod\ndef constant(cls, constant: int | float) -&gt; Expression:\n    \"\"\"Creates a new expression equal to the given constant.\n\n    Examples:\n        &gt;&gt;&gt; pf.Expression.constant(5)\n        &lt;Expression (parameter) terms=1&gt;\n        5\n    \"\"\"\n    return cls(\n        pl.DataFrame(\n            {\n                COEF_KEY: [constant],\n                VAR_KEY: [CONST_TERM],\n            },\n            schema={COEF_KEY: pl.Float64, VAR_KEY: Config.id_dtype},\n        ),\n        name=str(constant),\n    )\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.degree","title":"<code>degree(return_str: bool = False) -&gt; int | str</code>","text":"<pre><code>degree(return_str: Literal[False] = False) -&gt; int\n</code></pre><pre><code>degree(return_str: Literal[True] = True) -&gt; str\n</code></pre> <p>Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).</p> <p>Parameters:</p> Name Type Description Default <code>return_str</code> <code>bool</code> <p>If <code>True</code>, returns the degree as a string (<code>\"constant\"</code>, <code>\"linear\"</code>, or <code>\"quadratic\"</code>). If <code>False</code>, returns the degree as an integer (0, 1, or 2).</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v1 = pf.Variable()\n&gt;&gt;&gt; m.v2 = pf.Variable()\n&gt;&gt;&gt; expr = pf.Param({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]})\n&gt;&gt;&gt; expr.degree()\n0\n&gt;&gt;&gt; expr *= m.v1\n&gt;&gt;&gt; expr.degree()\n1\n&gt;&gt;&gt; expr += (m.v2**2).over(\"dim1\")\n&gt;&gt;&gt; expr.degree()\n2\n&gt;&gt;&gt; expr.degree(return_str=True)\n'quadratic'\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def degree(self, return_str: bool = False) -&gt; int | str:\n    \"\"\"Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).\n\n    Parameters:\n        return_str: If `True`, returns the degree as a string (`\"constant\"`, `\"linear\"`, or `\"quadratic\"`).\n            If `False`, returns the degree as an integer (0, 1, or 2).\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v1 = pf.Variable()\n        &gt;&gt;&gt; m.v2 = pf.Variable()\n        &gt;&gt;&gt; expr = pf.Param({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]})\n        &gt;&gt;&gt; expr.degree()\n        0\n        &gt;&gt;&gt; expr *= m.v1\n        &gt;&gt;&gt; expr.degree()\n        1\n        &gt;&gt;&gt; expr += (m.v2**2).over(\"dim1\")\n        &gt;&gt;&gt; expr.degree()\n        2\n        &gt;&gt;&gt; expr.degree(return_str=True)\n        'quadratic'\n    \"\"\"\n    if self.is_quadratic:\n        return \"quadratic\" if return_str else 2\n    # TODO improve performance of .evaluate() by ensuring early exit if linear\n    elif (self.data.get_column(VAR_KEY) != CONST_TERM).any():\n        return \"linear\" if return_str else 1\n    else:\n        return \"parameter\" if return_str else 0\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.evaluate","title":"<code>evaluate() -&gt; pl.DataFrame</code>","text":"<p>Computes the value of the expression using the variables' solutions.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A Polars <code>DataFrame</code> for dimensioned expressions a <code>float</code> for dimensionless expressions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, lb=10, ub=10)\n&gt;&gt;&gt; m.expr = 2 * m.X * m.X + 1\n</code></pre> <pre><code>&gt;&gt;&gt; m.expr.evaluate()\nTraceback (most recent call last):\n...\nValueError: Cannot evaluate the expression 'expr' before calling model.optimize().\n</code></pre> <pre><code>&gt;&gt;&gt; m.constant_expression = m.expr - 2 * m.X * m.X\n&gt;&gt;&gt; m.constant_expression.evaluate()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0      \u2502\n\u2502 2    \u2506 1.0      \u2502\n\u2502 3    \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.expr.evaluate()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 201.0    \u2502\n\u2502 2    \u2506 201.0    \u2502\n\u2502 3    \u2506 201.0    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; m.expr.sum().evaluate()\n603.0\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@unwrap_single_values\ndef evaluate(self) -&gt; pl.DataFrame:\n    \"\"\"Computes the value of the expression using the variables' solutions.\n\n    Returns:\n        A Polars `DataFrame` for dimensioned expressions a `float` for dimensionless expressions.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, lb=10, ub=10)\n        &gt;&gt;&gt; m.expr = 2 * m.X * m.X + 1\n\n        &gt;&gt;&gt; m.expr.evaluate()\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot evaluate the expression 'expr' before calling model.optimize().\n\n        &gt;&gt;&gt; m.constant_expression = m.expr - 2 * m.X * m.X\n        &gt;&gt;&gt; m.constant_expression.evaluate()\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 solution \u2502\n        \u2502 ---  \u2506 ---      \u2502\n        \u2502 i64  \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0      \u2502\n        \u2502 2    \u2506 1.0      \u2502\n        \u2502 3    \u2506 1.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.expr.evaluate()\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 solution \u2502\n        \u2502 ---  \u2506 ---      \u2502\n        \u2502 i64  \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 201.0    \u2502\n        \u2502 2    \u2506 201.0    \u2502\n        \u2502 3    \u2506 201.0    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; m.expr.sum().evaluate()\n        603.0\n\n    \"\"\"\n    assert self._model is not None, (\n        \"Expression must be added to the model to use .value\"\n    )\n\n    df = self.data.rename({COEF_KEY: SOLUTION_KEY})\n    sm = self._model.poi\n    attr = poi.VariableAttribute.Value\n\n    if self.degree() == 0:\n        df = df.drop(self._variable_columns)\n    elif (\n        self._model.attr.TerminationStatus\n        == poi.TerminationStatusCode.OPTIMIZE_NOT_CALLED\n    ):\n        raise ValueError(\n            f\"Cannot evaluate the expression '{self.name}' before calling model.optimize().\"\n        )\n    else:\n        for var_col in self._variable_columns:\n            values = [\n                sm.get_variable_attribute(poi.VariableIndex(v_id), attr)\n                for v_id in df.get_column(var_col).to_list()\n            ]\n\n            df = df.drop(var_col).with_columns(\n                pl.col(SOLUTION_KEY) * pl.Series(values, dtype=pl.Float64)\n            )\n\n    dims = self.dimensions\n    if dims is not None:\n        df = df.group_by(dims, maintain_order=Config.maintain_order)\n    return df.sum()\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.map","title":"<code>map(mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression</code>","text":"<p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <p>This is particularly useful to go from one type of dimensions to another. For example, to convert data that is indexed by city to data indexed by country (see example).</p> <p>Parameters:</p> Name Type Description Default <code>mapping_set</code> <code>SetTypes</code> <p>The set to map the expression to. This can be a DataFrame, Index, or another Set.</p> required <code>drop_shared_dims</code> <code>bool</code> <p>If <code>True</code>, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and     repeated rows are summed. If <code>False</code>, the shared dimensions are kept in the resulting expression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression containing the result of the mapping operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; pop_data = pf.Param(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n...         \"year\": [2024, 2024, 2024],\n...         \"population\": [10, 2, 8],\n...     }\n... )\n&gt;&gt;&gt; cities_and_countries = pl.DataFrame(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n...         \"country\": [\"Canada\", \"Canada\", \"USA\"],\n...     }\n... )\n&gt;&gt;&gt; pop_data.map(cities_and_countries)\n&lt;Expression (parameter) height=2 terms=2&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 year \u2506 country \u2506 expression \u2502\n\u2502 (1)  \u2506 (2)     \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024 \u2506 Canada  \u2506 12         \u2502\n\u2502 2024 \u2506 USA     \u2506 8          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n&lt;Expression (parameter) height=3 terms=3&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 city      \u2506 year \u2506 country \u2506 expression \u2502\n\u2502 (3)       \u2506 (1)  \u2506 (2)     \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto   \u2506 2024 \u2506 Canada  \u2506 10         \u2502\n\u2502 Vancouver \u2506 2024 \u2506 Canada  \u2506 2          \u2502\n\u2502 Boston    \u2506 2024 \u2506 USA     \u2506 8          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def map(self, mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression:\n    \"\"\"Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.\n\n    This is particularly useful to go from one type of dimensions to another. For example, to convert data that\n    is indexed by city to data indexed by country (see example).\n\n    Parameters:\n        mapping_set:\n            The set to map the expression to. This can be a DataFrame, Index, or another Set.\n        drop_shared_dims:\n            If `True`, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and\n                repeated rows are summed.\n            If `False`, the shared dimensions are kept in the resulting expression.\n\n    Returns:\n        A new Expression containing the result of the mapping operation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; pop_data = pf.Param(\n        ...     {\n        ...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n        ...         \"year\": [2024, 2024, 2024],\n        ...         \"population\": [10, 2, 8],\n        ...     }\n        ... )\n        &gt;&gt;&gt; cities_and_countries = pl.DataFrame(\n        ...     {\n        ...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n        ...         \"country\": [\"Canada\", \"Canada\", \"USA\"],\n        ...     }\n        ... )\n        &gt;&gt;&gt; pop_data.map(cities_and_countries)\n        &lt;Expression (parameter) height=2 terms=2&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 year \u2506 country \u2506 expression \u2502\n        \u2502 (1)  \u2506 (2)     \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024 \u2506 Canada  \u2506 12         \u2502\n        \u2502 2024 \u2506 USA     \u2506 8          \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n        &lt;Expression (parameter) height=3 terms=3&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 city      \u2506 year \u2506 country \u2506 expression \u2502\n        \u2502 (3)       \u2506 (1)  \u2506 (2)     \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Toronto   \u2506 2024 \u2506 Canada  \u2506 10         \u2502\n        \u2502 Vancouver \u2506 2024 \u2506 Canada  \u2506 2          \u2502\n        \u2502 Boston    \u2506 2024 \u2506 USA     \u2506 8          \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    mapping_set = Set(mapping_set)\n\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot use .map() on an expression with no dimensions.\")\n\n    mapping_dims = mapping_set.dimensions\n    if mapping_dims is None:\n        raise ValueError(\n            \"Cannot use .map() with a mapping set containing no dimensions.\"\n        )\n\n    shared_dims = [dim for dim in dims if dim in mapping_dims]\n    if not shared_dims:\n        raise ValueError(\n            f\"Cannot apply .map() as there are no shared dimensions between the expression (dims={self.dimensions}) and the mapping set (dims={mapping_set.dimensions}).\"\n        )\n\n    mapped_expression = self * mapping_set\n\n    if drop_shared_dims:\n        mapped_expression = mapped_expression.sum(*shared_dims)\n\n    mapped_expression.name = f\"{self.name}.map(\u2026)\"\n\n    return mapped_expression\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.rolling_sum","title":"<code>rolling_sum(over: str, window_size: int) -&gt; Expression</code>","text":"<p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <p>This method applies a rolling sum operation over the dimension specified by <code>over</code>, using a window defined by <code>window_size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>over</code> <code>str</code> <p>The name of the dimension (column) over which the rolling sum is calculated. This dimension must exist within the Expression's dimensions.</p> required <code>window_size</code> <code>int</code> <p>The size of the moving window in terms of number of records. The rolling sum is calculated over this many consecutive elements.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression instance containing the result of the rolling sum operation. This new Expression retains all dimensions (columns) of the original data, with the rolling sum applied over the specified dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; cost = pl.DataFrame(\n...     {\n...         \"item\": [1, 1, 1, 2, 2],\n...         \"time\": [1, 2, 3, 1, 2],\n...         \"cost\": [1, 2, 3, 4, 5],\n...     }\n... )\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n&gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n&lt;Expression (linear) height=5 terms=8&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 time \u2506 expression                       \u2502\n\u2502 (2)  \u2506 (3)  \u2506                                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 quantity[1,1]                    \u2502\n\u2502 1    \u2506 2    \u2506 quantity[1,1] +2\u00a0quantity[1,2]   \u2502\n\u2502 1    \u2506 3    \u2506 2\u00a0quantity[1,2] +3\u00a0quantity[1,3] \u2502\n\u2502 2    \u2506 1    \u2506 4\u00a0quantity[2,1]                  \u2502\n\u2502 2    \u2506 2    \u2506 4\u00a0quantity[2,1] +5\u00a0quantity[2,2] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef rolling_sum(self, over: str, window_size: int):\n    \"\"\"Calculates the rolling sum of the Expression over a specified window size for a given dimension.\n\n    This method applies a rolling sum operation over the dimension specified by `over`,\n    using a window defined by `window_size`.\n\n\n    Parameters:\n        over:\n            The name of the dimension (column) over which the rolling sum is calculated.\n            This dimension must exist within the Expression's dimensions.\n        window_size:\n            The size of the moving window in terms of number of records.\n            The rolling sum is calculated over this many consecutive elements.\n\n    Returns:\n        A new Expression instance containing the result of the rolling sum operation.\n            This new Expression retains all dimensions (columns) of the original data,\n            with the rolling sum applied over the specified dimension.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; cost = pl.DataFrame(\n        ...     {\n        ...         \"item\": [1, 1, 1, 2, 2],\n        ...         \"time\": [1, 2, 3, 1, 2],\n        ...         \"cost\": [1, 2, 3, 4, 5],\n        ...     }\n        ... )\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n        &gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n        &lt;Expression (linear) height=5 terms=8&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 item \u2506 time \u2506 expression                       \u2502\n        \u2502 (2)  \u2506 (3)  \u2506                                  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1    \u2506 quantity[1,1]                    \u2502\n        \u2502 1    \u2506 2    \u2506 quantity[1,1] +2\u00a0quantity[1,2]   \u2502\n        \u2502 1    \u2506 3    \u2506 2\u00a0quantity[1,2] +3\u00a0quantity[1,3] \u2502\n        \u2502 2    \u2506 1    \u2506 4\u00a0quantity[2,1]                  \u2502\n        \u2502 2    \u2506 2    \u2506 4\u00a0quantity[2,1] +5\u00a0quantity[2,2] \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\n            \"Cannot use rolling_sum() with an expression with no dimensions.\"\n        )\n    assert over in dims, f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return pl.concat(\n        [\n            df.with_columns(pl.col(over).max())\n            for _, df in self.data.rolling(\n                index_column=over,\n                period=f\"{window_size}i\",\n                group_by=remaining_dims,\n            )\n        ]\n    )\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.sum","title":"<code>sum(*over: str) -&gt; Expression</code>","text":"<p>Sums an expression over specified dimensions.</p> <p>If no dimensions are specified, the sum is taken over all of the expression's dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = pf.Param(\n...     {\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"place\": [\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Vancouver\",\n...             \"Vancouver\",\n...         ],\n...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n...     }\n... )\n&gt;&gt;&gt; expr\n&lt;Expression (parameter) height=5 terms=5&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time \u2506 place     \u2506 expression \u2502\n\u2502 (3)  \u2506 (2)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 mon  \u2506 Toronto   \u2506 1000000    \u2502\n\u2502 tue  \u2506 Toronto   \u2506 3000000    \u2502\n\u2502 wed  \u2506 Toronto   \u2506 2000000    \u2502\n\u2502 mon  \u2506 Vancouver \u2506 1000000    \u2502\n\u2502 tue  \u2506 Vancouver \u2506 2000000    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr.sum(\"time\")\n&lt;Expression (parameter) height=2 terms=2&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 place     \u2506 expression \u2502\n\u2502 (2)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto   \u2506 6000000    \u2502\n\u2502 Vancouver \u2506 3000000    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr.sum()\n&lt;Expression (parameter) terms=1&gt;\n9000000\n</code></pre> <p>If the given dimensions don't exist, an error will be raised:</p> <pre><code>&gt;&gt;&gt; expr.sum(\"city\")\nTraceback (most recent call last):\n...\nAssertionError: Cannot sum over ['city'] as it is not in ['time', 'place']\n</code></pre> See Also <p>pyoframe.Expression.sum_by for summing over all dimensions except those that are specified.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef sum(self, *over: str):\n    \"\"\"Sums an expression over specified dimensions.\n\n    If no dimensions are specified, the sum is taken over all of the expression's dimensions.\n\n    Examples:\n        &gt;&gt;&gt; expr = pf.Param(\n        ...     {\n        ...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n        ...         \"place\": [\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Vancouver\",\n        ...             \"Vancouver\",\n        ...         ],\n        ...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n        ...     }\n        ... )\n        &gt;&gt;&gt; expr\n        &lt;Expression (parameter) height=5 terms=5&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time \u2506 place     \u2506 expression \u2502\n        \u2502 (3)  \u2506 (2)       \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 mon  \u2506 Toronto   \u2506 1000000    \u2502\n        \u2502 tue  \u2506 Toronto   \u2506 3000000    \u2502\n        \u2502 wed  \u2506 Toronto   \u2506 2000000    \u2502\n        \u2502 mon  \u2506 Vancouver \u2506 1000000    \u2502\n        \u2502 tue  \u2506 Vancouver \u2506 2000000    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr.sum(\"time\")\n        &lt;Expression (parameter) height=2 terms=2&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 place     \u2506 expression \u2502\n        \u2502 (2)       \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Toronto   \u2506 6000000    \u2502\n        \u2502 Vancouver \u2506 3000000    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr.sum()\n        &lt;Expression (parameter) terms=1&gt;\n        9000000\n\n        If the given dimensions don't exist, an error will be raised:\n\n        &gt;&gt;&gt; expr.sum(\"city\")\n        Traceback (most recent call last):\n        ...\n        AssertionError: Cannot sum over ['city'] as it is not in ['time', 'place']\n\n    See Also:\n        [pyoframe.Expression.sum_by][] for summing over all dimensions _except_ those that are specified.\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot sum a dimensionless expression.\")\n    if not over:\n        over = tuple(dims)\n    assert set(over) &lt;= set(dims), (\n        f\"Cannot sum over {list(over)} as it is not in {dims}\"\n    )\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return (\n        self.data.drop(over)\n        .group_by(\n            remaining_dims + self._variable_columns,\n            maintain_order=Config.maintain_order,\n        )\n        .sum()\n    )\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.sum_by","title":"<code>sum_by(*by: str)</code>","text":"<p>Like <code>Expression.sum</code>, but the sum is taken over all dimensions except those specified in <code>by</code> (just like a <code>group_by().sum()</code> operation).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = pf.Param(\n...     {\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"place\": [\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Vancouver\",\n...             \"Vancouver\",\n...         ],\n...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n...     }\n... )\n&gt;&gt;&gt; expr\n&lt;Expression (parameter) height=5 terms=5&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time \u2506 place     \u2506 expression \u2502\n\u2502 (3)  \u2506 (2)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 mon  \u2506 Toronto   \u2506 1000000    \u2502\n\u2502 tue  \u2506 Toronto   \u2506 3000000    \u2502\n\u2502 wed  \u2506 Toronto   \u2506 2000000    \u2502\n\u2502 mon  \u2506 Vancouver \u2506 1000000    \u2502\n\u2502 tue  \u2506 Vancouver \u2506 2000000    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; expr.sum_by(\"place\")\n&lt;Expression (parameter) height=2 terms=2&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 place     \u2506 expression \u2502\n\u2502 (2)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto   \u2506 6000000    \u2502\n\u2502 Vancouver \u2506 3000000    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If the specified dimensions don't exist, an error will be raised:</p> <pre><code>&gt;&gt;&gt; expr.sum_by(\"city\")\nTraceback (most recent call last):\n...\nValueError: Cannot sum by ['city'] because it is not a valid dimension. The expression's dimensions are: ['time', 'place'].\n</code></pre> <pre><code>&gt;&gt;&gt; total_sum = expr.sum()\n&gt;&gt;&gt; total_sum.sum_by(\"time\")\nTraceback (most recent call last):\n...\nValueError: Cannot sum a dimensionless expression.\n</code></pre> See Also <p>pyoframe.Expression.sum for summing over specified dimensions.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def sum_by(self, *by: str):\n    \"\"\"Like [`Expression.sum`][pyoframe.Expression.sum], but the sum is taken over all dimensions *except* those specified in `by` (just like a `group_by().sum()` operation).\n\n    Examples:\n        &gt;&gt;&gt; expr = pf.Param(\n        ...     {\n        ...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n        ...         \"place\": [\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Vancouver\",\n        ...             \"Vancouver\",\n        ...         ],\n        ...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n        ...     }\n        ... )\n        &gt;&gt;&gt; expr\n        &lt;Expression (parameter) height=5 terms=5&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time \u2506 place     \u2506 expression \u2502\n        \u2502 (3)  \u2506 (2)       \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 mon  \u2506 Toronto   \u2506 1000000    \u2502\n        \u2502 tue  \u2506 Toronto   \u2506 3000000    \u2502\n        \u2502 wed  \u2506 Toronto   \u2506 2000000    \u2502\n        \u2502 mon  \u2506 Vancouver \u2506 1000000    \u2502\n        \u2502 tue  \u2506 Vancouver \u2506 2000000    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; expr.sum_by(\"place\")\n        &lt;Expression (parameter) height=2 terms=2&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 place     \u2506 expression \u2502\n        \u2502 (2)       \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Toronto   \u2506 6000000    \u2502\n        \u2502 Vancouver \u2506 3000000    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        If the specified dimensions don't exist, an error will be raised:\n\n        &gt;&gt;&gt; expr.sum_by(\"city\")\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot sum by ['city'] because it is not a valid dimension. The expression's dimensions are: ['time', 'place'].\n\n        &gt;&gt;&gt; total_sum = expr.sum()\n        &gt;&gt;&gt; total_sum.sum_by(\"time\")\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot sum a dimensionless expression.\n\n    See Also:\n        [pyoframe.Expression.sum][] for summing over specified dimensions.\n    \"\"\"\n    if not by:\n        raise ValueError(\"sum_by requires at least 1 argument.\")\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot sum a dimensionless expression.\")\n    if not set(by) &lt;= set(dims):\n        raise ValueError(\n            f\"Cannot sum by {list(set(by) - set(dims))} because it is not a valid dimension. The expression's dimensions are: {list(dims)}.\"\n        )\n    remaining_dims = [dim for dim in dims if dim not in by]\n    return self.sum(*remaining_dims)\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.to_expr","title":"<code>to_expr() -&gt; Expression</code>","text":"<p>Returns the expression itself.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    \"\"\"Returns the expression itself.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.to_str","title":"<code>to_str(str_col_name: str = 'expression', include_const_term: bool = True, return_df: bool = False) -&gt; str | pl.DataFrame</code>","text":"<pre><code>to_str(\n    str_col_name: str = \"expression\",\n    include_const_term: bool = True,\n    return_df: Literal[False] = False,\n) -&gt; str\n</code></pre><pre><code>to_str(\n    str_col_name: str = \"expression\",\n    include_const_term: bool = True,\n    return_df: Literal[True] = True,\n) -&gt; pl.DataFrame\n</code></pre> <p>Converts the expression to a human-readable string, or several arranged in a table.</p> <p>Long expressions are truncated according to <code>Config.print_max_terms</code> and <code>Config.print_polars_config</code>.</p> <p><code>str(pyoframe.Expression)</code> is equivalent to <code>pyoframe.Expression.to_str()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>str_col_name</code> <code>str</code> <p>The name of the column containing the string representation of the expression (dimensioned expressions only).</p> <code>'expression'</code> <code>include_const_term</code> <code>bool</code> <p>If <code>False</code>, constant terms are omitted from the string representation.</p> <code>True</code> <code>return_df</code> <code>bool</code> <p>If <code>True</code>, returns a DataFrame containing the human-readable strings instead of the DataFrame's string representation.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; x = pf.Set(x=range(1000))\n&gt;&gt;&gt; y = pf.Set(y=range(1000))\n&gt;&gt;&gt; m.V = pf.Variable(x, y)\n&gt;&gt;&gt; expr = 2 * m.V * m.V + 3\n&gt;&gt;&gt; print(expr.to_str())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x      \u2506 y      \u2506 expression                   \u2502\n\u2502 (1000) \u2506 (1000) \u2506                              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 0      \u2506 3 +2\u00a0V[0,0] * V[0,0]         \u2502\n\u2502 0      \u2506 1      \u2506 3 +2\u00a0V[0,1] * V[0,1]         \u2502\n\u2502 0      \u2506 2      \u2506 3 +2\u00a0V[0,2] * V[0,2]         \u2502\n\u2502 0      \u2506 3      \u2506 3 +2\u00a0V[0,3] * V[0,3]         \u2502\n\u2502 0      \u2506 4      \u2506 3 +2\u00a0V[0,4] * V[0,4]         \u2502\n\u2502 \u2026      \u2506 \u2026      \u2506 \u2026                            \u2502\n\u2502 999    \u2506 995    \u2506 3 +2\u00a0V[999,995] * V[999,995] \u2502\n\u2502 999    \u2506 996    \u2506 3 +2\u00a0V[999,996] * V[999,996] \u2502\n\u2502 999    \u2506 997    \u2506 3 +2\u00a0V[999,997] * V[999,997] \u2502\n\u2502 999    \u2506 998    \u2506 3 +2\u00a0V[999,998] * V[999,998] \u2502\n\u2502 999    \u2506 999    \u2506 3 +2\u00a0V[999,999] * V[999,999] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr = expr.sum(\"y\")\n&gt;&gt;&gt; print(expr.to_str())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x      \u2506 expression                                                                              \u2502\n\u2502 (1000) \u2506                                                                                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 3000 +2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] \u2026      \u2502\n\u2502 1      \u2506 3000 +2\u00a0V[1,0] * V[1,0] +2\u00a0V[1,1] * V[1,1] +2\u00a0V[1,2] * V[1,2] +2\u00a0V[1,3] * V[1,3] \u2026      \u2502\n\u2502 2      \u2506 3000 +2\u00a0V[2,0] * V[2,0] +2\u00a0V[2,1] * V[2,1] +2\u00a0V[2,2] * V[2,2] +2\u00a0V[2,3] * V[2,3] \u2026      \u2502\n\u2502 3      \u2506 3000 +2\u00a0V[3,0] * V[3,0] +2\u00a0V[3,1] * V[3,1] +2\u00a0V[3,2] * V[3,2] +2\u00a0V[3,3] * V[3,3] \u2026      \u2502\n\u2502 4      \u2506 3000 +2\u00a0V[4,0] * V[4,0] +2\u00a0V[4,1] * V[4,1] +2\u00a0V[4,2] * V[4,2] +2\u00a0V[4,3] * V[4,3] \u2026      \u2502\n\u2502 \u2026      \u2506 \u2026                                                                                       \u2502\n\u2502 995    \u2506 3000 +2\u00a0V[995,0] * V[995,0] +2\u00a0V[995,1] * V[995,1] +2\u00a0V[995,2] * V[995,2] +2\u00a0V[995,3] * \u2502\n\u2502        \u2506 V[995,3] \u2026                                                                              \u2502\n\u2502 996    \u2506 3000 +2\u00a0V[996,0] * V[996,0] +2\u00a0V[996,1] * V[996,1] +2\u00a0V[996,2] * V[996,2] +2\u00a0V[996,3] * \u2502\n\u2502        \u2506 V[996,3] \u2026                                                                              \u2502\n\u2502 997    \u2506 3000 +2\u00a0V[997,0] * V[997,0] +2\u00a0V[997,1] * V[997,1] +2\u00a0V[997,2] * V[997,2] +2\u00a0V[997,3] * \u2502\n\u2502        \u2506 V[997,3] \u2026                                                                              \u2502\n\u2502 998    \u2506 3000 +2\u00a0V[998,0] * V[998,0] +2\u00a0V[998,1] * V[998,1] +2\u00a0V[998,2] * V[998,2] +2\u00a0V[998,3] * \u2502\n\u2502        \u2506 V[998,3] \u2026                                                                              \u2502\n\u2502 999    \u2506 3000 +2\u00a0V[999,0] * V[999,0] +2\u00a0V[999,1] * V[999,1] +2\u00a0V[999,2] * V[999,2] +2\u00a0V[999,3] * \u2502\n\u2502        \u2506 V[999,3] \u2026                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr = expr.sum(\"x\")\n&gt;&gt;&gt; print(expr.to_str())\n3000000 +2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] \u2026\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_str(\n    self,\n    str_col_name: str = \"expression\",\n    include_const_term: bool = True,\n    return_df: bool = False,\n) -&gt; str | pl.DataFrame:\n    \"\"\"Converts the expression to a human-readable string, or several arranged in a table.\n\n    Long expressions are truncated according to [`Config.print_max_terms`][pyoframe._Config.print_max_terms] and [`Config.print_polars_config`][pyoframe._Config.print_polars_config].\n\n    `str(pyoframe.Expression)` is equivalent to `pyoframe.Expression.to_str()`.\n\n    Parameters:\n        str_col_name:\n            The name of the column containing the string representation of the expression (dimensioned expressions only).\n        include_const_term:\n            If `False`, constant terms are omitted from the string representation.\n        return_df:\n            If `True`, returns a DataFrame containing the human-readable strings instead of the DataFrame's string representation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; x = pf.Set(x=range(1000))\n        &gt;&gt;&gt; y = pf.Set(y=range(1000))\n        &gt;&gt;&gt; m.V = pf.Variable(x, y)\n        &gt;&gt;&gt; expr = 2 * m.V * m.V + 3\n        &gt;&gt;&gt; print(expr.to_str())\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x      \u2506 y      \u2506 expression                   \u2502\n        \u2502 (1000) \u2506 (1000) \u2506                              \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0      \u2506 0      \u2506 3 +2\u00a0V[0,0] * V[0,0]         \u2502\n        \u2502 0      \u2506 1      \u2506 3 +2\u00a0V[0,1] * V[0,1]         \u2502\n        \u2502 0      \u2506 2      \u2506 3 +2\u00a0V[0,2] * V[0,2]         \u2502\n        \u2502 0      \u2506 3      \u2506 3 +2\u00a0V[0,3] * V[0,3]         \u2502\n        \u2502 0      \u2506 4      \u2506 3 +2\u00a0V[0,4] * V[0,4]         \u2502\n        \u2502 \u2026      \u2506 \u2026      \u2506 \u2026                            \u2502\n        \u2502 999    \u2506 995    \u2506 3 +2\u00a0V[999,995] * V[999,995] \u2502\n        \u2502 999    \u2506 996    \u2506 3 +2\u00a0V[999,996] * V[999,996] \u2502\n        \u2502 999    \u2506 997    \u2506 3 +2\u00a0V[999,997] * V[999,997] \u2502\n        \u2502 999    \u2506 998    \u2506 3 +2\u00a0V[999,998] * V[999,998] \u2502\n        \u2502 999    \u2506 999    \u2506 3 +2\u00a0V[999,999] * V[999,999] \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr = expr.sum(\"y\")\n        &gt;&gt;&gt; print(expr.to_str())\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x      \u2506 expression                                                                              \u2502\n        \u2502 (1000) \u2506                                                                                         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0      \u2506 3000 +2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] \u2026      \u2502\n        \u2502 1      \u2506 3000 +2\u00a0V[1,0] * V[1,0] +2\u00a0V[1,1] * V[1,1] +2\u00a0V[1,2] * V[1,2] +2\u00a0V[1,3] * V[1,3] \u2026      \u2502\n        \u2502 2      \u2506 3000 +2\u00a0V[2,0] * V[2,0] +2\u00a0V[2,1] * V[2,1] +2\u00a0V[2,2] * V[2,2] +2\u00a0V[2,3] * V[2,3] \u2026      \u2502\n        \u2502 3      \u2506 3000 +2\u00a0V[3,0] * V[3,0] +2\u00a0V[3,1] * V[3,1] +2\u00a0V[3,2] * V[3,2] +2\u00a0V[3,3] * V[3,3] \u2026      \u2502\n        \u2502 4      \u2506 3000 +2\u00a0V[4,0] * V[4,0] +2\u00a0V[4,1] * V[4,1] +2\u00a0V[4,2] * V[4,2] +2\u00a0V[4,3] * V[4,3] \u2026      \u2502\n        \u2502 \u2026      \u2506 \u2026                                                                                       \u2502\n        \u2502 995    \u2506 3000 +2\u00a0V[995,0] * V[995,0] +2\u00a0V[995,1] * V[995,1] +2\u00a0V[995,2] * V[995,2] +2\u00a0V[995,3] * \u2502\n        \u2502        \u2506 V[995,3] \u2026                                                                              \u2502\n        \u2502 996    \u2506 3000 +2\u00a0V[996,0] * V[996,0] +2\u00a0V[996,1] * V[996,1] +2\u00a0V[996,2] * V[996,2] +2\u00a0V[996,3] * \u2502\n        \u2502        \u2506 V[996,3] \u2026                                                                              \u2502\n        \u2502 997    \u2506 3000 +2\u00a0V[997,0] * V[997,0] +2\u00a0V[997,1] * V[997,1] +2\u00a0V[997,2] * V[997,2] +2\u00a0V[997,3] * \u2502\n        \u2502        \u2506 V[997,3] \u2026                                                                              \u2502\n        \u2502 998    \u2506 3000 +2\u00a0V[998,0] * V[998,0] +2\u00a0V[998,1] * V[998,1] +2\u00a0V[998,2] * V[998,2] +2\u00a0V[998,3] * \u2502\n        \u2502        \u2506 V[998,3] \u2026                                                                              \u2502\n        \u2502 999    \u2506 3000 +2\u00a0V[999,0] * V[999,0] +2\u00a0V[999,1] * V[999,1] +2\u00a0V[999,2] * V[999,2] +2\u00a0V[999,3] * \u2502\n        \u2502        \u2506 V[999,3] \u2026                                                                              \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr = expr.sum(\"x\")\n        &gt;&gt;&gt; print(expr.to_str())\n        3000000 +2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] \u2026\n\n    \"\"\"\n    # TODO consider optimizing using LazyFrames since .head() could maybe be automatically pushed up the chain of operations.\n    data = self.data if include_const_term else self.variable_terms\n    data = cast_coef_to_string(data)\n\n    for var_col in self._variable_columns:\n        temp_var_column = f\"{var_col}_temp\"\n        if self._model is not None and self._model._var_map is not None:\n            data = self._model._var_map.apply(\n                data, to_col=temp_var_column, id_col=var_col\n            )\n        else:\n            data = data.with_columns(\n                pl.concat_str(pl.lit(\"x\"), var_col).alias(temp_var_column)\n            )\n        data = data.with_columns(\n            pl.when(pl.col(var_col) == CONST_TERM)\n            .then(pl.lit(\"\"))\n            .otherwise(temp_var_column)\n            .alias(var_col)\n        ).drop(temp_var_column)\n    if self.is_quadratic:\n        data = data.with_columns(\n            pl.when(pl.col(QUAD_VAR_KEY) == \"\")\n            .then(pl.col(VAR_KEY))\n            .otherwise(pl.concat_str(VAR_KEY, pl.lit(\" * \"), pl.col(QUAD_VAR_KEY)))\n            .alias(VAR_KEY)\n        ).drop(QUAD_VAR_KEY)\n\n    dimensions = self.dimensions\n\n    # Create a string for each term\n    data = data.with_columns(\n        pl.concat_str(\n            COEF_KEY,\n            pl.lit(\"\u00a0\"),\n            VAR_KEY,\n        )\n        .str.strip_chars(characters=\" \u00a0\")\n        .alias(str_col_name)\n    ).drop(COEF_KEY, VAR_KEY)\n\n    if dimensions is not None:\n        data = data.group_by(dimensions, maintain_order=Config.maintain_order).agg(\n            pl.concat_str(\n                pl.col(str_col_name)\n                .head(Config.print_max_terms)\n                .str.join(delimiter=\" \"),\n                pl.when(pl.len() &gt; Config.print_max_terms)\n                .then(pl.lit(\" \u2026\"))\n                .otherwise(pl.lit(\"\")),\n            )\n        )\n    else:\n        truncate = data.height &gt; Config.print_max_terms\n        if truncate:\n            data = data.head(Config.print_max_terms)\n\n        data = data.select(pl.col(str_col_name).str.join(delimiter=\" \"))\n\n        if truncate:\n            data = data.with_columns(\n                pl.concat_str(pl.col(str_col_name), pl.lit(\" \u2026\"))\n            )\n\n    # Remove leading +\n    data = data.with_columns(pl.col(str_col_name).str.strip_chars(characters=\" \u00a0+\"))\n\n    if not return_df:\n        if dimensions is None and not self._allowed_new_dims:\n            data = data.item()\n        else:\n            data = self._add_shape_to_columns(data)\n            data = self._add_allowed_new_dims_to_df(data)\n            with Config.print_polars_config:\n                data = repr(data)\n\n    return data\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.within","title":"<code>within(set: SetTypes) -&gt; Expression</code>","text":"<p>Filters this expression to only include the dimensions within the provided set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; general_expr = pf.Param({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]})\n&gt;&gt;&gt; filter_expr = pf.Param({\"dim1\": [1, 3], \"value\": [5, 6]})\n&gt;&gt;&gt; general_expr.within(filter_expr).data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0     \u2506 0             \u2502\n\u2502 3    \u2506 3.0     \u2506 0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef within(self, set: SetTypes):\n    \"\"\"Filters this expression to only include the dimensions within the provided set.\n\n    Examples:\n        &gt;&gt;&gt; general_expr = pf.Param({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]})\n        &gt;&gt;&gt; filter_expr = pf.Param({\"dim1\": [1, 3], \"value\": [5, 6]})\n        &gt;&gt;&gt; general_expr.within(filter_expr).data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0     \u2506 0             \u2502\n        \u2502 3    \u2506 3.0     \u2506 0             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df: pl.DataFrame = Set(set).data\n    set_dims = _get_dimensions(df)\n    assert set_dims is not None, (\n        \"Cannot use .within() with a set with no dimensions.\"\n    )\n    dims = self.dimensions\n    assert dims is not None, (\n        \"Cannot use .within() with an expression with no dimensions.\"\n    )\n    dims_in_common = [dim for dim in dims if dim in set_dims]\n    by_dims = df.select(dims_in_common).unique(maintain_order=Config.maintain_order)\n    return self.data.join(\n        by_dims,\n        on=dims_in_common,\n        maintain_order=\"left\" if Config.maintain_order else None,\n    )\n</code></pre>"},{"location":"reference/public/Model/","title":"Model","text":"<p>The founding block of any Pyoframe optimization model onto which variables, constraints, and an objective can be added.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>SUPPORTED_SOLVER_TYPES | _Solver | None</code> <p>The solver to use. If <code>None</code>, Pyoframe will try to use whichever solver is installed (unless Config.default_solver was changed from its default value of <code>auto</code>).</p> <code>None</code> <code>solver_env</code> <code>dict[str, str] | None</code> <p>Gurobi only: a dictionary of parameters to set when creating the Gurobi environment.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>The name of the model. Currently it is not used for much.</p> <code>None</code> <code>solver_uses_variable_names</code> <code>bool</code> <p>If <code>True</code>, the solver will use your custom variable names in its outputs (e.g. during <code>Model.write()</code>). This can be useful for debugging <code>.lp</code>, <code>.sol</code>, and <code>.ilp</code> files, but may worsen performance.</p> <code>False</code> <code>print_uses_variable_names</code> <code>bool</code> <p>If <code>True</code>, pyoframe will use your custom variables names when printing elements of the model to the console. This is useful for debugging, but may slightly worsen performance.</p> <code>True</code> <code>sense</code> <code>ObjSense | ObjSenseValue | None</code> <p>Either \"min\" or \"max\". Indicates whether it's a minimization or maximization problem. Typically, this parameter can be omitted (<code>None</code>) as it will automatically be set when the objective is set using <code>.minimize</code> or <code>.maximize</code>.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If <code>True</code>, logging messages will be printed every time a Variable or Constraint is added to the model. This is useful to discover performance bottlenecks. Logging can be further configured via the <code>logging</code> module by modifying the <code>pyoframe</code> logger.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.my_constraint = m.X &lt;= 10\n&gt;&gt;&gt; m\n&lt;Model vars=1 constrs=1 has_objective=False solver=gurobi&gt;\n</code></pre> <p>Use <code>solver_env</code> to, for example, connect to a Gurobi Compute Server:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\n...     \"gurobi\",\n...     solver_env=dict(ComputeServer=\"myserver\", ServerPassword=\"mypassword\"),\n... )\nTraceback (most recent call last):\n...\nRuntimeError: Could not resolve host: myserver (code 6, command POST http://myserver/api/v1/cluster/jobs)\n</code></pre> <p>Methods:</p> Name Description <code>compute_IIS</code> <p>Gurobi and COPT only: Computes the Irreducible Infeasible Set (IIS) of the model.</p> <code>constraints_size_info</code> <p>Returns a DataFrame with information about the memory usage of each constraint in the model.</p> <code>convert_to_fixed</code> <p>Gurobi only: Converts a mixed integer program into a continuous one by fixing all the non-continuous variables to their solution values.</p> <code>dispose</code> <p>Disposes of the model and cleans up the solver environment.</p> <code>optimize</code> <p>Optimizes the model using your selected solver (e.g. Gurobi, HiGHS).</p> <code>variables_size_info</code> <p>Returns a DataFrame with information about the memory usage of each variable in the model.</p> <code>write</code> <p>Outputs the model or the solution to a file (e.g. a <code>.lp</code>, <code>.sol</code>, <code>.mps</code>, or <code>.ilp</code> file).</p> <p>Attributes:</p> Name Type Description <code>attr</code> <code>Container</code> <p>An object that allows reading and writing model attributes.</p> <code>binary_variables</code> <code>Generator[Variable]</code> <p>Returns the model's binary variables.</p> <code>constraints</code> <code>list[Constraint]</code> <p>Returns the model's constraints.</p> <code>has_objective</code> <code>bool</code> <p>Returns whether the model's objective has been defined.</p> <code>integer_variables</code> <code>Generator[Variable]</code> <p>Returns the model's integer variables.</p> <code>maximize</code> <code>Objective</code> <p>Sets or gets the model's objective for maximization problems.</p> <code>minimize</code> <code>Objective</code> <p>Sets or gets the model's objective for minimization problems.</p> <code>name</code> <code>str | None</code> <code>objective</code> <code>Objective</code> <p>Returns the model's objective.</p> <code>params</code> <code>Container</code> <p>An object that allows reading and writing solver-specific parameters.</p> <code>poi</code> <p>The underlying PyOptInterface model used to interact with the solver.</p> <code>sense</code> <code>ObjSense | None</code> <code>solver_name</code> <code>str</code> <code>solver_uses_variable_names</code> <p>Whether to pass human-readable variable names to the solver.</p> <code>variables</code> <code>list[Variable]</code> <p>Returns a list of the model's variables.</p> Source code in <code>pyoframe/_model.py</code> <pre><code>def __init__(\n    self,\n    solver: SUPPORTED_SOLVER_TYPES | _Solver | None = None,\n    solver_env: dict[str, str] | None = None,\n    *,\n    name: str | None = None,\n    solver_uses_variable_names: bool = False,\n    print_uses_variable_names: bool = True,\n    sense: ObjSense | ObjSenseValue | None = None,\n    verbose: bool = False,\n):\n    self._poi, self.solver = Model._create_poi_model(solver, solver_env)\n    self.solver_name: str = self.solver.name\n    self._variables: list[Variable] = []\n    self._constraints: list[Constraint] = []\n    self.sense: ObjSense | None = ObjSense(sense) if sense is not None else None\n    self._objective: Objective | None = None\n    self._var_map = NamedVariableMapper() if print_uses_variable_names else None\n    self.name: str | None = name\n\n    self._params = Container(self._set_param, self._get_param)\n    self._attr = Container(self._set_attr, self._get_attr)\n    self._solver_uses_variable_names = solver_uses_variable_names\n\n    self._logger = None\n    self._last_log = None\n    if verbose:\n        import logging\n\n        self._logger = logging.getLogger(\"pyoframe\")\n        self._logger.addHandler(logging.NullHandler())\n        self._logger.setLevel(logging.DEBUG)\n\n        self._last_log = time.time()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.attr","title":"<code>attr: Container</code>","text":"<p>An object that allows reading and writing model attributes.</p> <p>Several model attributes are common across all solvers making it easy to switch between solvers (see supported attributes for Gurobi, HiGHS, Ipopt), and COPT.</p> <p>We additionally support all of Gurobi's attributes when using Gurobi.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable(lb=1, ub=1, vtype=\"integer\")\n&gt;&gt;&gt; m.attr.Silent = True  # Prevent solver output from being printed\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus\n&lt;TerminationStatusCode.OPTIMAL: 2&gt;\n</code></pre> <p>Some attributes, like <code>NumVars</code>, are solver-specific.</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"gurobi\")\n&gt;&gt;&gt; m.attr.NumConstrs\n0\n&gt;&gt;&gt; m = pf.Model(\"highs\")\n&gt;&gt;&gt; m.attr.NumConstrs\nTraceback (most recent call last):\n...\nKeyError: 'NumConstrs'\n</code></pre> See Also <p>Variable.attr for setting variable attributes and Constraint.attr for setting constraint attributes.</p>"},{"location":"reference/public/Model/#pyoframe.Model.binary_variables","title":"<code>binary_variables: Generator[Variable]</code>","text":"<p>Returns the model's binary variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.binary_variables))\n1\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.constraints","title":"<code>constraints: list[Constraint]</code>","text":"<p>Returns the model's constraints.</p>"},{"location":"reference/public/Model/#pyoframe.Model.has_objective","title":"<code>has_objective: bool</code>","text":"<p>Returns whether the model's objective has been defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.has_objective\nFalse\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.maximize = m.X\n&gt;&gt;&gt; m.has_objective\nTrue\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.integer_variables","title":"<code>integer_variables: Generator[Variable]</code>","text":"<p>Returns the model's integer variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.INTEGER)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.integer_variables))\n1\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.maximize","title":"<code>maximize: Objective</code>","text":"<p>Sets or gets the model's objective for maximization problems.</p>"},{"location":"reference/public/Model/#pyoframe.Model.minimize","title":"<code>minimize: Objective</code>","text":"<p>Sets or gets the model's objective for minimization problems.</p>"},{"location":"reference/public/Model/#pyoframe.Model.name","title":"<code>name: str | None = name</code>","text":""},{"location":"reference/public/Model/#pyoframe.Model.objective","title":"<code>objective: Objective</code>","text":"<p>Returns the model's objective.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the objective has not been defined.</p> See Also <p><code>Model.has_objective</code></p>"},{"location":"reference/public/Model/#pyoframe.Model.params","title":"<code>params: Container</code>","text":"<p>An object that allows reading and writing solver-specific parameters.</p> <p>See the list of available parameters for Gurobi, HiGHS, Ipopt, and COPT.</p> <p>Examples:</p> <p>For example, if you'd like to use Gurobi's barrier method, you can set the <code>Method</code> parameter:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"gurobi\")\n&gt;&gt;&gt; m.params.Method = 2\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.poi","title":"<code>poi</code>","text":"<p>The underlying PyOptInterface model used to interact with the solver.</p> <p>Modifying the underlying model directly is not recommended and may lead to unexpected behaviors.</p>"},{"location":"reference/public/Model/#pyoframe.Model.sense","title":"<code>sense: ObjSense | None = ObjSense(sense) if sense is not None else None</code>","text":""},{"location":"reference/public/Model/#pyoframe.Model.solver_name","title":"<code>solver_name: str = self.solver.name</code>","text":""},{"location":"reference/public/Model/#pyoframe.Model.solver_uses_variable_names","title":"<code>solver_uses_variable_names</code>","text":"<p>Whether to pass human-readable variable names to the solver.</p>"},{"location":"reference/public/Model/#pyoframe.Model.variables","title":"<code>variables: list[Variable]</code>","text":"<p>Returns a list of the model's variables.</p>"},{"location":"reference/public/Model/#pyoframe.Model.compute_IIS","title":"<code>compute_IIS()</code>","text":"<p>Gurobi and COPT only: Computes the Irreducible Infeasible Set (IIS) of the model.</p> <p>Gurobi and COPT only</p> <p>This method only works with the Gurobi and COPT solver. Open an issue if you'd like to see support for other solvers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"gurobi\")\n&gt;&gt;&gt; m.X = pf.Variable(lb=0, ub=2)\n&gt;&gt;&gt; m.Y = pf.Variable(lb=0, ub=2)\n&gt;&gt;&gt; m.bad_constraint = m.X &gt;= 3\n&gt;&gt;&gt; m.minimize = m.X + m.Y\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus\n&lt;TerminationStatusCode.INFEASIBLE: 3&gt;\n&gt;&gt;&gt; m.bad_constraint.attr.IIS\nTraceback (most recent call last):\n...\nRuntimeError: Unable to retrieve attribute 'IISConstr'\n&gt;&gt;&gt; m.compute_IIS()\n&gt;&gt;&gt; m.bad_constraint.attr.IIS\nTrue\n</code></pre> Source code in <code>pyoframe/_model.py</code> <pre><code>@for_solvers(\"gurobi\", \"copt\")\ndef compute_IIS(self):\n    \"\"\"Gurobi and COPT only: Computes the Irreducible Infeasible Set (IIS) of the model.\n\n    !!! warning \"Gurobi and COPT only\"\n        This method only works with the Gurobi and COPT solver. Open an issue if you'd like to see support for other solvers.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model(\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.Y = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.bad_constraint = m.X &gt;= 3\n        &gt;&gt;&gt; m.minimize = m.X + m.Y\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.attr.TerminationStatus\n        &lt;TerminationStatusCode.INFEASIBLE: 3&gt;\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        Traceback (most recent call last):\n        ...\n        RuntimeError: Unable to retrieve attribute 'IISConstr'\n        &gt;&gt;&gt; m.compute_IIS()\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        True\n    \"\"\"\n    self.poi.computeIIS()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.constraints_size_info","title":"<code>constraints_size_info(memory_unit: pl.SizeUnit = 'b') -&gt; pl.DataFrame</code>","text":"<p>Returns a DataFrame with information about the memory usage of each constraint in the model.</p> <p>Experimental</p> <p>This method is experimental and may change or be removed in future versions. We're interested in your feedback.</p> <p>Parameters:</p> Name Type Description Default <code>memory_unit</code> <code>SizeUnit</code> <p>The size of the memory unit to use for the memory usage information. See <code>polars.DataFrame.estimated_size</code>.</p> <code>'b'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.Y = pf.Variable(pf.Set(dim_x=range(100)))\n&gt;&gt;&gt; m.c1 = m.X.over(\"dim_x\") + m.Y &lt;= 10\n&gt;&gt;&gt; m.c2 = m.X + m.Y.sum() &lt;= 20\n&gt;&gt;&gt; m.constraints_size_info()\nshape: (3, 7)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 name  \u2506 num_constrain \u2506 num_constrai \u2506 num_non_zero \u2506 num_non_zero \u2506 pyoframe_mem \u2506 pyoframe_mem \u2502\n\u2502 ---   \u2506 ts            \u2506 nts_perc     \u2506 s            \u2506 s_perc       \u2506 ory_usage    \u2506 ory_usage_pe \u2502\n\u2502 str   \u2506 ---           \u2506 ---          \u2506 ---          \u2506 ---          \u2506 ---          \u2506 rc           \u2502\n\u2502       \u2506 i64           \u2506 str          \u2506 i64          \u2506 str          \u2506 i64          \u2506 ---          \u2502\n\u2502       \u2506               \u2506              \u2506              \u2506              \u2506              \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 c1    \u2506 100           \u2506 99.0%        \u2506 300          \u2506 74.6%        \u2506 7314         \u2506 85.6%        \u2502\n\u2502 c2    \u2506 1             \u2506 1.0%         \u2506 102          \u2506 25.4%        \u2506 1228         \u2506 14.4%        \u2502\n\u2502 TOTAL \u2506 101           \u2506 100.0%       \u2506 402          \u2506 100.0%       \u2506 8542         \u2506 100.0%       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_model.py</code> <pre><code>def constraints_size_info(self, memory_unit: pl.SizeUnit = \"b\") -&gt; pl.DataFrame:\n    \"\"\"Returns a DataFrame with information about the memory usage of each constraint in the model.\n\n    !!! warning \"Experimental\"\n        This method is experimental and may change or be removed in future versions. We're interested in your [feedback](https://github.com/Bravos-Power/pyoframe/issues).\n\n    Parameters:\n        memory_unit:\n            The size of the memory unit to use for the memory usage information.\n            See [`polars.DataFrame.estimated_size`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.estimated_size.html).\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable()\n        &gt;&gt;&gt; m.Y = pf.Variable(pf.Set(dim_x=range(100)))\n        &gt;&gt;&gt; m.c1 = m.X.over(\"dim_x\") + m.Y &lt;= 10\n        &gt;&gt;&gt; m.c2 = m.X + m.Y.sum() &lt;= 20\n        &gt;&gt;&gt; m.constraints_size_info()\n        shape: (3, 7)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 name  \u2506 num_constrain \u2506 num_constrai \u2506 num_non_zero \u2506 num_non_zero \u2506 pyoframe_mem \u2506 pyoframe_mem \u2502\n        \u2502 ---   \u2506 ts            \u2506 nts_perc     \u2506 s            \u2506 s_perc       \u2506 ory_usage    \u2506 ory_usage_pe \u2502\n        \u2502 str   \u2506 ---           \u2506 ---          \u2506 ---          \u2506 ---          \u2506 ---          \u2506 rc           \u2502\n        \u2502       \u2506 i64           \u2506 str          \u2506 i64          \u2506 str          \u2506 i64          \u2506 ---          \u2502\n        \u2502       \u2506               \u2506              \u2506              \u2506              \u2506              \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 c1    \u2506 100           \u2506 99.0%        \u2506 300          \u2506 74.6%        \u2506 7314         \u2506 85.6%        \u2502\n        \u2502 c2    \u2506 1             \u2506 1.0%         \u2506 102          \u2506 25.4%        \u2506 1228         \u2506 14.4%        \u2502\n        \u2502 TOTAL \u2506 101           \u2506 100.0%       \u2506 402          \u2506 100.0%       \u2506 8542         \u2506 100.0%       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    data = pl.DataFrame(\n        [\n            dict(\n                name=c.name,\n                n=len(c),\n                non_zeros=c.lhs.data.height,\n                mem=c.estimated_size(memory_unit),\n            )\n            for c in self.constraints\n        ]\n    ).sort(\"n\", descending=True)\n\n    total = data.sum().with_columns(name=pl.lit(\"TOTAL\"))\n    data = pl.concat([data, total])\n\n    def format(col: pl.Expr) -&gt; pl.Expr:\n        return (100 * col).round(1).cast(pl.String) + pl.lit(\"%\")\n\n    data = data.with_columns(\n        n_per=format(pl.col(\"n\") / total[\"n\"].item()),\n        non_zeros_per=format(pl.col(\"non_zeros\") / total[\"non_zeros\"].item()),\n        mem_per=format(pl.col(\"mem\") / total[\"mem\"].item()),\n    )\n\n    data = data.select(\n        \"name\", \"n\", \"n_per\", \"non_zeros\", \"non_zeros_per\", \"mem\", \"mem_per\"\n    )\n    data = data.rename(\n        {\n            \"n\": \"num_constraints\",\n            \"n_per\": \"num_constraints_perc\",\n            \"non_zeros\": \"num_non_zeros\",\n            \"non_zeros_per\": \"num_non_zeros_perc\",\n            \"mem\": \"pyoframe_memory_usage\",\n            \"mem_per\": \"pyoframe_memory_usage_perc\",\n        }\n    )\n\n    return pl.DataFrame(data)\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.convert_to_fixed","title":"<code>convert_to_fixed() -&gt; None</code>","text":"<p>Gurobi only: Converts a mixed integer program into a continuous one by fixing all the non-continuous variables to their solution values.</p> <p>Gurobi only</p> <p>This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"gurobi\")\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0)\n&gt;&gt;&gt; m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0)\n&gt;&gt;&gt; m.Z = pf.Variable(lb=0)\n&gt;&gt;&gt; m.my_constraint = m.X + m.Y + m.Z &lt;= 10\n&gt;&gt;&gt; m.maximize = 3 * m.X + 2 * m.Y + m.Z\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.X.solution, m.Y.solution, m.Z.solution\n(1, 9, 0.0)\n&gt;&gt;&gt; m.my_constraint.dual\nTraceback (most recent call last):\n...\nRuntimeError: Unable to retrieve attribute 'Pi'\n&gt;&gt;&gt; m.convert_to_fixed()\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.my_constraint.dual\n1.0\n</code></pre> <p>Only works for Gurobi:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"highs\")\n&gt;&gt;&gt; m.convert_to_fixed()\nTraceback (most recent call last):\n...\nNotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.\n</code></pre> Source code in <code>pyoframe/_model.py</code> <pre><code>@for_solvers(\"gurobi\")\ndef convert_to_fixed(self) -&gt; None:\n    \"\"\"Gurobi only: Converts a mixed integer program into a continuous one by fixing all the non-continuous variables to their solution values.\n\n    !!! warning \"Gurobi only\"\n        This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model(\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0)\n        &gt;&gt;&gt; m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0)\n        &gt;&gt;&gt; m.Z = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.my_constraint = m.X + m.Y + m.Z &lt;= 10\n        &gt;&gt;&gt; m.maximize = 3 * m.X + 2 * m.Y + m.Z\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.X.solution, m.Y.solution, m.Z.solution\n        (1, 9, 0.0)\n        &gt;&gt;&gt; m.my_constraint.dual\n        Traceback (most recent call last):\n        ...\n        RuntimeError: Unable to retrieve attribute 'Pi'\n        &gt;&gt;&gt; m.convert_to_fixed()\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.my_constraint.dual\n        1.0\n\n        Only works for Gurobi:\n\n        &gt;&gt;&gt; m = pf.Model(\"highs\")\n        &gt;&gt;&gt; m.convert_to_fixed()\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.\n    \"\"\"\n    self.poi._converttofixed()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.dispose","title":"<code>dispose()</code>","text":"<p>Disposes of the model and cleans up the solver environment.</p> <p>When using Gurobi compute server, this cleanup will ensure your run is not marked as 'ABORTED'.</p> <p>Note that once the model is disposed, it cannot be used anymore.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(ub=1)\n&gt;&gt;&gt; m.maximize = m.X\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.X.solution\n1.0\n&gt;&gt;&gt; m.dispose()\n</code></pre> Source code in <code>pyoframe/_model.py</code> <pre><code>def dispose(self):\n    \"\"\"Disposes of the model and cleans up the solver environment.\n\n    When using Gurobi compute server, this cleanup will\n    ensure your run is not marked as 'ABORTED'.\n\n    Note that once the model is disposed, it cannot be used anymore.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable(ub=1)\n        &gt;&gt;&gt; m.maximize = m.X\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.X.solution\n        1.0\n        &gt;&gt;&gt; m.dispose()\n    \"\"\"\n    env = None\n    if hasattr(self.poi, \"_env\"):\n        env = self.poi._env\n    self.poi.close()\n    if env is not None:\n        env.close()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.optimize","title":"<code>optimize()</code>","text":"<p>Optimizes the model using your selected solver (e.g. Gurobi, HiGHS).</p> Source code in <code>pyoframe/_model.py</code> <pre><code>def optimize(self):\n    \"\"\"Optimizes the model using your selected solver (e.g. Gurobi, HiGHS).\"\"\"\n    self.poi.optimize()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.variables_size_info","title":"<code>variables_size_info(memory_unit: pl.SizeUnit = 'b') -&gt; pl.DataFrame</code>","text":"<p>Returns a DataFrame with information about the memory usage of each variable in the model.</p> <p>Experimental</p> <p>This method is experimental and may change or be removed in future versions. We're interested in your [feedback](feedback.</p> <p>Parameters:</p> Name Type Description Default <code>memory_unit</code> <code>SizeUnit</code> <p>The size of the memory unit to use for the memory usage information. See <code>polars.DataFrame.estimated_size</code>.</p> <code>'b'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.Y = pf.Variable(pf.Set(dim_x=range(100)))\n&gt;&gt;&gt; m.variables_size_info()\nshape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 name  \u2506 num_variables \u2506 num_variables_perc \u2506 pyoframe_memory_usage \u2506 pyoframe_memory_usage_perc \u2502\n\u2502 ---   \u2506 ---           \u2506 ---                \u2506 ---                   \u2506 ---                        \u2502\n\u2502 str   \u2506 i64           \u2506 str                \u2506 i64                   \u2506 str                        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Y     \u2506 100           \u2506 99.0%              \u2506 1200                  \u2506 99.7%                      \u2502\n\u2502 X     \u2506 1             \u2506 1.0%               \u2506 4                     \u2506 0.3%                       \u2502\n\u2502 TOTAL \u2506 101           \u2506 100.0%             \u2506 1204                  \u2506 100.0%                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_model.py</code> <pre><code>def variables_size_info(self, memory_unit: pl.SizeUnit = \"b\") -&gt; pl.DataFrame:\n    \"\"\"Returns a DataFrame with information about the memory usage of each variable in the model.\n\n    !!! warning \"Experimental\"\n        This method is experimental and may change or be removed in future versions. We're interested in your [feedback]([feedback](https://github.com/Bravos-Power/pyoframe/issues).\n\n    Parameters:\n        memory_unit:\n            The size of the memory unit to use for the memory usage information.\n            See [`polars.DataFrame.estimated_size`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.estimated_size.html).\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable()\n        &gt;&gt;&gt; m.Y = pf.Variable(pf.Set(dim_x=range(100)))\n        &gt;&gt;&gt; m.variables_size_info()\n        shape: (3, 5)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 name  \u2506 num_variables \u2506 num_variables_perc \u2506 pyoframe_memory_usage \u2506 pyoframe_memory_usage_perc \u2502\n        \u2502 ---   \u2506 ---           \u2506 ---                \u2506 ---                   \u2506 ---                        \u2502\n        \u2502 str   \u2506 i64           \u2506 str                \u2506 i64                   \u2506 str                        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Y     \u2506 100           \u2506 99.0%              \u2506 1200                  \u2506 99.7%                      \u2502\n        \u2502 X     \u2506 1             \u2506 1.0%               \u2506 4                     \u2506 0.3%                       \u2502\n        \u2502 TOTAL \u2506 101           \u2506 100.0%             \u2506 1204                  \u2506 100.0%                     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    data = pl.DataFrame(\n        [\n            dict(name=v.name, n=len(v), mem=v.estimated_size(memory_unit))\n            for v in self.variables\n        ]\n    ).sort(\"n\", descending=True)\n\n    total = data.sum().with_columns(name=pl.lit(\"TOTAL\"))\n    data = pl.concat([data, total])\n\n    def format(expr: pl.Expr) -&gt; pl.Expr:\n        return (100 * expr).round(1).cast(pl.String) + pl.lit(\"%\")\n\n    data = data.with_columns(\n        n_per=format(pl.col(\"n\") / total[\"n\"].item()),\n        mem_per=format(pl.col(\"mem\") / total[\"mem\"].item()),\n    )\n\n    data = data.select(\"name\", \"n\", \"n_per\", \"mem\", \"mem_per\")\n    data = data.rename(\n        {\n            \"n\": \"num_variables\",\n            \"n_per\": \"num_variables_perc\",\n            \"mem\": \"pyoframe_memory_usage\",\n            \"mem_per\": \"pyoframe_memory_usage_perc\",\n        }\n    )\n\n    return pl.DataFrame(data)\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.write","title":"<code>write(file_path: Path | str, pretty: bool = False)</code>","text":"<p>Outputs the model or the solution to a file (e.g. a <code>.lp</code>, <code>.sol</code>, <code>.mps</code>, or <code>.ilp</code> file).</p> <p>These files can be useful for manually debugging a model. Consult your solver documentation to learn more.</p> <p>When creating your model, set <code>solver_uses_variable_names</code> to make the outputed file human-readable.</p> <pre><code>m = pf.Model(solver_uses_variable_names=True)\n</code></pre> <p>For Gurobi, <code>solver_uses_variable_names=True</code> is mandatory when using .write(). This may become mandatory for other solvers too without notice.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>The path to the file to write to.</p> required <code>pretty</code> <code>bool</code> <p>Only used when writing .sol files in HiGHS. If <code>True</code>, will use HiGH's pretty print columnar style which contains more information.</p> <code>False</code> Source code in <code>pyoframe/_model.py</code> <pre><code>def write(self, file_path: Path | str, pretty: bool = False):\n    \"\"\"Outputs the model or the solution to a file (e.g. a `.lp`, `.sol`, `.mps`, or `.ilp` file).\n\n    These files can be useful for manually debugging a model.\n    Consult your solver documentation to learn more.\n\n    When creating your model, set [`solver_uses_variable_names`][pyoframe.Model]\n    to make the outputed file human-readable.\n\n    ```python\n    m = pf.Model(solver_uses_variable_names=True)\n    ```\n\n    For Gurobi, `solver_uses_variable_names=True` is mandatory when using\n    .write(). This may become mandatory for other solvers too without notice.\n\n    Parameters:\n        file_path:\n            The path to the file to write to.\n        pretty:\n            Only used when writing .sol files in HiGHS. If `True`, will use HiGH's pretty print columnar style which contains more information.\n    \"\"\"\n    if not self.solver.supports_write:\n        raise NotImplementedError(f\"{self.solver.name} does not support .write()\")\n    if (\n        not self.solver_uses_variable_names\n        and self.solver.accelerate_with_repeat_names\n    ):\n        raise ValueError(\n            f\"{self.solver.name} requires solver_uses_variable_names=True to use .write()\"\n        )\n\n    file_path = Path(file_path)\n    file_path.parent.mkdir(parents=True, exist_ok=True)\n\n    kwargs = {}\n    if self.solver.name == \"highs\":\n        if self.solver_uses_variable_names:\n            self.params.write_solution_style = 1\n        kwargs[\"pretty\"] = pretty\n    self.poi.write(str(file_path), **kwargs)\n</code></pre>"},{"location":"reference/public/ObjSense/","title":"ObjSense","text":"<p>               Bases: <code>Enum</code></p> <p>Attributes:</p> Name Type Description <code>MAX</code> <code>MIN</code>"},{"location":"reference/public/ObjSense/#pyoframe.ObjSense.MAX","title":"<code>MAX = 'max'</code>","text":""},{"location":"reference/public/ObjSense/#pyoframe.ObjSense.MIN","title":"<code>MIN = 'min'</code>","text":""},{"location":"reference/public/Objective/","title":"Objective","text":"<p>               Bases: <code>Expression</code></p> <p>The objective for an optimization model.</p> <p>Examples:</p> <p>An <code>Objective</code> is automatically created when an <code>Expression</code> is assigned to <code>.minimize</code> or <code>.maximize</code></p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.A, m.B = pf.Variable(lb=0), pf.Variable(lb=0)\n&gt;&gt;&gt; m.con = m.A + m.B &lt;= 10\n&gt;&gt;&gt; m.maximize = 2 * m.B + 4\n&gt;&gt;&gt; m.maximize\n&lt;Objective (linear) terms=2&gt;\n2\u00a0B +4\n</code></pre> <p>The objective value can be retrieved with from the solver once the model is solved using <code>.value</code>.</p> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n24.0\n</code></pre> <p>Objectives support <code>+=</code> and <code>-=</code> operators.</p> <pre><code>&gt;&gt;&gt; m.maximize += 3 * m.A\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.A.solution, m.B.solution\n(10.0, 0.0)\n&gt;&gt;&gt; m.maximize -= 2 * m.A\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.A.solution, m.B.solution\n(0.0, 10.0)\n</code></pre> <p>Objectives cannot be created from dimensioned expressions since an objective must be a single expression.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.dimensioned_variable = pf.Variable(\n...     {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}\n... )\n&gt;&gt;&gt; m.maximize = m.dimensioned_variable\nTraceback (most recent call last):\n...\nValueError: Objective cannot be created from a dimensioned expression. Did you forget to use .sum()?\n</code></pre> <p>Objectives cannot be overwritten.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.A = pf.Variable(lb=0)\n&gt;&gt;&gt; m.maximize = 2 * m.A\n&gt;&gt;&gt; m.maximize = 3 * m.A\nTraceback (most recent call last):\n...\nValueError: An objective already exists. Use += or -= to modify it.\n</code></pre> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The value of the objective function (only available after solving the model).</p> Source code in <code>pyoframe/_objective.py</code> <pre><code>def __init__(self, expr: Operable, _constructive: bool = False) -&gt; None:\n    self._constructive = _constructive\n    if isinstance(expr, (int, float)):\n        expr = Expression.constant(expr)\n    else:\n        expr = expr.to_expr()  # TODO don't rely on monkey patch\n    super().__init__(expr.data, name=\"objective\")\n    self._model = expr._model\n    if self.dimensions is not None:\n        raise ValueError(\n            \"Objective cannot be created from a dimensioned expression. Did you forget to use .sum()?\"\n        )\n</code></pre>"},{"location":"reference/public/Objective/#pyoframe.Objective.value","title":"<code>value: float</code>","text":"<p>The value of the objective function (only available after solving the model).</p> <p>This value is obtained by directly querying the solver.</p>"},{"location":"reference/public/Param/","title":"Param","text":"<p>Creates a model parameter, i.e. an Expression that doesn't involve any variables.</p> <p>A Parameter can be created from a DataFrame, CSV file, Parquet file, data dictionary, or a Pandas Series.</p> <p><code>Param</code> is a function, not a class</p> <p>Technically, <code>Param(data)</code> is a function that returns an Expression, not a class. However, for consistency with other modeling frameworks, we provide it as a class-like function (i.e. an uppercase function).</p> <p>Smart naming</p> <p>If a Param is not given a name (i.e. if it is not assigned to a model: <code>m.my_name = Param(...)</code>), then its name is inferred from the name of the column in <code>data</code> that contains the parameter values. This makes debugging models with inline parameters easier.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame | DataFrame | Series | dict | str | Path</code> <p>The data to use for the parameter.</p> <p>If <code>data</code> is a polars or pandas <code>DataFrame</code>, the last column will be treated as the values of the parameter, and all other columns as labels.</p> <p>If <code>data</code> is a string or <code>Path</code>, it will be interpreted as a path to a CSV or Parquet file that will be read and used as a <code>DataFrame</code>. The file extension must be <code>.csv</code> or <code>.parquet</code>.</p> <p>If <code>data</code> is a <code>pandas.Series</code>, the index(es) will be treated as columns for labels and the series values as the parameter values.</p> <p>If <code>data</code> is of any other type (e.g. a dictionary), it will be used as if you had called <code>Param(pl.DataFrame(data))</code>.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>An Expression representing the parameter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.fixed_cost = pf.Param({\"plant\": [\"A\", \"B\"], \"cost\": [1000, 1500]})\n&gt;&gt;&gt; m.fixed_cost\n&lt;Expression (parameter) height=2 terms=2&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 plant \u2506 expression \u2502\n\u2502 (2)   \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A     \u2506 1000       \u2502\n\u2502 B     \u2506 1500       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Since <code>Param</code> simply returns an Expression, you can use it in building larger expressions as usual:</p> <pre><code>&gt;&gt;&gt; m.variable_cost = pf.Param(\n...     pl.DataFrame({\"plant\": [\"A\", \"B\"], \"cost\": [50, 60]})\n... )\n&gt;&gt;&gt; m.total_cost = m.fixed_cost + m.variable_cost\n&gt;&gt;&gt; m.total_cost\n&lt;Expression (parameter) height=2 terms=2&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 plant \u2506 expression \u2502\n\u2502 (2)   \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A     \u2506 1050       \u2502\n\u2502 B     \u2506 1560       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_param.py</code> <pre><code>def Param(\n    data: pl.DataFrame | pd.DataFrame | pd.Series | dict | str | Path,\n) -&gt; Expression:\n    \"\"\"Creates a model parameter, i.e. an [Expression][pyoframe.Expression] that doesn't involve any variables.\n\n    A Parameter can be created from a DataFrame, CSV file, Parquet file, data dictionary, or a Pandas Series.\n\n    !!! info \"`Param` is a function, not a class\"\n        Technically, `Param(data)` is a function that returns an [Expression][pyoframe.Expression], not a class.\n        However, for consistency with other modeling frameworks, we provide it as a class-like function (i.e. an uppercase function).\n\n    !!! tip \"Smart naming\"\n        If a Param is not given a name (i.e. if it is not assigned to a model: `m.my_name = Param(...)`),\n        then its [name][pyoframe._model_element.BaseBlock.name] is inferred from the name of the column in `data` that contains the parameter values.\n        This makes debugging models with inline parameters easier.\n\n    Args:\n        data: The data to use for the parameter.\n\n            If `data` is a polars or pandas `DataFrame`, the last column will be treated as the values of the parameter, and all other columns as labels.\n\n            If `data` is a string or `Path`, it will be interpreted as a path to a CSV or Parquet file that will be read and used as a `DataFrame`. The file extension must be `.csv` or `.parquet`.\n\n            If `data` is a `pandas.Series`, the index(es) will be treated as columns for labels and the series values as the parameter values.\n\n            If `data` is of any other type (e.g. a dictionary), it will be used as if you had called `Param(pl.DataFrame(data))`.\n\n    Returns:\n        An Expression representing the parameter.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.fixed_cost = pf.Param({\"plant\": [\"A\", \"B\"], \"cost\": [1000, 1500]})\n        &gt;&gt;&gt; m.fixed_cost\n        &lt;Expression (parameter) height=2 terms=2&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 plant \u2506 expression \u2502\n        \u2502 (2)   \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A     \u2506 1000       \u2502\n        \u2502 B     \u2506 1500       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        Since `Param` simply returns an Expression, you can use it in building larger expressions as usual:\n\n        &gt;&gt;&gt; m.variable_cost = pf.Param(\n        ...     pl.DataFrame({\"plant\": [\"A\", \"B\"], \"cost\": [50, 60]})\n        ... )\n        &gt;&gt;&gt; m.total_cost = m.fixed_cost + m.variable_cost\n        &gt;&gt;&gt; m.total_cost\n        &lt;Expression (parameter) height=2 terms=2&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 plant \u2506 expression \u2502\n        \u2502 (2)   \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A     \u2506 1050       \u2502\n        \u2502 B     \u2506 1560       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if isinstance(data, pd.Series):\n        data = data.to_frame().reset_index()\n    if isinstance(data, pd.DataFrame):\n        data = pl.from_pandas(data)\n\n    if isinstance(data, (str, Path)):\n        data = Path(data)\n        if data.suffix.lower() == \".csv\":\n            data = pl.read_csv(data)\n        elif data.suffix.lower() in {\".parquet\"}:\n            data = pl.read_parquet(data)\n        else:\n            raise NotImplementedError(\n                f\"Could not create parameter. Unsupported file format: {data.suffix}\"\n            )\n\n    if not isinstance(data, pl.DataFrame):\n        data = pl.DataFrame(data)\n\n    value_col = data.columns[-1]\n\n    return Expression(\n        data.rename({value_col: COEF_KEY})\n        .drop_nulls(COEF_KEY)\n        .with_columns(pl.lit(CONST_TERM).alias(VAR_KEY)),\n        name=value_col,\n    )\n</code></pre>"},{"location":"reference/public/PyoframeError/","title":"PyoframeError","text":"<p>               Bases: <code>Exception</code></p> <p>Class for all Pyoframe-specific errors, typically errors arising from improper arithmetic operations.</p>"},{"location":"reference/public/Set/","title":"Set","text":"<p>               Bases: <code>BaseOperableBlock</code></p> <p>A set which can then be used to index variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Set(x=range(2), y=range(3))\n&lt;Set 'unnamed' height=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2506 y   \u2502\n\u2502 (2) \u2506 (3) \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 0   \u2502\n\u2502 0   \u2506 1   \u2502\n\u2502 0   \u2506 2   \u2502\n\u2502 1   \u2506 0   \u2502\n\u2502 1   \u2506 1   \u2502\n\u2502 1   \u2506 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Methods:</p> Name Description <code>drop</code> <p>Returns a new Set with the given dimensions dropped.</p> <code>to_expr</code> <p>Converts the Set to an Expression equal to 1 for each index.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(self, *data: SetTypes | Iterable[SetTypes], **named_data):\n    data_list = list(data)\n    for name, set in named_data.items():\n        data_list.append({name: set})\n    df = self._parse_acceptable_sets(*data_list)\n    if not df.is_empty() and df.is_duplicated().any():\n        raise ValueError(\"Duplicate rows found in input data.\")\n    super().__init__(df, name=\"unnamed_set\")\n</code></pre>"},{"location":"reference/public/Set/#pyoframe.Set.drop","title":"<code>drop(*dims: str) -&gt; Set</code>","text":"<p>Returns a new Set with the given dimensions dropped.</p> <p>Only unique rows are kept in the resulting Set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xy = pf.Set(x=range(3), y=range(2))\n&gt;&gt;&gt; xy\n&lt;Set 'unnamed' height=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2506 y   \u2502\n\u2502 (3) \u2506 (2) \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 0   \u2502\n\u2502 0   \u2506 1   \u2502\n\u2502 1   \u2506 0   \u2502\n\u2502 1   \u2506 1   \u2502\n\u2502 2   \u2506 0   \u2502\n\u2502 2   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; x = xy.drop(\"y\")\n&gt;&gt;&gt; x\n&lt;Set 'unnamed_set.drop(\u2026)' height=3&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2502\n\u2502 (3) \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2502\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def drop(self, *dims: str) -&gt; Set:\n    \"\"\"Returns a new Set with the given dimensions dropped.\n\n    Only unique rows are kept in the resulting Set.\n\n    Examples:\n        &gt;&gt;&gt; xy = pf.Set(x=range(3), y=range(2))\n        &gt;&gt;&gt; xy\n        &lt;Set 'unnamed' height=6&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x   \u2506 y   \u2502\n        \u2502 (3) \u2506 (2) \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0   \u2506 0   \u2502\n        \u2502 0   \u2506 1   \u2502\n        \u2502 1   \u2506 0   \u2502\n        \u2502 1   \u2506 1   \u2502\n        \u2502 2   \u2506 0   \u2502\n        \u2502 2   \u2506 1   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; x = xy.drop(\"y\")\n        &gt;&gt;&gt; x\n        &lt;Set 'unnamed_set.drop(\u2026)' height=3&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x   \u2502\n        \u2502 (3) \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0   \u2502\n        \u2502 1   \u2502\n        \u2502 2   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if not dims:\n        raise ValueError(\"At least one dimension must be provided to drop.\")\n    return self._new(\n        self.data.drop(dims).unique(maintain_order=Config.maintain_order),\n        name=f\"{self.name}.drop(\u2026)\",\n    )\n</code></pre>"},{"location":"reference/public/Set/#pyoframe.Set.to_expr","title":"<code>to_expr() -&gt; Expression</code>","text":"<p>Converts the Set to an Expression equal to 1 for each index.</p> <p>Useful when multiplying a Set by an Expression.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    \"\"\"Converts the Set to an Expression equal to 1 for each index.\n\n    Useful when multiplying a Set by an Expression.\n    \"\"\"\n    return Expression(\n        self.data.with_columns(\n            pl.lit(1).alias(COEF_KEY), pl.lit(CONST_TERM).alias(VAR_KEY)\n        ),\n        name=self.name,\n    )\n</code></pre>"},{"location":"reference/public/VType/","title":"VType","text":"<p>               Bases: <code>Enum</code></p> <p>An Enum that can be used to specify the variable type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=VType.BINARY)\n</code></pre> <p>The enum's string values can also be used directly although this is prone to typos:</p> <pre><code>&gt;&gt;&gt; m.Y = pf.Variable(vtype=\"binary\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>BINARY</code> <p>Variables that must be either 0 or 1.</p> <code>CONTINUOUS</code> <p>Variables that can be any real value.</p> <code>INTEGER</code> <p>Variables that must be integer values.</p>"},{"location":"reference/public/VType/#pyoframe.VType.BINARY","title":"<code>BINARY = 'binary'</code>","text":"<p>Variables that must be either 0 or 1.</p>"},{"location":"reference/public/VType/#pyoframe.VType.CONTINUOUS","title":"<code>CONTINUOUS = 'continuous'</code>","text":"<p>Variables that can be any real value.</p>"},{"location":"reference/public/VType/#pyoframe.VType.INTEGER","title":"<code>INTEGER = 'integer'</code>","text":"<p>Variables that must be integer values.</p>"},{"location":"reference/public/Variable/","title":"Variable","text":"<p>               Bases: <code>BaseOperableBlock</code></p> <p>A decision variable for an optimization model.</p> <p>Tip</p> <p>If <code>lb</code> or <code>ub</code> are a dimensioned object (e.g. an Expression), they will automatically be broadcasted to match the variable's dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*indexing_sets</code> <code>SetTypes | Iterable[SetTypes]</code> <p>If no indexing_sets are provided, a single variable with no dimensions is created. Otherwise, a variable is created for each element in the Cartesian product of the indexing_sets (see Set for details on behaviour).</p> <code>()</code> <code>vtype</code> <code>VType | VTypeValue</code> <p>The type of the variable. Can be either a VType enum or a string. Default is VType.CONTINUOUS.</p> <code>CONTINUOUS</code> <code>lb</code> <code>Operable | None</code> <p>The lower bound for the variables.</p> <code>None</code> <code>ub</code> <code>Operable | None</code> <p>The upper bound for the variables.</p> <code>None</code> <code>equals</code> <code>Operable | None</code> <p>When specified, a variable is created for every label in <code>equals</code> and a constraint is added to make the variable equal to the provided expression. <code>indexing_sets</code> cannot be provided when using <code>equals</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; df = pd.DataFrame(\n...     {\"dim1\": [1, 1, 2, 2, 3, 3], \"dim2\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]}\n... )\n&gt;&gt;&gt; Variable(df)\n&lt;Variable 'unnamed' height=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2502\n\u2502 (3)  \u2506 (2)  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2502\n\u2502 1    \u2506 b    \u2502\n\u2502 2    \u2506 a    \u2502\n\u2502 2    \u2506 b    \u2502\n\u2502 3    \u2506 a    \u2502\n\u2502 3    \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Variables cannot be used until they're added to the model.</p> <pre><code>&gt;&gt;&gt; m.constraint = Variable(df) &lt;= 3\nTraceback (most recent call last):\n...\nValueError: Cannot use 'Variable' before it has been added to a model.\n</code></pre> <p>Instead, assign the variable to the model first:</p> <pre><code>&gt;&gt;&gt; m.v = Variable(df)\n&gt;&gt;&gt; m.constraint = m.v &lt;= 3\n</code></pre> <pre><code>&gt;&gt;&gt; m.v\n&lt;Variable 'v' height=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2506 variable \u2502\n\u2502 (3)  \u2506 (2)  \u2506          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2506 v[1,a]   \u2502\n\u2502 1    \u2506 b    \u2506 v[1,b]   \u2502\n\u2502 2    \u2506 a    \u2506 v[2,a]   \u2502\n\u2502 2    \u2506 b    \u2506 v[2,b]   \u2502\n\u2502 3    \u2506 a    \u2506 v[3,a]   \u2502\n\u2502 3    \u2506 b    \u2506 v[3,b]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; m.v2 = Variable(df[[\"dim1\"]])\nTraceback (most recent call last):\n...\nValueError: Duplicate rows found in input data.\n&gt;&gt;&gt; m.v3 = Variable(df[[\"dim1\"]].drop_duplicates())\n&gt;&gt;&gt; m.v3\n&lt;Variable 'v3' height=3&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 variable \u2502\n\u2502 (3)  \u2506          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 v3[1]    \u2502\n\u2502 2    \u2506 v3[2]    \u2502\n\u2502 3    \u2506 v3[3]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Methods:</p> Name Description <code>next</code> <p>Creates an expression where the variable at each label is the next variable in the specified dimension.</p> <code>to_expr</code> <p>Converts the Variable to an Expression.</p> <p>Attributes:</p> Name Type Description <code>attr</code> <code>Container</code> <p>Allows reading and writing variable attributes similarly to Model.attr.</p> <code>solution</code> <p>Retrieves a variable's optimal value after the model has been solved.</p> <code>vtype</code> <code>VType</code> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(\n    self,\n    *indexing_sets: SetTypes | Iterable[SetTypes],\n    lb: Operable | None = None,\n    ub: Operable | None = None,\n    vtype: VType | VTypeValue = VType.CONTINUOUS,\n    equals: Operable | None = None,\n):\n    if equals is not None:\n        if isinstance(equals, (float, int)):\n            if lb is not None:\n                raise ValueError(\"Cannot specify 'lb' when 'equals' is a constant.\")\n            if ub is not None:\n                raise ValueError(\"Cannot specify 'ub' when 'equals' is a constant.\")\n            lb = ub = equals\n            equals = None\n        else:\n            assert len(indexing_sets) == 0, (\n                \"Cannot specify both 'equals' and 'indexing_sets'\"\n            )\n            equals = equals.to_expr()  # TODO don't rely on monkey patch\n            indexing_sets = (equals,)\n\n    data = Set(*indexing_sets).data if len(indexing_sets) &gt; 0 else pl.DataFrame()\n    super().__init__(data)\n\n    self.vtype: VType = VType(vtype)\n    self._attr = Container(self._set_attribute, self._get_attribute)\n    self._equals: Expression | None = equals\n\n    if lb is not None and not isinstance(lb, (float, int)):\n        lb: Expression = lb.to_expr()  # TODO don't rely on monkey patch\n        if not self.dimensionless:\n            lb = lb.over(*self.dimensions)\n        self._lb_expr, self.lb = lb, None\n    else:\n        self._lb_expr, self.lb = None, lb\n    if ub is not None and not isinstance(ub, (float, int)):\n        ub = ub.to_expr()  # TODO don't rely on monkey patch\n        if not self.dimensionless:\n            ub = ub.over(*self.dimensions)  # pyright: ignore[reportOptionalIterable]\n        self._ub_expr, self.ub = ub, None\n    else:\n        self._ub_expr, self.ub = None, ub\n</code></pre>"},{"location":"reference/public/Variable/#pyoframe.Variable.attr","title":"<code>attr: Container</code>","text":"<p>Allows reading and writing variable attributes similarly to Model.attr.</p>"},{"location":"reference/public/Variable/#pyoframe.Variable.solution","title":"<code>solution</code>","text":"<p>Retrieves a variable's optimal value after the model has been solved.</p> <p>Return type is a DataFrame if the variable has dimensions, otherwise it is a single value. Binary and integer variables are returned as integers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.var_continuous = pf.Variable({\"dim1\": [1, 2, 3]}, lb=5, ub=5)\n&gt;&gt;&gt; m.var_integer = pf.Variable(\n...     {\"dim1\": [1, 2, 3]}, lb=4.5, ub=5.5, vtype=pf.VType.INTEGER\n... )\n&gt;&gt;&gt; m.var_dimensionless = pf.Variable(\n...     lb=4.5, ub=5.5, vtype=pf.VType.INTEGER\n... )\n&gt;&gt;&gt; m.var_continuous.solution\nTraceback (most recent call last):\n...\nRuntimeError: Failed to retrieve solution for variable. Are you sure the model has been solved?\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.var_continuous.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5.0      \u2502\n\u2502 2    \u2506 5.0      \u2502\n\u2502 3    \u2506 5.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.var_integer.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5        \u2502\n\u2502 2    \u2506 5        \u2502\n\u2502 3    \u2506 5        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.var_dimensionless.solution\n5\n</code></pre>"},{"location":"reference/public/Variable/#pyoframe.Variable.vtype","title":"<code>vtype: VType = VType(vtype)</code>","text":""},{"location":"reference/public/Variable/#pyoframe.Variable.next","title":"<code>next(dim: str, wrap_around: bool = False) -&gt; Expression</code>","text":"<p>Creates an expression where the variable at each label is the next variable in the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>str</code> <p>The dimension over which to shift the variable.</p> required <code>wrap_around</code> <code>bool</code> <p>If <code>True</code>, the last label in the dimension is connected to the first label.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n&gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; # Fails because the dimensions are not the same\n&gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot subtract the two expressions below because expression 1 has extra labels.\nExpression 1:       (bat_charge + bat_flow)\nExpression 2:       bat_charge.next(\u2026)\nExtra labels in expression 1:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 18:00 \u2506 Toronto \u2502\n\u2502 18:00 \u2506 Berlin  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nUse .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_extras() == m.bat_charge.next(\"time\")\n&lt;Constraint 'unnamed' (linear) height=6 terms=18&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 constraint                                                                     \u2502\n\u2502 (3)   \u2506 (2)     \u2506                                                                                \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00 \u2506 Toronto \u2506 bat_charge[00:00,Toronto] +\u00a0bat_flow[00:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[06:00,Toronto] =\u00a00                                                \u2502\n\u2502 00:00 \u2506 Berlin  \u2506 bat_charge[00:00,Berlin] +\u00a0bat_flow[00:00,Berlin] -\u00a0bat_charge[06:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 06:00 \u2506 Toronto \u2506 bat_charge[06:00,Toronto] +\u00a0bat_flow[06:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[12:00,Toronto] =\u00a00                                                \u2502\n\u2502 06:00 \u2506 Berlin  \u2506 bat_charge[06:00,Berlin] +\u00a0bat_flow[06:00,Berlin] -\u00a0bat_charge[12:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 12:00 \u2506 Toronto \u2506 bat_charge[12:00,Toronto] +\u00a0bat_flow[12:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[18:00,Toronto] =\u00a00                                                \u2502\n\u2502 12:00 \u2506 Berlin  \u2506 bat_charge[12:00,Berlin] +\u00a0bat_flow[12:00,Berlin] -\u00a0bat_charge[18:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\n...     \"time\", wrap_around=True\n... )\n&lt;Constraint 'unnamed' (linear) height=8 terms=24&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 constraint                                                                     \u2502\n\u2502 (4)   \u2506 (2)     \u2506                                                                                \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00 \u2506 Toronto \u2506 bat_charge[00:00,Toronto] +\u00a0bat_flow[00:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[06:00,Toronto] =\u00a00                                                \u2502\n\u2502 00:00 \u2506 Berlin  \u2506 bat_charge[00:00,Berlin] +\u00a0bat_flow[00:00,Berlin] -\u00a0bat_charge[06:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 06:00 \u2506 Toronto \u2506 bat_charge[06:00,Toronto] +\u00a0bat_flow[06:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[12:00,Toronto] =\u00a00                                                \u2502\n\u2502 06:00 \u2506 Berlin  \u2506 bat_charge[06:00,Berlin] +\u00a0bat_flow[06:00,Berlin] -\u00a0bat_charge[12:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 12:00 \u2506 Toronto \u2506 bat_charge[12:00,Toronto] +\u00a0bat_flow[12:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[18:00,Toronto] =\u00a00                                                \u2502\n\u2502 12:00 \u2506 Berlin  \u2506 bat_charge[12:00,Berlin] +\u00a0bat_flow[12:00,Berlin] -\u00a0bat_charge[18:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 18:00 \u2506 Toronto \u2506 bat_charge[18:00,Toronto] +\u00a0bat_flow[18:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[00:00,Toronto] =\u00a00                                                \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 bat_charge[18:00,Berlin] +\u00a0bat_flow[18:00,Berlin] -\u00a0bat_charge[00:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef next(self, dim: str, wrap_around: bool = False):\n    \"\"\"Creates an expression where the variable at each label is the next variable in the specified dimension.\n\n    Parameters:\n        dim:\n            The dimension over which to shift the variable.\n        wrap_around:\n            If `True`, the last label in the dimension is connected to the first label.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n        &gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; # Fails because the dimensions are not the same\n        &gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\n        Traceback (most recent call last):\n        ...\n        pyoframe._constants.PyoframeError: Cannot subtract the two expressions below because expression 1 has extra labels.\n        Expression 1:\t(bat_charge + bat_flow)\n        Expression 2:\tbat_charge.next(\u2026)\n        Extra labels in expression 1:\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 18:00 \u2506 Toronto \u2502\n        \u2502 18:00 \u2506 Berlin  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        Use .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n            https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_extras() == m.bat_charge.next(\"time\")\n        &lt;Constraint 'unnamed' (linear) height=6 terms=18&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 constraint                                                                     \u2502\n        \u2502 (3)   \u2506 (2)     \u2506                                                                                \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 00:00 \u2506 Toronto \u2506 bat_charge[00:00,Toronto] +\u00a0bat_flow[00:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[06:00,Toronto] =\u00a00                                                \u2502\n        \u2502 00:00 \u2506 Berlin  \u2506 bat_charge[00:00,Berlin] +\u00a0bat_flow[00:00,Berlin] -\u00a0bat_charge[06:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 06:00 \u2506 Toronto \u2506 bat_charge[06:00,Toronto] +\u00a0bat_flow[06:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[12:00,Toronto] =\u00a00                                                \u2502\n        \u2502 06:00 \u2506 Berlin  \u2506 bat_charge[06:00,Berlin] +\u00a0bat_flow[06:00,Berlin] -\u00a0bat_charge[12:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 12:00 \u2506 Toronto \u2506 bat_charge[12:00,Toronto] +\u00a0bat_flow[12:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[18:00,Toronto] =\u00a00                                                \u2502\n        \u2502 12:00 \u2506 Berlin  \u2506 bat_charge[12:00,Berlin] +\u00a0bat_flow[12:00,Berlin] -\u00a0bat_charge[18:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\n        ...     \"time\", wrap_around=True\n        ... )\n        &lt;Constraint 'unnamed' (linear) height=8 terms=24&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 constraint                                                                     \u2502\n        \u2502 (4)   \u2506 (2)     \u2506                                                                                \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 00:00 \u2506 Toronto \u2506 bat_charge[00:00,Toronto] +\u00a0bat_flow[00:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[06:00,Toronto] =\u00a00                                                \u2502\n        \u2502 00:00 \u2506 Berlin  \u2506 bat_charge[00:00,Berlin] +\u00a0bat_flow[00:00,Berlin] -\u00a0bat_charge[06:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 06:00 \u2506 Toronto \u2506 bat_charge[06:00,Toronto] +\u00a0bat_flow[06:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[12:00,Toronto] =\u00a00                                                \u2502\n        \u2502 06:00 \u2506 Berlin  \u2506 bat_charge[06:00,Berlin] +\u00a0bat_flow[06:00,Berlin] -\u00a0bat_charge[12:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 12:00 \u2506 Toronto \u2506 bat_charge[12:00,Toronto] +\u00a0bat_flow[12:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[18:00,Toronto] =\u00a00                                                \u2502\n        \u2502 12:00 \u2506 Berlin  \u2506 bat_charge[12:00,Berlin] +\u00a0bat_flow[12:00,Berlin] -\u00a0bat_charge[18:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 18:00 \u2506 Toronto \u2506 bat_charge[18:00,Toronto] +\u00a0bat_flow[18:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[00:00,Toronto] =\u00a00                                                \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 bat_charge[18:00,Berlin] +\u00a0bat_flow[18:00,Berlin] -\u00a0bat_charge[00:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    wrapped = (\n        self.data.select(dim)\n        .unique(maintain_order=Config.maintain_order)\n        .sort(by=dim)\n    )\n    wrapped = wrapped.with_columns(pl.col(dim).shift(-1).alias(\"__next\"))\n    if wrap_around:\n        wrapped = wrapped.with_columns(pl.col(\"__next\").fill_null(pl.first(dim)))\n    else:\n        wrapped = wrapped.drop_nulls(dim)\n\n    expr = self.to_expr()\n    data = expr.data.rename({dim: \"__prev\"})\n\n    data = data.join(\n        wrapped,\n        left_on=\"__prev\",\n        right_on=\"__next\",\n        # We use \"right\" instead of \"left\" to maintain consistency with the behavior without maintain_order\n        maintain_order=\"right\" if Config.maintain_order else None,\n    ).drop([\"__prev\", \"__next\"], strict=False)\n\n    return data\n</code></pre>"},{"location":"reference/public/Variable/#pyoframe.Variable.to_expr","title":"<code>to_expr() -&gt; Expression</code>","text":"<p>Converts the Variable to an Expression.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    \"\"\"Converts the Variable to an Expression.\"\"\"\n    self._assert_has_ids()\n    return self._new(self.data.drop(SOLUTION_KEY, strict=False), self.name)  # pyright: ignore[reportArgumentType], we know it's safe after _assert_has_ids()\n</code></pre>"},{"location":"reference/types/Operable/","title":"Operable","text":"<p>Any of the following objects: <code>int</code>, <code>float</code>, Variable, Expression, Set, polars or pandas DataFrame, or pandas Series.</p>"},{"location":"why-pyoframe/","title":"Why Pyoframe?","text":"<p>A growing community of users are choosing Pyoframe for its speed, memory efficiency, model readability, and ease-of-development!</p> <p>We are actively developing performance benchmarks against other libraries. Preliminary (unpublished) results indicate that Pyoframe is much faster!</p> <p>Kjartan has also kindly developed a notebook showcasing Pyoframe for its speed, memory efficiency and readability compared to GAMS, Gurobipy, and Linopy.</p>"}]}