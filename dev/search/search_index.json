{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyoframe: A loved alternative to GAMS, Pyomo, and Linopy","text":"<ul> <li>Builds linear, non-linear, quadratic, continuous and mixed-integer optimization problems.</li> <li>Seamlessly integrates with pandas thanks to its dataframe-centric design.</li> <li>Extremely fast and memory efficient (even for sparse problems) thanks to Polars, Rust, and Pyoptinterface.</li> <li>Clear Pythonic syntax for writing mathematical models.</li> <li>Supports Gurobi, HiGHS, Ipopt and COPT solvers.</li> <li>Continuously used in high-stakes production environments.</li> <li>100% open-source (MIT License).</li> </ul> <ul> <li> <p> Learn</p> <p>Install <code>pyoframe</code> and learn the library's basics.</p> <p> Get started</p> </li> <li> <p> Examples</p> <p>Jump right in with our annotated examples.</p> <p> Examples</p> </li> </ul> <ul> <li> <p> API Reference</p> <p>Your go-to reference for understanding our API.</p> <p> Reference</p> </li> <li> <p> Ask a question</p> <p>Ask questions and discuss on our forum.</p> <p> GitHub Discussions</p> </li> <li> <p> Report a bug</p> <p>Bugs and feature requests can be submitted on GitHub.</p> <p> GitHub Issues</p> </li> </ul>"},{"location":"contribute/","title":"Contribute","text":"<p>Contributions are more than welcome! Submit a pull request, or open an issue and I (Martin) will gladly answer your questions on how to contribute.</p>"},{"location":"contribute/#setup-a-development-environment","title":"Setup a development environment","text":"<ol> <li> <p>Clone this repository. <pre><code>git clone https://github.com/Bravos-Power/pyoframe\n</code></pre></p> </li> <li> <p>Install the dependencies.  <pre><code>pip install --editable .[dev,docs]\n</code></pre></p> </li> <li> <p>Install the pre-commit hooks.  <pre><code>pre-commit install\n</code></pre></p> </li> <li> <p>Run <code>pytest</code> to make sure everything is working. The only errors you should see are those related to a solver not being installed. If not, open an issue!</p> </li> </ol>"},{"location":"contribute/#writing-documentation","title":"Writing documentation","text":"<p>We use Material Docs for documentation with several plugins to enable features like automatically compiling the docstrings into the reference API. Please follow the Google docstring style and the Google style guide. Additionally, all Python code blocks in Markdown files are tested using Sybil. To properly setup the tests refer to this Sybil documentation.</p>"},{"location":"contribute/#helpful-commands","title":"Helpful commands","text":"<ul> <li><code>pytest</code>: Runs all the tests. If you'd like to generate coverage information just add the flag <code>--cov</code>.</li> <li><code>mkdocs serve</code>: Generates the documentation locally. Navigate to <code>http://127.0.0.1:8000/pyoframe/</code> to check it out.</li> <li><code>coverage html</code>: Generate a webpage to view the coverage information generated after having run <code>pytest --cov</code>.</li> <li><code>python -m tests.test_examples</code>: Regenerate the files in the <code>results</code> folder of an example (e.g. <code>tests/examples/sudoku/results/**</code>). You should only run this if the result files need to be regenerated, for example, if model variable names have changed.</li> <li><code>ruff check</code>: Ensures all the linter tests pass</li> <li><code>ruff format</code>: Ensures the code is properly formatted (this is run upon commit if you've installed the pre-commit hooks)</li> <li><code>doccmd --language=python --no-pad-file --command=\"ruff format\" docs/</code>: to format the code in the documentation.</li> <li><code>mike serve</code> to see a local version of the documentation with the version selector.</li> </ul>"},{"location":"contribute/#additional-tips","title":"Additional tips","text":"<p>For core developers:</p> <ul> <li>If you use <code>.unique</code>, <code>.join</code>, <code>.sort</code>, or <code>.group_by</code> on a Polars dataframe, make sure to set the <code>maintain_order</code> parameter appropriately (typically, <code>maintain_order=Config.maintain_order</code>).</li> </ul> <p>For repository maintainers:</p> <ul> <li>Our CI pipeline on Github Actions requires a Gurobi and COPT license to run. If the Gurobi license expires, generate a new one and copy the contents of the <code>guorbi.lic</code> file into the <code>GUROBI_WLS</code> Github secret (Settings -&gt; Secrets and variables -&gt; actions). Similarly, if the COPT license expires, request a new academic license (or email COPT sales for a free one) and copy the contents of both license files to the matching Github secrets.</li> </ul>"},{"location":"examples/","title":"List of Examples","text":"Example Description Diet problem A simple linear program about optimizing your diet. Production planning A simple linear program about optimizing a production line. Facility location A problem with quadratic constraints about placing facilities nearest to customers. Portfolio optimization A problem with a quadratic objective about minimizing risk in an investment portfolio."},{"location":"examples/diet/","title":"Diet problem","text":""},{"location":"examples/diet/#problem-statement","title":"Problem statement","text":"<p>Given a list of potential foods, their costs, and their availability (<code>foods.csv</code>), and a list of the nutrients (e.g., protein, fats, etc.) contained in each food (<code>foods_to_nutrients.csv</code>), how can you satisfy your dietary requirements (<code>nutrients.csv</code>) while minimizing total costs?</p>"},{"location":"examples/diet/#model","title":"Model","text":"<pre><code>import pandas as pd\n\nimport pyoframe as pf\n\n# Import data\nfood = pd.read_csv(\"foods.csv\")\nnutrients = pd.read_csv(\"nutrients.csv\")\nfood_nutrients = pd.read_csv(\"foods_to_nutrients.csv\")\n\n# Construct model\nm = pf.Model()\nm.Buy = pf.Variable(food[\"food\"], lb=0, ub=food[[\"food\", \"stock\"]])\n\nnutrient_intake = (m.Buy * food_nutrients).sum_by(\"category\")\nm.min_nutrients = (\n    nutrients[[\"category\", \"min\"]] &lt;= nutrient_intake.drop_extras()  # (1)!\n)\nm.max_nutrients = nutrient_intake.drop_extras() &lt;= nutrients[[\"category\", \"max\"]]\n\ntotal_cost = (m.Buy * food[[\"food\", \"cost\"]]).sum()\nm.minimize = total_cost\n\n# Solve model\nm.optimize()\n</code></pre> <ol> <li><code>.drop_extras()</code> ensures that if <code>min_nutrient</code> is <code>null</code> for certain foods, no constraint will be created for those foods. Learn more</li> </ol> <p>So the solution is...</p> <pre><code>&gt;&gt;&gt; total_cost.evaluate()\n12.060249999999998\n&gt;&gt;&gt; m.Buy.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food      \u2506 solution \u2502\n\u2502 ---       \u2506 ---      \u2502\n\u2502 str       \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 hamburger \u2506 0.555263 \u2502\n\u2502 chicken   \u2506 0.0      \u2502\n\u2502 hot_dog   \u2506 0.0      \u2502\n\u2502 fries     \u2506 0.0      \u2502\n\u2502 macaroni  \u2506 0.0      \u2502\n\u2502 pizza     \u2506 0.0      \u2502\n\u2502 salad     \u2506 0.0      \u2502\n\u2502 milk      \u2506 6.8      \u2502\n\u2502 ice_cream \u2506 2.909211 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Not a very balanced diet .</p>"},{"location":"examples/facility_location/","title":"Facility location Problem","text":""},{"location":"examples/facility_location/#problem-statement","title":"Problem statement","text":"<p>As described in this paper, the facility location problem seeks to find the optimal <code>(x,y)</code> location for a set of <code>F</code> facilities such that the maximum distance between any customer and its nearest facility is minimized. Customers are spread out evenly on a <code>G</code>-by-<code>G</code> grid.</p>"},{"location":"examples/facility_location/#model","title":"Model","text":"<pre><code>import pandas as pd\n\nimport pyoframe as pf\n\nG = 4\nF = 3\n\n# Construct model\nmodel = pf.Model()\n\n# Define sets\nmodel.facilities = pf.Set(f=range(F))\nmodel.x_axis = pf.Set(x=range(G))\nmodel.y_axis = pf.Set(y=range(G))\nmodel.axis = pf.Set(axis=[\"x\", \"y\"])\nmodel.customers = model.x_axis * model.y_axis  # (1)!\n\n\nmodel.facility_position = pf.Variable(model.facilities, model.axis, lb=0, ub=1)\nmodel.customer_position_x = pd.DataFrame(\n    {\"x\": range(G), \"x_pos\": [step / (G - 1) for step in range(G)]}\n).to_expr()\nmodel.customer_position_y = pd.DataFrame(\n    {\"y\": range(G), \"y_pos\": [step / (G - 1) for step in range(G)]}\n).to_expr()\n\nmodel.max_distance = pf.Variable(lb=0)\n\nmodel.is_closest = pf.Variable(model.customers, model.facilities, vtype=\"binary\")\nmodel.con_only_one_closest = model.is_closest.sum(\"f\") == 1\n\nmodel.dist_x = pf.Variable(model.x_axis, model.facilities)\nmodel.dist_y = pf.Variable(model.y_axis, model.facilities)\nmodel.con_dist_x = model.dist_x == model.customer_position_x.over(\n    \"f\"\n) - model.facility_position.pick(axis=\"x\").over(\"x\")\nmodel.con_dist_y = model.dist_y == model.customer_position_y.over(\n    \"f\"\n) - model.facility_position.pick(axis=\"y\").over(\"y\")\nmodel.dist = pf.Variable(model.x_axis, model.y_axis, model.facilities, lb=0)\nmodel.con_dist = model.dist**2 == (model.dist_x**2).over(\"y\") + (model.dist_y**2).over(\n    \"x\"\n)\n\nM = 2 * 1.414\nmodel.con_max_distance = model.max_distance.over(\"x\", \"y\", \"f\") &gt;= model.dist - M * (\n    1 - model.is_closest\n)\n\nmodel.minimize = model.max_distance\n\n# Solve model\nmodel.optimize()\n</code></pre> <ol> <li>Multiplying Sets returns their cartesian product.</li> </ol> <p>So what's the maximum distance from a customer to its nearest facility?</p> <pre><code>&gt;&gt;&gt; model.objective.value\n0.5\n</code></pre>"},{"location":"examples/portfolio_optimization/","title":"Portfolio optimization","text":""},{"location":"examples/portfolio_optimization/#problem-statement","title":"Problem statement","text":"<p>Given a list of assets, their covariance, and some portfolio parameters, select the portfolio weights that minimize risk (i.e. variance) while achieving a target return.</p>"},{"location":"examples/portfolio_optimization/#solution","title":"Solution","text":"<pre><code>import pandas as pd\nimport pyoframe as pf\n\n# Read input data\nassets = pd.read_csv(\"assets.csv\").set_index(\"asset\")\ncovariance = pd.read_csv(\"covariance.csv\").set_index([\"asset_i\", \"asset_j\"])\nparams = pd.read_csv(\"portfolio_params.csv\").set_index(\"param\")[\"value\"]\n\nm = pf.Model()\n\n# Decision variables: portfolio weights\nm.weight = pf.Variable(assets.index, lb=0, ub=params.loc[\"max_weight\"])\n\n# Constraint: weights must sum to 1\nm.con_weights_sum = m.weight.sum() == 1\n\n# Constraint: minimum expected return\nm.con_min_return = (m.weight * assets[\"expected_return\"]).sum() &gt;= params.loc[\n    \"min_return\"\n]\n\n# Objective: minimize portfolio variance (quadratic)\n# Variance = sum over i,j of weight_i * cov_ij * weight_j\n# We use 'rename' to make the dimensions match properly\nm.minimize = (\n    m.weight.rename({\"asset\": \"asset_i\"})\n    * covariance[\"covariance\"]\n    * m.weight.rename({\"asset\": \"asset_j\"})\n).sum()\n\nm.optimize()\n</code></pre> <p>And the result should be: <pre><code>&gt;&gt;&gt; m.weight.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 asset \u2506 solution \u2502\n\u2502 ---   \u2506 ---      \u2502\n\u2502 str   \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A     \u2506 0.36067  \u2502\n\u2502 B     \u2506 0.147212 \u2502\n\u2502 C     \u2506 0.209338 \u2502\n\u2502 D     \u2506 0.145308 \u2502\n\u2502 E     \u2506 0.137472 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.objective.value\n0.0195\n</code></pre></p>"},{"location":"examples/production/","title":"Production planning","text":""},{"location":"examples/production/#problem-statement","title":"Problem statement","text":"<p>This classical problem (Eiselt and Sandblom, p. 20) seeks to determine which products should be manufactured (and in what quantities) given that:</p> <ol> <li> <p>Each product must go through all the machines.</p> </li> <li> <p>Every machine takes a different amount of time to process every product (<code>processing_times.csv</code>).</p> </li> <li> <p>Machines have a maximum lifetime before needing maintenance (<code>machines_availability.csv</code>).</p> </li> <li> <p>Each product yields a different amount of profit (<code>products_profit.csv</code>).</p> </li> </ol>"},{"location":"examples/production/#model","title":"Model","text":"<pre><code>import pandas as pd\n\nimport pyoframe as pf\n\n\nprocessing_times = pd.read_csv(\"processing_times.csv\")\nmachines_availability = pd.read_csv(\"machines_availability.csv\")\nproducts_profit = pd.read_csv(\"products_profit.csv\")\n\nm = pf.Model()\nm.Production = pf.Variable(products_profit[\"products\"], lb=0)\n\nmachine_usage = m.Production * processing_times\nm.machine_capacity = machine_usage.sum_by(\"machines\") &lt;= machines_availability\n\nm.maximize = (products_profit * m.Production).sum()\n\nm.optimize()\n</code></pre> <pre><code>&gt;&gt;&gt; m.Production.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 products \u2506 solution \u2502\n\u2502 ---      \u2506 ---      \u2502\n\u2502 i64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1        \u2506 20.0     \u2502\n\u2502 2        \u2506 0.0      \u2502\n\u2502 3        \u2506 120.0    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/advanced-concepts/datastructure/","title":"Pyoframe's datastructure","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>So how does Pyoframe really work? Pyoframe uses dataframe operations to build your model's linear expressions. Here's what's happening under the hood.</p>"},{"location":"learn/advanced-concepts/internals/","title":"Internal details","text":"<p>Pyoframe's inner workings involve a few tricks that you should be aware of if you wish to modify Pyoframe's internal code.</p>"},{"location":"learn/advanced-concepts/internals/#the-zero-variable","title":"The zero variable","text":"<p>Whenever a Model is instantiated, Pyoframe immediately creates a variable whose value is fixed to <code>1</code> and has a variable id of <code>0</code> \u2014 the Zero Variable. This allows Pyoframe to represent constant terms in mathematical expressions as  multiples of the Zero Variable. For example, the expression <code>3 * var_8 + 5</code> is represented as <code>3 * var_8 + 5 * var_0</code>. This eliminates the need to separately track constant terms and also simplifies the handling of quadratics.</p>"},{"location":"learn/advanced-concepts/internals/#quadratics","title":"Quadratics","text":"<p>Internally, Expression is used to represent both linear and quadratic mathematical expressions. When a quadratic expression is formed, column <code>__quadratic_variable_id</code> is added to Expression.data. If an expression's quadratic terms happen to cancel out (e.g. <code>(ab + c) - ab</code>), this column is automatically removed.</p> <p>Column <code>__quadratic_variable_id</code> records the ID of the second variable in a quadratic term (the <code>b</code> in <code>3ab</code>). For linear terms, which have no second variable, this column contains the Zero Variable. Quadratic terms are always stored such that the first term's variable ID (in column <code>__variable_id</code>) is greater or equal to the second term's variable id (in column <code>__quadratic_variable_id</code>). For example, <code>var_7 * var_8</code> would be rearranged and stored as <code>var_8 * var_7</code>. This helps simplify expressions and provides a useful guarantee: If the variable in the first column (<code>__variable_id</code>) is the Zero Variable (<code>var_0</code>) we know the variable in the second column must also be the Zero Variable and, thus, the term must be a constant.</p>"},{"location":"learn/advanced-concepts/performance/","title":"Performance tips","text":"<p>Pyoframe is already one of the fastest and most memory-efficient libraries for formulating optimization models. However, if you'd like to squeeze out every bit of performance, here are some additional tips.</p>"},{"location":"learn/advanced-concepts/performance/#use-polars-instead-of-pandas","title":"Use polars instead of pandas","text":"<p>Polars is much faster than Pandas. Moreover, if you use Pandas, there will be a (very small) overhead because Pyoframe converts all DataFrames to Polars prior to computations.</p>"},{"location":"learn/advanced-concepts/performance/#use-integer-labels","title":"Use integer labels","text":"<p>Pyoframe works with any label data type (e.g. string labels, date labels, etc.), but integer labels are fastest and most memory efficient.</p>"},{"location":"learn/advanced-concepts/performance/#disable-maintain_order","title":"Disable <code>maintain_order</code>","text":"<p>By default, Pyoframe ensures that the order of variables, constraints, and mathematical terms is maintained across runs to ensure that your results are reproducible down to the very last decimal place. However, if you're not bothered by miniscule variations in your results due to numerical errors accumulating differently for different orderings, you should disable <code>maintain_order</code>:</p> <pre><code>pf.Config.maintain_order = False\n</code></pre>"},{"location":"learn/advanced-concepts/performance/#disable-checks-for-extra-values","title":"Disable checks for extra values","text":"<p>Disabling checks for extra values means that, instead of raising extra value exceptions, pyoframe will process sums with extra values as if <code>keep_extras</code> had been applied. While this may improve performance, it will silence potentially important errors meant to help you build your model. If you'd like to disable checks for extra values, we recommend you do so only after thoroughly testing your model and ensuring that all potential extra value exceptions have been handled.</p> <p>The following code disables checks for extra values:</p> <pre><code>pf.Config.disable_extras_checks = True\n</code></pre>"},{"location":"learn/advanced-concepts/quadratics/","title":"Quadratic expressions","text":"<p>Quadratic expressions work as you'd expect. Simply multiply two linear expression together (or square an expression with <code>**2</code>) and you'll get a quadratic. The quadratic can then be used in constraints or the objective.</p>"},{"location":"learn/advanced-concepts/quadratics/#example-1-maximize-area-of-box","title":"Example 1: Maximize area of box","text":"<p>Here's a short example that shows that a square maximizes the area of any box with a fixed perimeter.</p> <pre><code>import pyoframe as pf\n\nmodel = pf.Model()\nmodel.w = pf.Variable(lb=0)\nmodel.h = pf.Variable(lb=0)\nmodel.limit_perimter = 2 * (model.w + model.h) &lt;= 20\nmodel.maximize = model.w * model.h\nmodel.optimize()\nprint(f\"It's a square: {model.w.solution == model.h.solution}\")\nprint(f\"With area: {model.objective.value}\")\n\n# Outputs:\n# It's a square: True\n# With area: 25.0\n</code></pre>"},{"location":"learn/advanced-concepts/quadratics/#example-2-facility-location-problem","title":"Example 2: Facility location problem","text":"<p>See examples/facility_location.</p>"},{"location":"learn/advanced-concepts/troubleshooting/","title":"Troubleshooting","text":"<p>Here are some potential errors and how to resolve them.</p>"},{"location":"learn/advanced-concepts/troubleshooting/#datatypes-of-join-keys-dont-match","title":"<code>datatypes of join keys don't match</code>","text":"<p>Often, this error indicates that two columns in your input dataframes, although representing the same dimension, have different datatypes (e.g. 16bit integer and 64bit integer). This is not allowed and you should ensure that for the same dimensions, datatypes are identical.</p>"},{"location":"learn/concepts/addition/","title":"Addition and its quirks","text":"<p>In Pyoframe, <code>Expression</code> objects can be added using the <code>+</code> operator, as you might expect.</p> <p>However, sometimes an addition is ambiguous or indicative of a potential mistake in your model. In these situations, Pyoframe forces you to use addition modifiers to specify exactly how you'd like the addition to be performed. This safety feature helps prevent and quickly fix mistakes in your model.</p> <p>There are three common addition modifiers in Pyoframe: <code>.over(\u2026)</code>, <code>.keep_extras()</code>, and <code>.drop_extras()</code>.</p> <p>Before delving into these addition modifiers, please note that these addition rules also apply to subtraction as well as the <code>&lt;=</code> and <code>&gt;=</code> operators used to create constraints. This is because subtraction is actually computed as an addition (<code>a - b</code> is computed as <code>a + (-b)</code>). Similarly, creating a constraint with the <code>&lt;=</code> or <code>&gt;=</code> operators involves combining the left and right hand sides using addition (<code>a &lt;= b</code> becomes <code>a + (-b) &lt;= 0</code>). So, although I may only mention addition from now on, please remember that this page also applies to subtraction and to constraint creation.</p> <p>The rest of the page is organized as follows:</p> <ol> <li> <p>The <code>.over(\u2026)</code> addition modifier</p> </li> <li> <p>The <code>.keep_extras()</code> and <code>.drop_extras()</code> addition modifiers</p> </li> <li> <p>Important note on the order of operations of addition modifiers</p> </li> </ol>"},{"location":"learn/concepts/addition/#adding-expressions-with-differing-dimensions-using-over","title":"Adding expressions with differing dimensions using <code>.over(\u2026)</code>","text":"<p>To help catch mistakes, adding expressions with differing dimensions is disallowed by default. <code>.over(\u2026)</code> overrides this default and indicates that an addition should be performed by \"broadcasting\" the differing dimensions.</p> <p>The following examples help illustrate when <code>.over(\u2026)</code> should and shouldn't be used.</p>"},{"location":"learn/concepts/addition/#example-1-catching-a-mistake","title":"Example 1: Catching a mistake","text":"<p>Say you're developing an optimization model to study aviation emissions. You'd like to express the sum of in-flight emissions and on-the-ground (taxiing) emissions, for each flight, but when you try to add both <code>Expression</code> objects, you get an error:</p> <pre><code>&gt;&gt;&gt; model.flight_emissions = model.air_emissions + model.ground_emissions\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot add the two expressions below because their\n  dimensions are different (['flight_no'] != ['flight_number']).\nExpression 1:  air_emissions\nExpression 2:  ground_emissions\nIf this is intentional, use .over(\u2026) to broadcast. Learn more at\n  https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition/#adding-expressions-with-differing-dimensions-using-over\n</code></pre> <p>Do you understand what happened? The error informs us that <code>model.air_emissions</code> has dimension <code>flight_no</code>, but <code>model.ground_emissions</code> has dimension <code>flight_number</code>. Oops, the two datasets use slightly different spellings! You can use <code>.rename(\u2026)</code> to correct for the <code>Expression</code> objects having differing dimension names.</p> <pre><code>&gt;&gt;&gt; model.flight_emissions = model.air_emissions + model.ground_emissions.rename({\"flight_number\": \"flight_no\"})\n</code></pre> <p>Benign mistakes like these are relatively common and Pyoframe's error messages help you detect them early. Now, let's examine a case where <code>.over(\u2026)</code> is needed.</p>"},{"location":"learn/concepts/addition/#example-2-broadcasting-with-over","title":"Example 2: Broadcasting with <code>.over(\u2026)</code>","text":"<p>Say, you'd like to see what happens if, instead of minimizing total emissions, you were to minimize the emissions of the most emitting flight. Mathematically, this is equivalent to minimizing variable <code>E_max</code> where <code>E_max</code> is constrained to be greater or equal to the emissions of every flight.</p> <p>You try to express this constraint in Pyoframe, but get an error:</p> <pre><code>&gt;&gt;&gt; model.E_max = pf.Variable()\n&gt;&gt;&gt; model.minimize = model.E_max\n&gt;&gt;&gt; model.emission_constraint = model.E_max &gt;= model.flight_emissions\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot subtract the two expressions below because their\n    dimensions are different ([] != ['flight_no']).\nExpression 1:  E_max\nExpression 2:  flight_emissions\nIf this is intentional, use .over(\u2026) to broadcast. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition/#adding-expressions-with-differing-dimensions-using-over\n</code></pre> <p>The error indicates that <code>E_max</code> has no dimensions but <code>flight_emissions</code> has dimensions <code>flight_no</code>. The error is raised because, by default, combining terms with differing dimensions is not allowed (as explained in example 1).</p> <p>What we'd like to do is effectively 'copy' (aka. 'broadcast') <code>E_max</code> over every flight number. <code>E_max.over(\"flight_no\")</code> does just this:</p> <pre><code>&gt;&gt;&gt; model.E_max.over(\"flight_no\")\n&lt;Expression terms=1 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2506 expression \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 *         \u2506 E_max      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Notice how applying <code>.over(\"flight_no\")</code> added a dimension <code>flight_no</code> with value <code>*</code>. The asterix (<code>*</code>) indicates that <code>flight_no</code> will take the shape of whichever expression <code>E_max</code> is later combined with. Since <code>E_max</code> is being combined with <code>flight_emissions</code>, <code>*</code> will be replaced with an entry for every flight number in <code>flight_emissions</code>. Now creating our constraint works properly:</p> <pre><code>&gt;&gt;&gt; model.emission_constraint = model.E_max.over(\"flight_no\") &gt;= model.flight_emissions\n&gt;&gt;&gt; model.emission_constraint\n&lt;Constraint 'emission_constraint' height=2 terms=6 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2506 constraint                    \u2502\n\u2502 (2)       \u2506                               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A4543     \u2506 E_max -1.4\u00a0Fly[A4543] &gt;=\u00a00.02 \u2502\n\u2502 K937      \u2506 E_max -2.4\u00a0Fly[K937] &gt;=\u00a00.05  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/concepts/addition/#handling-extra-labels-with-keep_extras-and-drop_extras","title":"Handling 'extra' labels with <code>.keep_extras()</code> and <code>.drop_extras()</code>","text":"<p>Addition is performed by pairing the labels in the left <code>Expression</code> with those in the right <code>Expression</code>. But, what happens when the left and right labels differ?</p> <p>If one of the two expressions in an addition has extras labels not present in the other, <code>.keep_extras()</code> or <code>.drop_extras()</code> must be used to indicate how the extra labels should be handled.</p>"},{"location":"learn/concepts/addition/#example-3-deciding-how-to-handle-extra-labels","title":"Example 3: Deciding how to handle extra labels","text":"<p>Consider again example 1 where we added air emissions and ground emissions. Let's say that you fixed the error in example 1, but when you try the addition again you get the following error:</p> <pre><code>&gt;&gt;&gt; model.air_emissions + model.ground_emissions\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot add the two expressions below because expression 1 has extra labels.\nExpression 1:       air_emissions\nExpression 2:       ground_emissions\nExtra labels in expression 1:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 D2082     \u2502\n\u2502 D8432     \u2502\n\u2502 D1206     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nUse .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n</code></pre> <p>Do you understand what happened? The error explains that <code>air_emissions</code> contains flight numbers that are not present in <code>ground_emissions</code> (specifically flight numbers <code>D2082</code>, <code>D8432</code>, and <code>D1206</code>). Your ground emissions dataset is missing some flights!</p> <p>Pyoframe raised an error because it is unclear how you'd like the addition to be performed. In fact, you have three options:</p> <ol> <li>Decide to discard all flights with missing ground data (<code>model.air_emissions.drop_extras()</code>).</li> <li>Decide to keep all flights, assuming <code>0</code> ground emissions when the data is missing (<code>model.air_emissions.keep_extras()</code>).</li> <li>Go back to your data processing and fix the root cause of the missing data.</li> </ol> <p>After investigating, you realize that the data is missing because the ground emissions for those flights were negligible. As such, you decide to use <code>.keep_extras()</code> (option 2), effectively setting ground emissions to <code>0</code> whenever the data is missing.</p> <p>Let's try again!</p> <pre><code>&gt;&gt;&gt; model.air_emissions.keep_extras() + model.ground_emissions\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot add the two expressions below because expression 2 has extra labels.\nExpression 1:   air_emissions.keep_extras()\nExpression 2:   ground_emissions\nExtra labels in expression 2:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 B3420     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nUse .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n</code></pre> <p>Argh, another error! Do you understand what happened? This time <code>ground_emissions</code> has extra labels: flight <code>B3420</code> is present in <code>ground_emissions</code> but not <code>air_emissions</code>. Again, Pyoframe raised an error because it is unclear what should be done:</p> <ol> <li>Discard flight <code>B3420</code> because the air emissions data is missing.</li> <li>Keep flight <code>B3420</code>, assuming the air emissions data is <code>0</code>.</li> <li>Go back to your data processing and fix the root cause of the missing air emissions data.</li> </ol> <p>Option 2 hardly seems reasonable this time considering that air emissions make up the majority of a flight's emissions. You end up deciding to discard the flight entirely (option 1) using <code>.drop_extras()</code>. Now, the addition works perfectly!</p> <pre><code>&gt;&gt;&gt; model.air_emissions.keep_extras() + model.ground_emissions.drop_extras()\n&lt;Expression height=5 terms=5 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 flight_no \u2506 expression \u2502\n\u2502 (5)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A4543     \u2506 1.42       \u2502\n\u2502 K937      \u2506 2.45       \u2502\n\u2502 D2082     \u2506 4          \u2502\n\u2502 D8432     \u2506 7.6        \u2502\n\u2502 D1206     \u2506 4          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/concepts/addition/#order-of-operations-for-addition-modifiers","title":"Order of operations for addition modifiers","text":"<p>When an operation creates a new Expression, any previously applied addition modifiers are discarded to prevent unexpected behaviors. As such, addition modifiers only work if they're applied right before an addition. For example, <code>a.drop_extras().sum(\"time\") + b</code> won't work but <code>a.sum(\"time\").drop_extras() + b</code> will.</p> <p>There are two exceptions to this rule:</p> <ol> <li> <p>Negation. Negation preserves addition modifiers. If it weren't for this exception, <code>-my_obj.drop_extras()</code> wouldn't work as expected; you would have to write <code>(-my_obj).drop_extras()</code> which is unintuitive!</p> </li> <li> <p>Addition/subtraction. A <code>.keep_extras()</code> or <code>.drop_extras()</code> in the left and/or right side of an addition or subtraction is preserved in the result because this allows you to write     <pre><code>a.keep_extras() + b.keep_extras() + c.keep_extras()\n</code></pre>     instead of the annoyingly verbose,     <pre><code>(a.keep_extras() + b.keep_extras()).keep_extras() + c.keep_extras()\n</code></pre>     (If the left and right sides have conflicting addition modifiers, e.g., <code>a.keep_extras() + b.drop_extras()</code>, no addition modifiers are preserved. Also, if you'd like an addition or subtraction not to preserve addition modifiers, you can force the result back to the default of raising errors whenever there are extra labels by using <code>.raise_extras()</code>.)</p> </li> </ol>"},{"location":"learn/concepts/building-blocks/","title":"Pyoframe basics","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>In any linear program there are three key components Variables, Constraints, and an Objective. We walk you through these as well as two more: Expressions and Sets</p>"},{"location":"learn/concepts/building-blocks/#variable","title":"<code>Variable</code>","text":""},{"location":"learn/concepts/building-blocks/#constraint","title":"<code>Constraint</code>","text":""},{"location":"learn/concepts/building-blocks/#objective","title":"<code>Objective</code>","text":""},{"location":"learn/concepts/building-blocks/#expression","title":"<code>Expression</code>","text":""},{"location":"learn/concepts/building-blocks/#set","title":"<code>Set</code>","text":""},{"location":"learn/concepts/solver-access/","title":"Solver interface","text":"<p>Pyoframe provides a friendly API that allows you to read and set the various attributes and parameters your solver has to offer.</p>"},{"location":"learn/concepts/solver-access/#model-attributes","title":"Model attributes","text":"<p>Pyoframe lets you read and set solver attributes using <code>model.attr.&lt;your-attribute&gt;</code>. For example, if you'd like to prevent the solver from printing to the console you can do:</p> <pre><code>m = pf.Model()\nm.attr.Silent = True\n</code></pre> <p>Pyoframe supports a set of standard attributes as well as additional Gurobi attributes and COPT attributes.</p> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus  # PyOptInterface attribute (always available)\n&lt;TerminationStatusCode.OPTIMAL: 2&gt;\n&gt;&gt;&gt; m.attr.Status  # Gurobi attribute (only available with Gurobi)\n2\n</code></pre>"},{"location":"learn/concepts/solver-access/#model-parameters","title":"Model parameters","text":"<p>Every solver has a set of parameters that you can read or set using <code>model.params.&lt;your-param&gt;</code>.</p> GurobiCOPTHiGHSIpopt <p>Refer to the list of Gurobi parameters.</p> <pre><code>m = pf.Model(\"gurobi\")\nm.params.Method = 2  # Use barrier method\nm.params.TimeLimit = 100\n</code></pre> <p>Refer to the list of COPT parameters.</p> <pre><code>m = pf.Model(\"copt\")\nm.params.RelGap = 0.01\nm.params.TimeLimit = 100\n</code></pre> <p>Refer to the list of HiGHS options.</p> <pre><code>m = pf.Model(\"highs\")\nm.params.time_limit = 100.0\nm.params.mip_rel_gap = 0.01\n</code></pre> <p>Refer to the list of Ipopt options.</p> <pre><code>m = pf.Model(\"ipopt\")\nm.params.tol = 1e-6\nm.params.max_iter = 1000\n</code></pre> <p>Warning</p> <p>Ipopt does not support reading parameters (only setting them).</p>"},{"location":"learn/concepts/solver-access/#variable-and-constraint-attributes","title":"Variable and constraint attributes","text":"<p>Similar to above, Pyoframe allows directly accessing the PyOptInterface or the solver's variable and constraint attributes.</p> <pre><code>m = pf.Model()\nm.X = pf.Variable()\nm.X.attr.PrimalStart = 5  # Set initial value for warm start\n</code></pre> <p>If the variable or constraint is dimensioned, the attribute can accept/return a DataFrame instead of a constant.</p>"},{"location":"learn/concepts/solver-access/#license-configuration-copt-and-gurobi","title":"License configuration (COPT and Gurobi)","text":"<p>Both COPT and Gurobi support advanced license configurations through the <code>solver_env</code> parameter:</p> COPTGurobi <pre><code># Cluster configuration\nm = pf.Model(\"copt\", solver_env={\"CLIENT_CLUSTER\": \"cluster.example.com\"})\n</code></pre> <pre><code># Compute server\nm = pf.Model(\n    \"gurobi\",\n    solver_env={\"ComputeServer\": \"server.example.com\", \"ServerPassword\": \"password\"},\n)\n</code></pre>"},{"location":"learn/concepts/special-functions/","title":"Transforms","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>Pyoframe has a few special functions that make working with dataframes easy and intuitive. Here they are:</p>"},{"location":"learn/concepts/special-functions/#sum-and-sum_by","title":"<code>sum</code> and <code>sum_by</code>","text":""},{"location":"learn/concepts/special-functions/#expressionmap","title":"<code>Expression.map()</code>","text":""},{"location":"learn/concepts/special-functions/#dataframeto_expr","title":"<code>DataFrame.to_expr()</code>","text":"<p>Summary</p> <p><code>pandas.DataFrame.to_expr()</code> and <code>polars.DataFrame.to_expr()</code> allow users to manually convert their DataFrames to Pyoframe Expressions when Pyoframe is unable to perform an automatic conversation.</p> <p>Pyoframe conveniently allows users to use Polars DataFrames and Pandas DataFrames in their mathematical expressions. To do so, Pyoframe automatically detects these DataFrames and converts them to Pyoframe Expressions whenever there is a mathematical operation (e.g., <code>*</code>, <code>-</code>, <code>+</code>) involving at least one Pyoframe object (e.g. Variable, Set, Expression, etc.).</p> <p>However, if neither the left or right terms of a mathematical operation is a Pyoframe object, Pyoframe will not automatically convert DataFrames<sup>1</sup>. In these situations, users can manually convert their DataFrames to Pyoframe expressions using <code>.to_expr()</code>.</p> <p>Additionally, users should use <code>.to_expr()</code> whenever they wish to use over, drop_extras, or keep_extras on a DataFrame.</p> <p>Under the hood</p> <p>How is <code>.to_expr()</code> a valid Pandas and Polars method? <code>import pyoframe</code> causes Pyoframe to monkey patch the Pandas and Polars libraries. One of the patches adds the <code>.to_expr()</code> method to both <code>pandas.DataFrame</code> and <code>polars.DataFrame</code> (see <code>monkey_patch.py</code>).</p> <p>Working with Pandas Series</p> <p>You can call <code>.to_expr()</code> on a Pandas Series to produce an expression where the labels will be determined from the Series' index.</p>"},{"location":"learn/concepts/special-functions/#example","title":"Example","text":"<p>Consider the following scenario where we have some population data on yearly births and deaths, as well as an immigration variable.</p> <pre><code>import pyoframe as pf\nimport pandas as pd\n\npopulation_data = pd.DataFrame(\n    dict(year=[2025, 2026], births=[1e6, 1.1e6], deaths=[-1.2e6, -1.4e6])\n)\n\nmodel = pf.Model()\nmodel.immigration = pf.Variable(dict(year=[2025, 2026]))\n</code></pre> <p>Now, saw we wanted an expression representing the total yearly population change. The following works just fine:</p> <pre><code>&gt;&gt;&gt; (\n...     model.immigration\n...     + population_data[[\"year\", \"births\"]]\n...     + population_data[[\"year\", \"deaths\"]]\n... )\n&lt;Expression height=2 terms=4 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 year \u2506 expression                \u2502\n\u2502 (2)  \u2506                           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025 \u2506 immigration[2025] -200000 \u2502\n\u2502 2026 \u2506 immigration[2026] -300000 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>But, if we simply change the order of the terms in our addition, we get an error:</p> <pre><code>&gt;&gt;&gt; (\n...     population_data[[\"year\", \"births\"]]\n...     + population_data[[\"year\", \"deaths\"]]\n...     + model.immigration\n... )\nTraceback (most recent call last):\n...\nValueError: Cannot create an expression with duplicate labels:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 births \u2506 deaths \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---    \u2506 ---    \u2506 ---     \u2506 ---           \u2502\n\u2502 f64    \u2506 f64    \u2506 i64     \u2506 i32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null   \u2506 null   \u2506 4050    \u2506 0             \u2502\n\u2502 null   \u2506 null   \u2506 4052    \u2506 0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518.\n</code></pre> <p>What happened? Since Python computes additions from left to right, the second re-arranged version failed because, in the first addition, neither operand is a Pyoframe object. As such, the addition is done by Pandas, not Pyoframe, which leads to unexpected results.</p> <p>How do we avoid these weird behaviors? Users can manually convert their DataFrames to Pyoframe expressions ahead of time with <code>.to_expr()</code>. For example:</p> <pre><code>&gt;&gt;&gt; (\n...     population_data[[\"year\", \"births\"]].to_expr()\n...     + population_data[[\"year\", \"deaths\"]].to_expr()\n...     + model.immigration\n... )\n&lt;Expression height=2 terms=4 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 year \u2506 expression                  \u2502\n\u2502 (2)  \u2506                             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2025 \u2506 -200000 +\u00a0immigration[2025] \u2502\n\u2502 2026 \u2506 -300000 +\u00a0immigration[2026] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li> <p>After all, how could it? If a user decides to write code that adds two DataFrames together, Pyoframe shouldn't interfere.\u00a0\u21a9</p> </li> </ol>"},{"location":"learn/get-started/installation/","title":"Install","text":""},{"location":"learn/get-started/installation/#step-1-install-pyoframe","title":"Step 1: Install Pyoframe","text":"<p>Install Pyoframe using your preferred package manager:</p> pipuv <pre><code>pip install pyoframe\n</code></pre> <pre><code>uv add pyoframe\n</code></pre>"},{"location":"learn/get-started/installation/#step-2-choose-a-solver","title":"Step 2: Choose a solver","text":"<p>Pyoframe makes it easy to build models, but a separate solver is needed to solve the model after it is built. Use the compatibility table below to choose a solver that fits your needs. If you're unsure, choose HiGHS. Note that both Gurobi and COPT offer free licenses for academics.</p> Compatibility table HiGHS (free) Gurobi (paid) COPT (paid) Ipopt (free) Linear programs (LPs) \u2705 \u2705 \u2705 \u2705 Mixed integer programs (MIPs) \u2705* \u2705 \u2705 \u274c Quadratic objective (convex) \u2705 \u2705 \u2705 \u2705 Quadratic objective (non-convex) \u274c \u2705 \u274c \u2705 Quadratic constraints (convex) \u274c \u2705 \u2705 \u2705 Quadratic constraints (non-convex) \u274c \u2705 \u274c \u2705 *Integer variables cannot be used with quadratic objectives. <p>Don't see your preferred solver?</p> <p>Don't hesitate to request another solver. We would gladly consider adding support for other solvers, particularly Mosek which would be easy to support given sufficient interest.</p>"},{"location":"learn/get-started/installation/#step-3-install-the-solver","title":"Step 3: Install the solver","text":"<p>Select your chosen solver and follow the installation instructions.</p> HiGHSGurobiCOPTIpopt <p>To install HiGHS run:</p> <pre><code>pip install pyoframe[highs]\n</code></pre> <p>To install Gurobi:</p> <ol> <li>Download Gurobi from their website (login required) and follow the installation instructions.</li> <li>Ensure you have a valid Gurobi license installed on your machine. (If you're using Gurobi Compute Server or other atypical licensing setups, refer to License configuration.)</li> </ol> <p>Do not install Gurobi using <code>pip</code></p> <p>You should not install Gurobi using <code>pip</code> because Pyoframe uses Gurobi's C API, which the <code>pip</code> installation does not include.</p> <p>To install COPT:</p> <ol> <li>Download COPT from the e-mail you received after requesting a license and follow the installation instructions.</li> <li>Ensure you have valid COPT license files on your machine. (If you're using floating, cluster, or web licenses refer to License configuration.)</li> <li>Set the <code>COPT_HOME</code> environment variable to point to your COPT installation directory.</li> </ol> <p>To install ipopt:</p> <ol> <li>Run: <pre><code>pip install pyoframe[ipopt]\n</code></pre></li> <li>Download the Ipopt binaries from GitHub. Version 3.14.x is recommended since it is the latest version that we've tested.</li> <li>On Windows, unpack the zip and add the <code>bin</code> folder to your Path variable. If not on Windows, you may have to build the solver from source, see further details here.</li> </ol>"},{"location":"learn/get-started/basic-example/example-with-dimensions/","title":"Integrate DataFrames","text":"<p>Pyoframe is built on DataFrames</p> <p>Most other optimization libraries require you to convert your data from its <code>DataFrame</code> format to another format.<sup>1</sup> Not Pyoframe! DataFrames form the core of Pyoframe making it easy to seamlessly \u2014 and efficiently \u2014 integrate large datasets into your models.</p> <p>You are going to re-build the previous example using a dataset, <code>food_data.csv</code>, instead of hard-coded values. This way, you can add as many vegetarian proteins as you like without needing to write more code. If you're impatient, skip to the end to see the final result.</p> <p><code>food_data.csv</code></p> food protein cost tofu_block 18 4 chickpea_can 15 3"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-1-load-the-data","title":"Step 1: Load the data","text":"<p>Load <code>food_data.csv</code> using Polars or Pandas.</p> PolarsPandas <pre><code>import polars as pl\n\ndata = pl.read_csv(\"food_data.csv\")\n</code></pre> <pre><code>import pandas as pd\n\ndata = pd.read_csv(\"food_data.csv\")\n</code></pre> <p>Pandas vs. Polars: Which should I use?</p> <p>Pyoframe works the same whether you're using Polars or Pandas, two similar libraries for manipulating data with DataFrames. We prefer using Polars because it is much faster (and generally better), but you can use whichever library you're most comfortable with.</p> <p>Note that, internally, Pyoframe always uses Polars during computations to ensure the best performance. If you're using Pandas, your DataFrames will automatically be converted to Polars prior to computations. If needed, you can convert a Polars DataFrame back to Pandas using <code>polars.DataFrame.to_pandas()</code>.</p>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-2-create-the-model","title":"Step 2: Create the model","text":"<pre><code>import pyoframe as pf\n\nm = pf.Model()\n</code></pre> <p>A <code>pyoframe.Model</code> instance sets the foundation of your optimization model onto which you can add optimization variables, constraints, and an objective.</p>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-3-create-a-dimensioned-variable","title":"Step 3: Create a dimensioned variable","text":"<p>Previously, you created two variables: <code>m.tofu_blocks</code> and <code>m.chickpea_cans</code>. Instead, create a single variable dimensioned over the column <code>food</code>.</p> <pre><code>m.Buy = pf.Variable(data[\"food\"], lb=0, vtype=\"integer\")\n</code></pre> <p>Printing the variable shows that it contains a <code>food</code> dimension with labels <code>tofu</code> and <code>chickpeas</code>!</p> <pre><code>&gt;&gt;&gt; m.Buy\n&lt;Variable 'Buy' lb=0 height=2&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food         \u2506 variable          \u2502\n\u2502 (2)          \u2506                   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 tofu_block   \u2506 Buy[tofu_block]   \u2502\n\u2502 chickpea_can \u2506 Buy[chickpea_can] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Capitalize model variables</p> <p>We suggest capitalizing model variables (i.e. <code>m.Buy</code>, not <code>m.buy</code>) to make distinguishing what is and isn't a variable easy.</p>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-3-create-the-objective-with-sum","title":"Step 3: Create the objective with <code>.sum()</code>","text":"<p>Previously you had:</p> <pre><code>m.minimize = 4 * m.tofu_blocks + 3 * m.chickpea_cans\n</code></pre> <p>How do you make use of the dimensioned variable <code>m.Buy</code> instead?</p> <p>First, multiply the variable by the protein amount.</p> <pre><code>&gt;&gt;&gt; data[[\"food\", \"cost\"]] * m.Buy\n&lt;Expression height=2 terms=2 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food         \u2506 expression          \u2502\n\u2502 (2)          \u2506                     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 tofu_block   \u2506 4\u00a0Buy[tofu_block]   \u2502\n\u2502 chickpea_can \u2506 3\u00a0Buy[chickpea_can] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>As you can see, Pyoframe with a bit of magic converted the <code>Variable</code> into an <code>Expression</code> where the coefficients are the protein amounts.</p> <p>Second, notice that the <code>Expression</code> still has the <code>food</code> dimension\u2014it really contains two separate expressions, one for tofu and one for chickpeas. All objective functions must be a single expression (without dimensions) so let's sum over the <code>food</code> dimension.</p> <pre><code>&gt;&gt;&gt; (data[[\"food\", \"cost\"]] * m.Buy).sum(\"food\")\n&lt;Expression terms=2 type=linear&gt;\n4\u00a0Buy[tofu_block] +3\u00a0Buy[chickpea_can]\n</code></pre> <p>This works and since <code>food</code> is the only dimensions you don't even need to specify it. Putting it all together:</p> <pre><code>m.minimize = (data[[\"food\", \"cost\"]] * m.Buy).sum()\n</code></pre>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#step-4-add-the-constraint","title":"Step 4: Add the constraint","text":"<p>This is similar to how you created the objective, except now you're using <code>protein</code> and you turn the <code>Expression</code> into a <code>Constraint</code> with the <code>&gt;=</code> operation.</p> <pre><code>m.protein_constraint = (data[[\"food\", \"protein\"]] * m.Buy).sum() &gt;= 50\n</code></pre>"},{"location":"learn/get-started/basic-example/example-with-dimensions/#put-it-all-together","title":"Put it all together","text":"<pre><code>import pandas as pd\nimport pyoframe as pf\n\ndata = pd.read_csv(\"food_data.csv\")\n\nm = pf.Model()\nm.Buy = pf.Variable(data[\"food\"], lb=0, vtype=\"integer\")\nm.minimize = (data[[\"food\", \"cost\"]] * m.Buy).sum()\nm.protein_constraint = (data[[\"food\", \"protein\"]] * m.Buy).sum() &gt;= 50\n\nm.optimize()\n</code></pre> <p>So you should buy:</p> <pre><code>&gt;&gt;&gt; m.Buy.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food         \u2506 solution \u2502\n\u2502 ---          \u2506 ---      \u2502\n\u2502 str          \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 tofu_block   \u2506 2        \u2502\n\u2502 chickpea_can \u2506 1        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Notice that since <code>m.Buy</code> is dimensioned, <code>m.Buy.solution</code> returned a DataFrame with the solution for each of the labels.</p> <p>Returning Pandas DataFrames</p> <p>Pyoframe currently always returns Polars DataFrames but you can easily convert them to Pandas using <code>.to_pandas()</code>. In the future, we plan to add support for automatically returning Pandas DataFrames. Upvote the issue if you'd like this feature.</p> <ol> <li> <p>For example, Pyomo converts your DataFrames to individual Python objects, Linopy uses multi-dimensional matrices via xarray, and gurobipy requires Python lists, dictionaries and tuples. While gurobipy-pandas uses dataframes, it only works with Gurobi!\u00a0\u21a9</p> </li> </ol>"},{"location":"learn/get-started/basic-example/example/","title":"Build a simple model","text":"<p>To start, you'll solve a simple optimization problem with Pyoframe.</p> <p>Problem statement</p> <p>Imagine you're a vegetarian hesitating between tofu and chickpeas as a source of protein for tomorrow's dinner. You'd like to spend as little money as possible while still consuming at least 50 grams of protein. How many blocks of tofu ($4 each, 18g of protein) and cans of chickpeas ($3 each, 15g of protein) should you buy?</p> <p>Click on the  buttons below to understand the code, and then run it on your computer.</p> <pre><code>import pyoframe as pf\n\nm = pf.Model()\n\n# You can buy tofu or chickpeas\nm.tofu_blocks = pf.Variable(lb=0, vtype=\"integer\")  # (1)!\nm.chickpea_cans = pf.Variable(lb=0, vtype=\"integer\")\n\n# You want to minimize your cost\nm.minimize = 4 * m.tofu_blocks + 3 * m.chickpea_cans  # (2)!\n\n# But still consume enough protein\nm.protein_constraint = 18 * m.tofu_blocks + 15 * m.chickpea_cans &gt;= 50  # (3)!\n\nm.optimize()  # (4)!\n\nprint(\"Tofu blocks:\", m.tofu_blocks.solution)\nprint(\"Chickpea cans:\", m.chickpea_cans.solution)\n</code></pre> <ol> <li> <p><code>lb=0</code> set a lower bound so that you can't buy negative amounts of tofu. </p> <p><code>vtype=\"integer\"</code> ensures that you can't buy a fraction of a block.</p> </li> <li> <p><code>minimize</code> and <code>maximize</code> are reserved variable names that can be used to set the objective.</p> </li> <li>Pyoframe constraints are easily created with the <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code> operators.</li> <li>Pyoframe automatically detects the solver you have installed; no need to specify it!</li> </ol> <p>After running the code you should get:</p> <pre><code>Tofu blocks: 2\nChickpea cans: 1\n</code></pre> <p>On the next page, you'll integrate DataFrames into your solution.</p>"},{"location":"learn/migrate/v1.0/","title":"Migrate to Pyoframe v1.0","text":"<p>Pyoframe version 1.0 brings major improvements </p> <ul> <li>New features including support for the Ipopt solver, the COPT solver, and the ability to improve performance with <code>pf.Config.maintain_order=False</code>.</li> <li>Bug fixes: notably with <code>Variable(equals=\u2026)</code> not properly parsing DataFrames.</li> <li>Improved performance after rewriting internal functions based on extensive benchmarking.</li> <li>Smoother developer experience, notably error messages explain the mathematical operations that led to an error and Pyoframe objects now print as legible tables.</li> <li>Improved documentation including a revamped API page, an examples page, new explanations of functions like <code>.over(\u2026)</code>, and the ability to view previous versions of the documentation.</li> <li>More readable syntax like our decision to rename <code>add_dim</code> to <code>over</code> and the changes to <code>.sum()</code> (see below).</li> </ul> <p>Unfortunately, these improvements involve some breaking changes. This page will guide you in migrating your code to v1.0.</p>"},{"location":"learn/migrate/v1.0/#breaking-changes","title":"Breaking changes","text":"<p>Summary:</p> <ol> <li><code>pf.Model(\u2026)</code> has a new signature</li> <li><code>pf.sum(\u2026, obj)</code> was replaced by <code>obj.sum(\u2026)</code></li> <li><code>add_dim(\u2026)</code> was renamed to <code>over(\u2026)</code></li> <li><code>keep_unmatched()</code> and <code>drop_unmatched</code> were renamed to <code>keep_extras()</code> and <code>drop_extras()</code></li> <li>Other less common breaking changes</li> </ol> <p>Follow the steps below to upgrade to v1.0.</p>"},{"location":"learn/migrate/v1.0/#1-update-all-calls-to-pfmodel","title":"1. Update all calls to <code>pf.Model(\u2026)</code>","text":"<p>The signature of <code>pf.Model(\u2026)</code> has changed from</p> <pre><code>Model(name=None, solver=None, solver_env=None, use_var_names=False, sense=None)\n</code></pre> <p>to</p> <pre><code>Model(solver=None, solver_env=None, *, name=None, solver_uses_variable_names=False, print_uses_variable_names=True, sense=None)\n</code></pre> <p>Importantly, notice how,</p> <ul> <li> <p><code>name</code> is now a named-only parameter (you must write <code>name=</code>), and</p> </li> <li> <p><code>use_var_names</code> was renamed to <code>solver_uses_variable_names</code> (to avoid confusion with the new option <code>print_uses_variable_names</code>).</p> </li> </ul> <p>Please update all calls to <code>pf.Model(\u2026)</code> accordingly.</p> <pre><code>import pyoframe as pf\n\npf.Model(\"my-model\")  # before\npf.Model(name=\"my-model\")  # after\n\npf.Model(use_var_names=True)  # before\npf.Model(solver_uses_variable_names=True)  # after\n</code></pre>"},{"location":"learn/migrate/v1.0/#2-replace-pfsum-obj-with-objsum","title":"2. Replace <code>pf.sum(\u2026, obj)</code> with <code>obj.sum(\u2026)</code>","text":"<p>To improve readability and align with Python best practices, both <code>pf.sum(\u2026, obj)</code> and <code>pf.sum_by(\u2026, obj)</code> have been replaced by <code>obj.sum(\u2026)</code> and <code>obj.sum_by(\u2026)</code>. Here <code>obj</code> represents any Pyoframe Variable or Expression.<sup>1</sup> For example:</p> <pre><code>pf.sum(m.X)  # before\nm.X.sum()  # after\n\npf.sum([\"day\", \"hour\"], m.X)  # before\nm.X.sum(\"day\", \"hour\")  # after\n\npf.sum_by(\"city\", m.X)  # before\nm.X.sum_by(\"city\")  # after\n</code></pre> <p>Please update all uses of <code>pf.sum</code> and <code>pf.sum_by</code> accordingly.</p>"},{"location":"learn/migrate/v1.0/#3-rename-add_dim-to-over","title":"3. Rename <code>.add_dim(\u2026)</code> to <code>.over(\u2026)</code>","text":"<p>For clarity, <code>.add_dim(\u2026)</code> was renamed to <code>.over(\u2026)</code>. Please update your code accordingly.</p> <pre><code>m.X.add_dim(\"time\")  # before\nm.X.over(\"time\")  # after\n</code></pre>"},{"location":"learn/migrate/v1.0/#4-rename-keep_unmatched-and-drop_unmatched-with-keep_extras-and-drop_extras","title":"4. Rename <code>.keep_unmatched()</code> and <code>.drop_unmatched()</code> with <code>.keep_extras()</code> and <code>.drop_extras()</code>","text":"<p>For clarity, <code>.keep_unmatched()</code> and <code>.drop_unmatched()</code> were renamed to <code>.keep_extras()</code> and <code>.drop_extras()</code>, respectively. Please update your code accordingly.</p> <pre><code>m.X.keep_unmatched()  # before\nm.X.keep_extras()  # after\n\nm.X.drop_unmatched()  # before\nm.X.drop_extras()  # after\n</code></pre>"},{"location":"learn/migrate/v1.0/#5-review-code-for-other-breaking-changes","title":"5. Review code for other breaking changes","text":"<p>Steps 1 to 3 should cover most breaking changes. For completeness, below are some additional breaking changes that you are less likely to encounter.</p> <ol> <li> <p>All submodules (e.g. <code>pyoframe.core</code>) and some attributes (<code>obj.unmatched_strategy</code>, <code>obj.allowed_new_dims</code>, <code>obj.dimensions_unsafe</code>, <code>Config.enable_is_duplicated_expression_safety_check</code>) have been renamed to begin with an underscore (e.g. now <code>pyoframe._core</code>) to indicate that these elements are no longer part of the public API.</p> </li> <li> <p>If you try to read <code>model.objective</code> before having defined an objective, an error will be raised. Prior to v1.0 <code>None</code> was returned.</p> </li> <li> <p><code>.over(\u2026)</code>, <code>.keep_extras()</code>, and <code>.drop_extras()</code> now have a well-defined \"order of operations.\" They must be applied after all other transforms. For example, <code>my_obj.drop_extras().sum(\"time\")</code> no longer works because <code>my_obj.sum(\"time\").drop_extras()</code> should be used instead. Learn more.</p> </li> <li> <p><code>pf.Config.print_max_set_elements</code>, <code>pf.Config.print_max_line_length</code>, and <code>pf.Config.print_max_lines</code> no longer exist. Use <code>pf.Config.print_max_terms</code> <code>pf.Config.print_polars_config</code> instead.</p> </li> <li> <p><code>pf.Config.print_uses_variable_names</code> no longer exists. Use the equivalent option in <code>pf.Model(\u2026)</code></p> </li> <li> <p><code>pf.Config.default_solver</code> now defaults to <code>\"auto\"</code> instead of <code>None</code> to clarify that by default, the solver will be automatically detected. Don't set <code>pf.Config.default_solver = None</code>.</p> </li> <li> <p><code>pf.Config.disable_unmatched_checks</code> has been renamed to <code>pf.Config.disable_extras_checks</code>.</p> </li> <li> <p>Gurobi users: <code>Model.write(\u2026)</code> is now only available when <code>solver_uses_variable_names=True</code>.</p> </li> <li> <p>Previously, passing a DataFrame to the <code>equals=</code> parameter of the <code>Variable</code> constructor would result in a Variable equal to 1. This bug has been fixed.</p> </li> </ol> <ol> <li> <p>If you were using <code>pf.sum</code> or <code>pf.sum_by</code> on a Polars or Pandas DataFrame instead of on a Pyoframe object, you should use the <code>.sum()</code> function native to Pandas/Polars.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/","title":"Overview of Pyoframe's API","text":"<p>Pyoframe's classes and subclasses are structured as follows:</p> <ul> <li>Model</li> <li>BaseBlock*<ul> <li>Constraint</li> <li>BaseOperableBlock*<ul> <li>Variable</li> <li>Expression<ul> <li>Objective</li> </ul> </li> <li>Set</li> </ul> </li> </ul> </li> <li>Config</li> </ul> <p>The following enums are also available:</p> <ul> <li>VType</li> <li>ObjSense</li> </ul> <p>Finally, PyoframeError is a Pyoframe custom error type. </p> <p>All the above classes (except those marked with an asterisk) can be imported via:</p> <pre><code>import pyoframe as pf\n</code></pre> <p>Additionally, importing Pyoframe patches Pandas and Polars such that the following methods are available.</p> <ul> <li>polars.DataFrame.to_expr</li> <li>pandas.DataFrame.to_expr</li> <li>pandas.Series.to_expr</li> </ul>"},{"location":"reference/bases/BaseBlock/","title":"BaseBlock","text":"<p>               Bases: <code>ABC</code></p> <p>The base class for elements of a Model such as  and .</p> <p>Methods:</p> Name Description <code>estimated_size</code> <p>Returns the estimated size of the object in bytes.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>DataFrame</code> <p>Returns the object's underlying Polars DataFrame.</p> <code>dimensionless</code> <code>bool</code> <p>Whether the object has no dimensions.</p> <code>dimensions</code> <code>list[str] | None</code> <p>The names of the data's dimensions.</p> <code>name</code> <code>str</code> <code>shape</code> <code>dict[str, int]</code> <p>The number of distinct labels in each dimension.</p> Source code in <code>pyoframe/_model_element.py</code> <pre><code>def __init__(self, data: pl.DataFrame, name=\"unnamed\") -&gt; None:\n    # Sanity checks, no duplicate column names\n    assert len(data.columns) == len(set(data.columns)), (\n        \"Duplicate column names found.\"\n    )\n\n    cols = _get_dimensions(data)\n    if cols is None:\n        cols = []\n    cols += [col for col in RESERVED_COL_KEYS if col in data.columns]\n\n    # Reorder columns to keep things consistent\n    data = data.select(cols)\n\n    # Cast to proper dtype\n    if COEF_KEY in data.columns:\n        data = data.cast({COEF_KEY: pl.Float64})\n    if VAR_KEY in data.columns:\n        data = data.cast({VAR_KEY: Config.id_dtype})\n    if QUAD_VAR_KEY in data.columns:\n        data = data.cast({QUAD_VAR_KEY: Config.id_dtype})\n\n    self._data = data\n    self._model: Model | None = None\n    self.name: str = name  # gets overwritten if object is added to model\n</code></pre>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.data","title":"<code>data: pl.DataFrame</code>","text":"<p>Returns the object's underlying Polars DataFrame.</p>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.dimensionless","title":"<code>dimensionless: bool</code>","text":"<p>Whether the object has no dimensions.</p> <p>Examples:</p> <p>A variable with no dimensions</p> <pre><code>&gt;&gt;&gt; pf.Variable().dimensionless\nTrue\n</code></pre> <p>A variable with dimensions of \"hour\" and \"city\"</p> <pre><code>&gt;&gt;&gt; pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... ).dimensionless\nFalse\n</code></pre>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.dimensions","title":"<code>dimensions: list[str] | None</code>","text":"<p>The names of the data's dimensions.</p> <p>Examples:</p> <p>A variable with no dimensions</p> <pre><code>&gt;&gt;&gt; pf.Variable().dimensions\n</code></pre> <p>A variable with dimensions of \"hour\" and \"city\"</p> <pre><code>&gt;&gt;&gt; pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... ).dimensions\n['hour', 'city']\n</code></pre>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.name","title":"<code>name: str = name</code>","text":""},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.shape","title":"<code>shape: dict[str, int]</code>","text":"<p>The number of distinct labels in each dimension.</p> <p>Examples:</p> <p>A variable with no dimensions</p> <pre><code>&gt;&gt;&gt; pf.Variable().shape\n{}\n</code></pre> <p>A variable with dimensions of \"hour\" and \"city\"</p> <pre><code>&gt;&gt;&gt; pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... ).shape\n{'hour': 4, 'city': 3}\n</code></pre>"},{"location":"reference/bases/BaseBlock/#pyoframe._model_element.BaseBlock.estimated_size","title":"<code>estimated_size(unit: pl.SizeUnit = 'b') -&gt; int | float</code>","text":"<p>Returns the estimated size of the object in bytes.</p> <p>Only considers the size of the underlying DataFrame(s) since other components (e.g., the object name) are negligible.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>SizeUnit</code> <p>See <code>polars.DataFrame.estimated_size</code>.</p> <code>'b'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n</code></pre> <p>A dimensionless variable contains just a 32 bit (4 bytes) unsigned integer (the variable ID).</p> <pre><code>&gt;&gt;&gt; m.x = pf.Variable()\n&gt;&gt;&gt; m.x.estimated_size()\n4\n</code></pre> <p>A dimensioned variable contains, for every row, a 32 bit ID and, in this case, a 64 bit <code>dim_x</code> value (1200 bytes total).</p> <pre><code>&gt;&gt;&gt; m.y = pf.Variable(pf.Set(dim_x=range(100)))\n&gt;&gt;&gt; m.y.estimated_size()\n1200\n</code></pre> Source code in <code>pyoframe/_model_element.py</code> <pre><code>def estimated_size(self, unit: pl.SizeUnit = \"b\") -&gt; int | float:\n    \"\"\"Returns the estimated size of the object in bytes.\n\n    Only considers the size of the underlying DataFrame(s) since other components (e.g., the object name) are negligible.\n\n    Parameters:\n        unit:\n            See [`polars.DataFrame.estimated_size`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.estimated_size.html).\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n\n        A dimensionless variable contains just a 32 bit (4 bytes) unsigned integer (the variable ID).\n\n        &gt;&gt;&gt; m.x = pf.Variable()\n        &gt;&gt;&gt; m.x.estimated_size()\n        4\n\n        A dimensioned variable contains, for every row, a 32 bit ID and, in this case, a 64 bit `dim_x` value (1200 bytes total).\n\n        &gt;&gt;&gt; m.y = pf.Variable(pf.Set(dim_x=range(100)))\n        &gt;&gt;&gt; m.y.estimated_size()\n        1200\n    \"\"\"\n    return self.data.estimated_size(unit)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/","title":"BaseOperableBlock","text":"<p>               Bases: <code>BaseBlock</code></p> <p>Any object that can be converted into an expression.</p> <p>Methods:</p> Name Description <code>add_dim</code> <p>Deprecated, use <code>over</code> instead.</p> <code>drop_extras</code> <p>Indicates that labels not present in the other expression should be discarded during addition, subtraction, or constraint creation.</p> <code>drop_unmatched</code> <p>Deprecated, use <code>drop_extras</code> instead.</p> <code>filter</code> <p>Creates a copy of the object containing only a subset of the original rows.</p> <code>keep_extras</code> <p>Indicates that labels not present in the other expression should be kept during addition, subtraction, or constraint creation.</p> <code>keep_unmatched</code> <p>Deprecated, use <code>keep_extras</code> instead.</p> <code>map</code> <p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.map</code>.</p> <code>over</code> <p>Indicates that the expression can be broadcasted over the given dimensions during addition and subtraction.</p> <code>pick</code> <p>Filters elements by the given criteria and then drops the filtered dimensions.</p> <code>raise_extras</code> <p>Indicates that labels not present in the other expression should raise an error during addition, subtraction, or constraint creation.</p> <code>rename</code> <p>Renames one or several of the object's dimensions.</p> <code>sum</code> <p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.sum</code>.</p> <code>sum_by</code> <p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.sum_by</code>.</p> <code>to_expr</code> <p>Converts the object to a Pyoframe Expression.</p> <code>with_columns</code> <p>Creates a new object with modified columns.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    self._extras_strategy = ExtrasStrategy.UNSET\n    self._allowed_new_dims: list[str] = []\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.add_dim","title":"<code>add_dim(*dims: str)</code>","text":"<p>Deprecated, use <code>over</code> instead.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def add_dim(self, *dims: str):  # pragma: no cover\n    \"\"\"Deprecated, use [`over`][pyoframe.Expression.over] instead.\"\"\"\n    warnings.warn(\n        \"'add_dim' has been renamed to 'over'. Please use 'over' instead.\",\n        DeprecationWarning,\n    )\n    return self.over(*dims)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.drop_extras","title":"<code>drop_extras()</code>","text":"<p>Indicates that labels not present in the other expression should be discarded during addition, subtraction, or constraint creation.</p> <p>Learn more about addition modifiers.</p> See Also <p><code>keep_extras</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def drop_extras(self):\n    \"\"\"Indicates that labels not present in the other expression should be discarded during addition, subtraction, or constraint creation.\n\n    [Learn more](../../learn/concepts/addition.md) about addition modifiers.\n\n    See Also:\n        [`keep_extras`][pyoframe.Expression.keep_extras].\n    \"\"\"\n    new = self._new(self.data, name=f\"{self.name}.drop_extras()\")\n    new._copy_flags(self)\n    new._extras_strategy = ExtrasStrategy.DROP\n    return new\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.drop_unmatched","title":"<code>drop_unmatched()</code>","text":"<p>Deprecated, use <code>drop_extras</code> instead.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def drop_unmatched(self):  # pragma: no cover\n    \"\"\"Deprecated, use [`drop_extras`][pyoframe.Expression.drop_extras] instead.\"\"\"\n    warnings.warn(\n        \"'drop_unmatched' has been renamed to 'drop_extras'. Please use 'drop_extras' instead.\",\n        DeprecationWarning,\n    )\n    return self.drop_extras()\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.filter","title":"<code>filter(*args, **kwargs)</code>","text":"<p>Creates a copy of the object containing only a subset of the original rows.</p> <p>Takes the same arguments as <code>polars.DataFrame.filter</code>.</p> See Also <p><code>Expression.pick</code> or <code>Variable.pick</code> if you wish to drop the filtered column in the process.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef filter(self, *args, **kwargs):\n    \"\"\"Creates a copy of the object containing only a subset of the original rows.\n\n    Takes the same arguments as [`polars.DataFrame.filter`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.filter.html).\n\n    See Also:\n        [`Expression.pick`][pyoframe.Expression.pick] or [`Variable.pick`][pyoframe.Variable.pick] if you wish to drop the filtered\n        column in the process.\n\n    \"\"\"\n    return self.data.filter(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.keep_extras","title":"<code>keep_extras()</code>","text":"<p>Indicates that labels not present in the other expression should be kept during addition, subtraction, or constraint creation.</p> <p>Learn more about addition modifiers.</p> See Also <p><code>drop_extras</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def keep_extras(self):\n    \"\"\"Indicates that labels not present in the other expression should be kept during addition, subtraction, or constraint creation.\n\n    [Learn more](../../learn/concepts/addition.md) about addition modifiers.\n\n    See Also:\n        [`drop_extras`][pyoframe.Expression.drop_extras].\n    \"\"\"\n    new = self._new(self.data, name=f\"{self.name}.keep_extras()\")\n    new._copy_flags(self)\n    new._extras_strategy = ExtrasStrategy.KEEP\n    return new\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.keep_unmatched","title":"<code>keep_unmatched()</code>","text":"<p>Deprecated, use <code>keep_extras</code> instead.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def keep_unmatched(self):  # pragma: no cover\n    \"\"\"Deprecated, use [`keep_extras`][pyoframe.Expression.keep_extras] instead.\"\"\"\n    warnings.warn(\n        \"'keep_unmatched' has been renamed to 'keep_extras'. Please use 'keep_extras' instead.\",\n        DeprecationWarning,\n    )\n    return self.keep_extras()\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.map","title":"<code>map(*args, **kwargs)</code>","text":"<p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.map</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def map(self, *args, **kwargs):\n    \"\"\"Converts the object to an expression (see `.to_expr()`) and then applies [`Expression.map`][pyoframe.Expression.map].\"\"\"\n    return self.to_expr().map(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.over","title":"<code>over(*dims: str)</code>","text":"<p>Indicates that the expression can be broadcasted over the given dimensions during addition and subtraction.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def over(self, *dims: str):\n    \"\"\"Indicates that the expression can be broadcasted over the given dimensions during addition and subtraction.\"\"\"\n    new = self._new(self.data, name=f\"{self.name}.over(\u2026)\")\n    new._copy_flags(self)\n    new._allowed_new_dims.extend(dims)\n    return new\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.pick","title":"<code>pick(**kwargs)</code>","text":"<p>Filters elements by the given criteria and then drops the filtered dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... )\n&gt;&gt;&gt; m.v.pick(hour=\"06:00\")\n&lt;Expression height=3 terms=3 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 city    \u2506 expression       \u2502\n\u2502 (3)     \u2506                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto \u2506 v[06:00,Toronto] \u2502\n\u2502 Berlin  \u2506 v[06:00,Berlin]  \u2502\n\u2502 Paris   \u2506 v[06:00,Paris]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.v.pick(hour=\"06:00\", city=\"Toronto\")\n&lt;Expression terms=1 type=linear&gt;\nv[06:00,Toronto]\n</code></pre> See Also <p><code>Expression.filter</code> or <code>Variable.filter</code> if you don't wish to drop the filtered column.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef pick(self, **kwargs):\n    \"\"\"Filters elements by the given criteria and then drops the filtered dimensions.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable(\n        ...     [\n        ...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n        ...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n        ...     ]\n        ... )\n        &gt;&gt;&gt; m.v.pick(hour=\"06:00\")\n        &lt;Expression height=3 terms=3 type=linear&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 city    \u2506 expression       \u2502\n        \u2502 (3)     \u2506                  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Toronto \u2506 v[06:00,Toronto] \u2502\n        \u2502 Berlin  \u2506 v[06:00,Berlin]  \u2502\n        \u2502 Paris   \u2506 v[06:00,Paris]   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; m.v.pick(hour=\"06:00\", city=\"Toronto\")\n        &lt;Expression terms=1 type=linear&gt;\n        v[06:00,Toronto]\n\n    See Also:\n        [`Expression.filter`][pyoframe.Expression.filter] or [`Variable.filter`][pyoframe.Variable.filter] if you don't wish to drop the filtered column.\n    \"\"\"\n    return self.data.filter(**kwargs).drop(kwargs.keys())\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.raise_extras","title":"<code>raise_extras()</code>","text":"<p>Indicates that labels not present in the other expression should raise an error during addition, subtraction, or constraint creation.</p> <p>This is the default behavior and, as such, this addition modifier should only be used in the rare cases where you want to override a previous use of <code>keep_extras()</code> or <code>drop_extras()</code>.</p> <p>Learn more about addition modifiers.</p> See Also <p><code>keep_extras</code> and <code>drop_extras</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def raise_extras(self):\n    \"\"\"Indicates that labels not present in the other expression should raise an error during addition, subtraction, or constraint creation.\n\n    This is the default behavior and, as such, this addition modifier should only be used in the rare cases where you want to override a previous use of `keep_extras()` or `drop_extras()`.\n\n    [Learn more](../../learn/concepts/addition.md) about addition modifiers.\n\n    See Also:\n        [`keep_extras`][pyoframe.Expression.keep_extras] and [`drop_extras`][pyoframe.Expression.drop_extras].\n    \"\"\"\n    new = self._new(self.data, name=f\"{self.name}.raise_extras()\")\n    new._copy_flags(self)\n    new._extras_strategy = ExtrasStrategy.UNSET\n    return new\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.rename","title":"<code>rename(*args, **kwargs)</code>","text":"<p>Renames one or several of the object's dimensions.</p> <p>Takes the same arguments as <code>polars.DataFrame.rename</code>.</p> <p>See the portfolio optimization example for a usage example.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable(\n...     {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...     {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n... )\n&gt;&gt;&gt; m.v\n&lt;Variable 'v' height=12&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 hour  \u2506 city    \u2506 variable         \u2502\n\u2502 (4)   \u2506 (3)     \u2506                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00 \u2506 Toronto \u2506 v[00:00,Toronto] \u2502\n\u2502 00:00 \u2506 Berlin  \u2506 v[00:00,Berlin]  \u2502\n\u2502 00:00 \u2506 Paris   \u2506 v[00:00,Paris]   \u2502\n\u2502 06:00 \u2506 Toronto \u2506 v[06:00,Toronto] \u2502\n\u2502 06:00 \u2506 Berlin  \u2506 v[06:00,Berlin]  \u2502\n\u2502 \u2026     \u2506 \u2026       \u2506 \u2026                \u2502\n\u2502 12:00 \u2506 Berlin  \u2506 v[12:00,Berlin]  \u2502\n\u2502 12:00 \u2506 Paris   \u2506 v[12:00,Paris]   \u2502\n\u2502 18:00 \u2506 Toronto \u2506 v[18:00,Toronto] \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 v[18:00,Berlin]  \u2502\n\u2502 18:00 \u2506 Paris   \u2506 v[18:00,Paris]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; m.v.rename({\"city\": \"location\"})\n&lt;Expression height=12 terms=12 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 hour  \u2506 location \u2506 expression       \u2502\n\u2502 (4)   \u2506 (3)      \u2506                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00 \u2506 Toronto  \u2506 v[00:00,Toronto] \u2502\n\u2502 00:00 \u2506 Berlin   \u2506 v[00:00,Berlin]  \u2502\n\u2502 00:00 \u2506 Paris    \u2506 v[00:00,Paris]   \u2502\n\u2502 06:00 \u2506 Toronto  \u2506 v[06:00,Toronto] \u2502\n\u2502 06:00 \u2506 Berlin   \u2506 v[06:00,Berlin]  \u2502\n\u2502 \u2026     \u2506 \u2026        \u2506 \u2026                \u2502\n\u2502 12:00 \u2506 Berlin   \u2506 v[12:00,Berlin]  \u2502\n\u2502 12:00 \u2506 Paris    \u2506 v[12:00,Paris]   \u2502\n\u2502 18:00 \u2506 Toronto  \u2506 v[18:00,Toronto] \u2502\n\u2502 18:00 \u2506 Berlin   \u2506 v[18:00,Berlin]  \u2502\n\u2502 18:00 \u2506 Paris    \u2506 v[18:00,Paris]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef rename(self, *args, **kwargs):\n    \"\"\"Renames one or several of the object's dimensions.\n\n    Takes the same arguments as [`polars.DataFrame.rename`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.rename.html).\n\n    See the [portfolio optimization example](../../examples/portfolio_optimization.md) for a usage example.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable(\n        ...     {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n        ...     {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n        ... )\n        &gt;&gt;&gt; m.v\n        &lt;Variable 'v' height=12&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 hour  \u2506 city    \u2506 variable         \u2502\n        \u2502 (4)   \u2506 (3)     \u2506                  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 00:00 \u2506 Toronto \u2506 v[00:00,Toronto] \u2502\n        \u2502 00:00 \u2506 Berlin  \u2506 v[00:00,Berlin]  \u2502\n        \u2502 00:00 \u2506 Paris   \u2506 v[00:00,Paris]   \u2502\n        \u2502 06:00 \u2506 Toronto \u2506 v[06:00,Toronto] \u2502\n        \u2502 06:00 \u2506 Berlin  \u2506 v[06:00,Berlin]  \u2502\n        \u2502 \u2026     \u2506 \u2026       \u2506 \u2026                \u2502\n        \u2502 12:00 \u2506 Berlin  \u2506 v[12:00,Berlin]  \u2502\n        \u2502 12:00 \u2506 Paris   \u2506 v[12:00,Paris]   \u2502\n        \u2502 18:00 \u2506 Toronto \u2506 v[18:00,Toronto] \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 v[18:00,Berlin]  \u2502\n        \u2502 18:00 \u2506 Paris   \u2506 v[18:00,Paris]   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; m.v.rename({\"city\": \"location\"})\n        &lt;Expression height=12 terms=12 type=linear&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 hour  \u2506 location \u2506 expression       \u2502\n        \u2502 (4)   \u2506 (3)      \u2506                  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 00:00 \u2506 Toronto  \u2506 v[00:00,Toronto] \u2502\n        \u2502 00:00 \u2506 Berlin   \u2506 v[00:00,Berlin]  \u2502\n        \u2502 00:00 \u2506 Paris    \u2506 v[00:00,Paris]   \u2502\n        \u2502 06:00 \u2506 Toronto  \u2506 v[06:00,Toronto] \u2502\n        \u2502 06:00 \u2506 Berlin   \u2506 v[06:00,Berlin]  \u2502\n        \u2502 \u2026     \u2506 \u2026        \u2506 \u2026                \u2502\n        \u2502 12:00 \u2506 Berlin   \u2506 v[12:00,Berlin]  \u2502\n        \u2502 12:00 \u2506 Paris    \u2506 v[12:00,Paris]   \u2502\n        \u2502 18:00 \u2506 Toronto  \u2506 v[18:00,Toronto] \u2502\n        \u2502 18:00 \u2506 Berlin   \u2506 v[18:00,Berlin]  \u2502\n        \u2502 18:00 \u2506 Paris    \u2506 v[18:00,Paris]   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    return self.data.rename(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.sum","title":"<code>sum(*args, **kwargs)</code>","text":"<p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.sum</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def sum(self, *args, **kwargs):\n    \"\"\"Converts the object to an expression (see `.to_expr()`) and then applies [`Expression.sum`][pyoframe.Expression.sum].\"\"\"\n    return self.to_expr().sum(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.sum_by","title":"<code>sum_by(*args, **kwargs)</code>","text":"<p>Converts the object to an expression (see <code>.to_expr()</code>) and then applies <code>Expression.sum_by</code>.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def sum_by(self, *args, **kwargs):\n    \"\"\"Converts the object to an expression (see `.to_expr()`) and then applies [`Expression.sum_by`][pyoframe.Expression.sum_by].\"\"\"\n    return self.to_expr().sum_by(*args, **kwargs)\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.to_expr","title":"<code>to_expr() -&gt; Expression</code>","text":"<p>Converts the object to a Pyoframe Expression.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@abstractmethod\ndef to_expr(self) -&gt; Expression:\n    \"\"\"Converts the object to a Pyoframe Expression.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/bases/BaseOperableBlock/#pyoframe._core.BaseOperableBlock.with_columns","title":"<code>with_columns(*args, **kwargs)</code>","text":"<p>Creates a new object with modified columns.</p> <p>Takes the same arguments as <code>polars.DataFrame.with_columns</code>.</p> <p>Warning</p> <p>Only use this function if you know what you're doing. It is not recommended to manually modify the columns within a Pyoframe object.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef with_columns(self, *args, **kwargs):\n    \"\"\"Creates a new object with modified columns.\n\n    Takes the same arguments as [`polars.DataFrame.with_columns`](https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.with_columns.html).\n\n    !!! warning\n        Only use this function if you know what you're doing. It is not recommended to manually modify the columns\n        within a Pyoframe object.\n    \"\"\"\n    return self.data.with_columns(*args, **kwargs)\n</code></pre>"},{"location":"reference/external/pandas.DataFrame.to_expr/","title":"pandas.DataFrame.to_expr","text":"<p>Same as <code>polars.DataFrame.to_expr</code>, but for pandas DataFrames.</p> Source code in <code>pyoframe/_monkey_patch.py</code> <pre><code>def pandas_df_to_expr(self: pd.DataFrame) -&gt; Expression:\n    \"\"\"Same as [`polars.DataFrame.to_expr`](./polars.DataFrame.to_expr.md), but for [pandas](https://pandas.pydata.org/) DataFrames.\"\"\"\n    return polars_df_to_expr(pl.from_pandas(self))\n</code></pre>"},{"location":"reference/external/pandas.Series.to_expr/","title":"pandas.Series.to_expr","text":"<p>Converts a pandas <code>Series</code> to a Pyoframe Expression, using the index for labels.</p> <p>See Special Functions for more details.</p> <p>Note that no equivalent method exists for Polars Series, as Polars does not support indexes.</p> Source code in <code>pyoframe/_monkey_patch.py</code> <pre><code>def pandas_series_to_expr(self: pd.Series) -&gt; Expression:\n    \"\"\"Converts a [pandas](https://pandas.pydata.org/) `Series` to a Pyoframe [Expression][pyoframe.Expression], using the index for labels.\n\n    See [Special Functions](../../learn/concepts/special-functions.md#dataframeto_expr) for more details.\n\n    Note that no equivalent method exists for Polars Series, as Polars does not support indexes.\n    \"\"\"\n    return pandas_df_to_expr(self.to_frame().reset_index())\n</code></pre>"},{"location":"reference/external/polars.DataFrame.to_expr/","title":"polars.DataFrame.to_expr","text":"<p>Converts a polars <code>DataFrame</code> to a Pyoframe Expression by using the last column for values and the previous columns as dimensions.</p> <p>See Special Functions for more details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3], \"y\": [4, 5, 6], \"z\": [7, 8, 9]})\n&gt;&gt;&gt; df.to_expr()\n&lt;Expression height=3 terms=3 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2506 y   \u2506 expression \u2502\n\u2502 (3) \u2506 (3) \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 7          \u2502\n\u2502 2   \u2506 5   \u2506 8          \u2502\n\u2502 3   \u2506 6   \u2506 9          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_monkey_patch.py</code> <pre><code>def polars_df_to_expr(self: pl.DataFrame) -&gt; Expression:\n    \"\"\"Converts a [polars](https://pola.rs/) `DataFrame` to a Pyoframe [Expression][pyoframe.Expression] by using the last column for values and the previous columns as dimensions.\n\n    See [Special Functions](../../learn/concepts/special-functions.md#dataframeto_expr) for more details.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3], \"y\": [4, 5, 6], \"z\": [7, 8, 9]})\n        &gt;&gt;&gt; df.to_expr()\n        &lt;Expression height=3 terms=3 type=constant&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x   \u2506 y   \u2506 expression \u2502\n        \u2502 (3) \u2506 (3) \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1   \u2506 4   \u2506 7          \u2502\n        \u2502 2   \u2506 5   \u2506 8          \u2502\n        \u2502 3   \u2506 6   \u2506 9          \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    name = self.columns[-1]\n    return Expression(\n        self.rename({name: COEF_KEY})\n        .drop_nulls(COEF_KEY)\n        .with_columns(pl.lit(CONST_TERM).alias(VAR_KEY)),\n        name=name,\n    )\n</code></pre>"},{"location":"reference/public/Config/","title":"Config","text":"<p>Default values listed at the end of the page.</p> <p>General settings for Pyoframe (for advanced users).</p> <p>Accessible via <code>pf.Config</code> (see examples below).</p> <p>Methods:</p> Name Description <code>reset_defaults</code> <p>Resets all configuration options to their default values.</p> <p>Attributes:</p> Name Type Description <code>default_solver</code> <code>SUPPORTED_SOLVER_TYPES | _Solver | Literal['raise', 'auto']</code> <p>The solver to use when Model is instantiated without specifying a solver.</p> <code>disable_extras_checks</code> <code>bool</code> <p>When <code>True</code>, improves performance by skipping checks for extra values (not recommended).</p> <code>enable_is_duplicated_expression_safety_check</code> <code>bool</code> <p>Setting for internal testing purposes only.</p> <code>float_to_str_precision</code> <code>int | None</code> <p>Number of decimal places to use when displaying mathematical expressions.</p> <code>id_dtype</code> <p>The Polars data type to use for variable and constraint IDs.</p> <code>integer_tolerance</code> <code>float</code> <p>Tolerance for checking if a floating point value is an integer.</p> <code>maintain_order</code> <code>bool</code> <p>Whether the order of variables, constraints, and mathematical terms is to be identical across runs.</p> <code>print_max_terms</code> <code>int</code> <p>Maximum number of terms to print in an expression before truncating it.</p> <code>print_polars_config</code> <code>Config</code> <p><code>polars.Config</code> object to use when printing dimensioned Pyoframe objects.</p> Source code in <code>pyoframe/_constants.py</code> <pre><code>def __init__(self):\n    self._settings = ConfigDefaults()\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.default_solver","title":"<code>default_solver: SUPPORTED_SOLVER_TYPES | _Solver | Literal['raise', 'auto']</code>","text":"<p>The solver to use when Model is instantiated without specifying a solver.</p> <p>If <code>auto</code>, Pyoframe will try to use whichever solver is installed. If <code>raise</code>, an exception will be raised when Model is instantiated without specifying a solver.</p> <p>We recommend that users specify their solver when instantiating Model rather than relying on this option.</p>"},{"location":"reference/public/Config/#pyoframe._constants._Config.disable_extras_checks","title":"<code>disable_extras_checks: bool</code>","text":"<p>When <code>True</code>, improves performance by skipping checks for extra values (not recommended).</p> <p>When <code>True</code>, checks for extra values are disabled which effectively means that all expressions are treated as if they contained <code>.keep_extras()</code> (unless <code>.drop_extras()</code> was applied).</p> <p>Warning</p> <p>This might improve performance, but it will suppress the errors that alert you of unexpected behaviors (learn more). Only consider enabling after you have thoroughly tested your code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; population = pl.DataFrame(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Montreal\"],\n...         \"pop\": [2_731_571, 631_486, 1_704_694],\n...     }\n... ).to_expr()\n&gt;&gt;&gt; population_influx = pl.DataFrame(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Montreal\"],\n...         \"influx\": [100_000, 50_000, None],\n...     }\n... ).to_expr()\n</code></pre> <p>Normally, an error warns users that the two expressions have conflicting labels:</p> <pre><code>&gt;&gt;&gt; population + population_influx\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot add the two expressions below because expression 1 has extra labels.\nExpression 1:   pop\nExpression 2:   influx\nExtra labels in expression 1:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 city     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Montreal \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nUse .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n</code></pre> <p>But if <code>Config.disable_extras_checks = True</code>, the error is suppressed and the sum is considered to be <code>population.keep_extras() + population_influx.keep_extras()</code>:</p> <pre><code>&gt;&gt;&gt; pf.Config.disable_extras_checks = True\n&gt;&gt;&gt; population + population_influx\n&lt;Expression height=3 terms=3 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 city      \u2506 expression \u2502\n\u2502 (3)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto   \u2506 2831571    \u2502\n\u2502 Vancouver \u2506 681486     \u2502\n\u2502 Montreal  \u2506 1704694    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.enable_is_duplicated_expression_safety_check","title":"<code>enable_is_duplicated_expression_safety_check: bool</code>","text":"<p>Setting for internal testing purposes only.</p> <p>When <code>True</code>, pyoframe checks that there are no bugs leading to duplicated terms in expressions.</p>"},{"location":"reference/public/Config/#pyoframe._constants._Config.float_to_str_precision","title":"<code>float_to_str_precision: int | None</code>","text":"<p>Number of decimal places to use when displaying mathematical expressions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Config.float_to_str_precision = 3\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; expr = 100.752038759 * m.X\n&gt;&gt;&gt; expr\n&lt;Expression terms=1 type=linear&gt;\n100.752\u00a0X\n&gt;&gt;&gt; pf.Config.float_to_str_precision = None\n&gt;&gt;&gt; expr\n&lt;Expression terms=1 type=linear&gt;\n100.752038759\u00a0X\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.id_dtype","title":"<code>id_dtype</code>","text":"<p>The Polars data type to use for variable and constraint IDs.</p> <p>Defaults to <code>pl.UInt32</code> which should be ideal for most users.</p> <p>Users with more than 4 billion variables or constraints can change this to <code>pl.UInt64</code>.</p> <p>Users concerned with memory usage and with fewer than 65k variables or constraints can change this to <code>pl.UInt16</code>.</p> <p>Warning</p> <p>Changing this setting after creating a model will lead to errors. You should only change this setting before creating any models.</p> <p>Examples:</p> <p>An error is automatically raised if the number of variables or constraints exceeds the chosen data type:</p> <pre><code>&gt;&gt;&gt; pf.Config.id_dtype = pl.UInt8\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; big_set = pf.Set(x=range(2**8 + 1))\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.constraint = m.X.over(\"x\") &lt;= big_set\nTraceback (most recent call last):\n...\nTypeError: Number of constraints exceeds the current data type (UInt8). Consider increasing the data type by changing Config.id_dtype.\n&gt;&gt;&gt; m.X_large = pf.Variable(big_set)\nTraceback (most recent call last):\n...\nTypeError: Number of variables exceeds the current data type (UInt8). Consider increasing the data type by changing Config.id_dtype.\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.integer_tolerance","title":"<code>integer_tolerance: float</code>","text":"<p>Tolerance for checking if a floating point value is an integer.</p> <p>Info</p> <p>For convenience, Pyoframe returns the solution of integer and binary variables as integers not floating point values. To do so, Pyoframe must convert the solver-provided floating point values to integers. To avoid unexpected rounding errors, Pyoframe uses this tolerance to check that the floating point result is an integer as expected. Overly tight tolerances can trigger unexpected errors. Setting the tolerance to zero disables the check.</p>"},{"location":"reference/public/Config/#pyoframe._constants._Config.maintain_order","title":"<code>maintain_order: bool</code>","text":"<p>Whether the order of variables, constraints, and mathematical terms is to be identical across runs.</p> <p>If <code>False</code>, performance is improved, but your results may vary every so slightly across runs since numerical errors can accumulate differently when the order of operations changes.</p>"},{"location":"reference/public/Config/#pyoframe._constants._Config.print_max_terms","title":"<code>print_max_terms: int</code>","text":"<p>Maximum number of terms to print in an expression before truncating it.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Config.print_max_terms = 3\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(pf.Set(x=range(100)), pf.Set(y=range(100)))\n&gt;&gt;&gt; m.X.sum(\"y\")\n&lt;Expression height=100 terms=10000 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x     \u2506 expression                    \u2502\n\u2502 (100) \u2506                               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 X[0,0] +\u00a0X[0,1] +\u00a0X[0,2] \u2026    \u2502\n\u2502 1     \u2506 X[1,0] +\u00a0X[1,1] +\u00a0X[1,2] \u2026    \u2502\n\u2502 2     \u2506 X[2,0] +\u00a0X[2,1] +\u00a0X[2,2] \u2026    \u2502\n\u2502 3     \u2506 X[3,0] +\u00a0X[3,1] +\u00a0X[3,2] \u2026    \u2502\n\u2502 4     \u2506 X[4,0] +\u00a0X[4,1] +\u00a0X[4,2] \u2026    \u2502\n\u2502 \u2026     \u2506 \u2026                             \u2502\n\u2502 95    \u2506 X[95,0] +\u00a0X[95,1] +\u00a0X[95,2] \u2026 \u2502\n\u2502 96    \u2506 X[96,0] +\u00a0X[96,1] +\u00a0X[96,2] \u2026 \u2502\n\u2502 97    \u2506 X[97,0] +\u00a0X[97,1] +\u00a0X[97,2] \u2026 \u2502\n\u2502 98    \u2506 X[98,0] +\u00a0X[98,1] +\u00a0X[98,2] \u2026 \u2502\n\u2502 99    \u2506 X[99,0] +\u00a0X[99,1] +\u00a0X[99,2] \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.X.sum()\n&lt;Expression terms=10000 type=linear&gt;\nX[0,0] +\u00a0X[0,1] +\u00a0X[0,2] \u2026\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.print_polars_config","title":"<code>print_polars_config: pl.Config</code>","text":"<p><code>polars.Config</code> object to use when printing dimensioned Pyoframe objects.</p> <p>Examples:</p> <p>For example, to limit the number of rows printed in a table, use <code>set_tbl_rows</code>:</p> <pre><code>&gt;&gt;&gt; pf.Config.print_polars_config.set_tbl_rows(5)\n&lt;class 'polars.config.Config'&gt;\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(pf.Set(x=range(100)))\n&gt;&gt;&gt; m.X\n&lt;Variable 'X' height=100&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x     \u2506 variable \u2502\n\u2502 (100) \u2506          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 X[0]     \u2502\n\u2502 1     \u2506 X[1]     \u2502\n\u2502 2     \u2506 X[2]     \u2502\n\u2502 \u2026     \u2506 \u2026        \u2502\n\u2502 98    \u2506 X[98]    \u2502\n\u2502 99    \u2506 X[99]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/public/Config/#pyoframe._constants._Config.reset_defaults","title":"<code>reset_defaults()</code>","text":"<p>Resets all configuration options to their default values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Config.disable_extras_checks\nFalse\n&gt;&gt;&gt; pf.Config.disable_extras_checks = True\n&gt;&gt;&gt; pf.Config.disable_extras_checks\nTrue\n&gt;&gt;&gt; pf.Config.reset_defaults()\n&gt;&gt;&gt; pf.Config.disable_extras_checks\nFalse\n</code></pre> Source code in <code>pyoframe/_constants.py</code> <pre><code>def reset_defaults(self):\n    \"\"\"Resets all configuration options to their default values.\n\n    Examples:\n        &gt;&gt;&gt; pf.Config.disable_extras_checks\n        False\n        &gt;&gt;&gt; pf.Config.disable_extras_checks = True\n        &gt;&gt;&gt; pf.Config.disable_extras_checks\n        True\n        &gt;&gt;&gt; pf.Config.reset_defaults()\n        &gt;&gt;&gt; pf.Config.disable_extras_checks\n        False\n    \"\"\"\n    self._settings = ConfigDefaults()\n</code></pre>"},{"location":"reference/public/Config/#default-values","title":"Default values","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.default_solver","title":"<code>default_solver: SUPPORTED_SOLVER_TYPES | _Solver | Literal['raise', 'auto'] = 'auto'</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.disable_extras_checks","title":"<code>disable_extras_checks: bool = False</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.enable_is_duplicated_expression_safety_check","title":"<code>enable_is_duplicated_expression_safety_check: bool = False</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.float_to_str_precision","title":"<code>float_to_str_precision: int | None = 5</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.id_dtype","title":"<code>id_dtype = pl.UInt32</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.integer_tolerance","title":"<code>integer_tolerance: float = 1e-08</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.maintain_order","title":"<code>maintain_order: bool = True</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.print_max_terms","title":"<code>print_max_terms: int = 5</code>","text":""},{"location":"reference/public/Config/#pyoframe._constants.ConfigDefaults.print_polars_config","title":"<code>print_polars_config: pl.Config = field(default_factory=(lambda: pl.Config(tbl_hide_column_data_types=True, tbl_hide_dataframe_shape=True, fmt_str_lengths=100, apply_on_context_enter=True)))</code>","text":""},{"location":"reference/public/Constraint/","title":"Constraint","text":"<p>               Bases: <code>BaseBlock</code></p> <p>An optimization constraint that can be added to a Model.</p> Implementation Note <p>Pyoframe simplifies constraints by moving all the constraint's mathematical terms to the left-hand side. This way, the right-hand side is always zero, and constraints only need to manage one expression.</p> Use <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code> operators to create constraints <p>Constraints should be created using the <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code> operators, not by directly calling the <code>Constraint</code> constructor.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expression</code> <p>The constraint's left-hand side expression.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required <p>Methods:</p> Name Description <code>estimated_size</code> <p>Returns the estimated size of the constraint.</p> <code>filter</code> <p>Syntactic sugar on <code>Constraint.lhs.data.filter()</code>, to help debugging.</p> <code>relax</code> <p>Allows the constraint to be violated at a <code>cost</code> and, optionally, up to a maximum.</p> <code>to_str</code> <p>Converts the constraint to a human-readable string, or several arranged in a table.</p> <p>Attributes:</p> Name Type Description <code>attr</code> <code>Container</code> <p>Allows reading and writing constraint attributes similarly to Model.attr.</p> <code>dual</code> <code>DataFrame | float</code> <p>Returns the constraint's dual values.</p> <code>lhs</code> <code>Expression</code> <code>sense</code> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(self, lhs: Expression, sense: ConstraintSense):\n    self.lhs: Expression = lhs\n    self._model = lhs._model\n    self.sense = sense\n    self._to_relax: FuncArgs | None = None\n    self._attr = Container(self._set_attribute, self._get_attribute)\n\n    dims = self.lhs.dimensions\n    data = (\n        pl.DataFrame()\n        if dims is None\n        else self.lhs.data.select(dims).unique(maintain_order=Config.maintain_order)\n    )\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.attr","title":"<code>attr: Container</code>","text":"<p>Allows reading and writing constraint attributes similarly to Model.attr.</p>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.dual","title":"<code>dual: pl.DataFrame | float</code>","text":"<p>Returns the constraint's dual values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.x = pf.Variable()\n&gt;&gt;&gt; m.y = pf.Variable()\n&gt;&gt;&gt; m.maximize = m.x - m.y\n</code></pre> <p>Notice that for every unit increase in the right-hand side, the objective only improves by 0.5.</p> <pre><code>&gt;&gt;&gt; m.constraint_x = 2 * m.x &lt;= 10\n&gt;&gt;&gt; m.constraint_y = 2 * m.y &gt;= 5\n&gt;&gt;&gt; m.optimize()\n</code></pre> <p>For every unit increase in the right-hand side of <code>constraint_x</code>, the objective improves by 0.5.</p> <pre><code>&gt;&gt;&gt; m.constraint_x.dual\n0.5\n</code></pre> <p>For every unit increase in the right-hand side of <code>constraint_y</code>, the objective worsens by 0.5.</p> <pre><code>&gt;&gt;&gt; m.constraint_y.dual\n-0.5\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.lhs","title":"<code>lhs: Expression = lhs</code>","text":""},{"location":"reference/public/Constraint/#pyoframe.Constraint.sense","title":"<code>sense = sense</code>","text":""},{"location":"reference/public/Constraint/#pyoframe.Constraint.estimated_size","title":"<code>estimated_size(*args, **kwargs)</code>","text":"<p>Returns the estimated size of the constraint.</p> <p>Includes the size of the underlying expression (<code>Constraint.lhs</code>).</p> <p>See <code>Expression.estimated_size</code> for details on signature and behavior.</p> <p>Examples:</p> <p>An dimensionless constraint has contains a 32 bit constraint id and, for each term, a 64 bit coefficient with a 32 bit variable id. For a two-term expression that is: (32 + 2 * (64 + 32)) = 224 bits = 28 bytes.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.x = pf.Variable()\n&gt;&gt;&gt; m.con = m.x &lt;= 4\n&gt;&gt;&gt; m.con.estimated_size()\n28\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def estimated_size(self, *args, **kwargs):\n    \"\"\"Returns the estimated size of the constraint.\n\n    Includes the size of the underlying expression (`Constraint.lhs`).\n\n    See [`Expression.estimated_size`][pyoframe.Expression.estimated_size] for details on signature and behavior.\n\n    Examples:\n        An dimensionless constraint has contains a 32 bit constraint id and, for each term, a 64 bit coefficient with a 32 bit variable id.\n        For a two-term expression that is: (32 + 2 * (64 + 32)) = 224 bits = 28 bytes.\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.x = pf.Variable()\n        &gt;&gt;&gt; m.con = m.x &lt;= 4\n        &gt;&gt;&gt; m.con.estimated_size()\n        28\n    \"\"\"\n    return super().estimated_size(*args, **kwargs) + self.lhs.estimated_size(\n        *args, **kwargs\n    )\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.filter","title":"<code>filter(*args, **kwargs) -&gt; pl.DataFrame</code>","text":"<p>Syntactic sugar on <code>Constraint.lhs.data.filter()</code>, to help debugging.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def filter(self, *args, **kwargs) -&gt; pl.DataFrame:\n    \"\"\"Syntactic sugar on `Constraint.lhs.data.filter()`, to help debugging.\"\"\"\n    return self.lhs.data.filter(*args, **kwargs)\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.relax","title":"<code>relax(cost: Operable, max: Operable | None = None) -&gt; Constraint</code>","text":"<p>Allows the constraint to be violated at a <code>cost</code> and, optionally, up to a maximum.</p> Warning <p><code>.relax()</code> must be called before the constraint is assigned to the Model (see examples below).</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Operable</code> <p>The cost of violating the constraint. Costs should be positive because Pyoframe will automatically make them negative for maximization problems.</p> required <code>max</code> <code>Operable | None</code> <p>The maximum value of the relaxation variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>The same constraint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.maximize = m.hours_day\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n16.0\n&gt;&gt;&gt; m.maximize += 2 * m.hours_day\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n19.0\n</code></pre> <p><code>relax</code> can only be called after the sense of the model has been defined.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\nTraceback (most recent call last):\n...\nValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n</code></pre> <p>One way to solve this is by setting the sense directly on the model. See how this works fine:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(sense=\"max\")\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n</code></pre> <p>And now an example with dimensions:</p> <pre><code>&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame(\n...     {\n...         \"project\": [\"A\", \"B\", \"C\"],\n...         \"cost_per_hour_underdelivered\": [10, 20, 30],\n...         \"hours_to_finish\": [9, 9, 9],\n...         \"max_underdelivered\": [1, 9, 9],\n...     }\n... )\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[\"project\"], lb=0)\n&gt;&gt;&gt; m.must_finish_project = (\n...     m.hours_spent\n...     &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n... ).relax(\n...     homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]],\n...     max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]],\n... )\n&gt;&gt;&gt; m.only_one_day = m.hours_spent.sum(\"project\") &lt;= 24\n&gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n&gt;&gt;&gt; m.only_one_day.relax(1)\nTraceback (most recent call last):\n...\nValueError: .relax() must be called before the Constraint is added to the model\n&gt;&gt;&gt; m.attr.Silent = True\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n-50.0\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 8.0      \u2502\n\u2502 B       \u2506 7.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def relax(self, cost: Operable, max: Operable | None = None) -&gt; Constraint:\n    \"\"\"Allows the constraint to be violated at a `cost` and, optionally, up to a maximum.\n\n    Warning:\n        `.relax()` must be called before the constraint is assigned to the [Model][pyoframe.Model] (see examples below).\n\n    Parameters:\n        cost:\n            The cost of violating the constraint. Costs should be positive because Pyoframe will automatically\n            make them negative for maximization problems.\n        max:\n            The maximum value of the relaxation variable.\n\n    Returns:\n        The same constraint\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.maximize = m.hours_day\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        16.0\n        &gt;&gt;&gt; m.maximize += 2 * m.hours_day\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        19.0\n\n        `relax` can only be called after the sense of the model has been defined.\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n\n        One way to solve this is by setting the sense directly on the model. See how this works fine:\n\n        &gt;&gt;&gt; m = pf.Model(sense=\"max\")\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n\n        And now an example with dimensions:\n\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame(\n        ...     {\n        ...         \"project\": [\"A\", \"B\", \"C\"],\n        ...         \"cost_per_hour_underdelivered\": [10, 20, 30],\n        ...         \"hours_to_finish\": [9, 9, 9],\n        ...         \"max_underdelivered\": [1, 9, 9],\n        ...     }\n        ... )\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[\"project\"], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = (\n        ...     m.hours_spent\n        ...     &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n        ... ).relax(\n        ...     homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]],\n        ...     max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]],\n        ... )\n        &gt;&gt;&gt; m.only_one_day = m.hours_spent.sum(\"project\") &lt;= 24\n        &gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n        &gt;&gt;&gt; m.only_one_day.relax(1)\n        Traceback (most recent call last):\n        ...\n        ValueError: .relax() must be called before the Constraint is added to the model\n        &gt;&gt;&gt; m.attr.Silent = True\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.maximize.value\n        -50.0\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 8.0      \u2502\n        \u2502 B       \u2506 7.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if self._has_ids:\n        raise ValueError(\n            \".relax() must be called before the Constraint is added to the model\"\n        )\n\n    m = self._model\n    if m is None:\n        self._to_relax = FuncArgs(args=[cost, max])\n        return self\n\n    var_name = f\"{self.name}_relaxation\"\n    assert not hasattr(m, var_name), (\n        \"Conflicting names, relaxation variable already exists on the model.\"\n    )\n    var = Variable(self, lb=0, ub=max)\n    setattr(m, var_name, var)\n\n    if self.sense == ConstraintSense.LE:\n        self.lhs -= var\n    elif self.sense == ConstraintSense.GE:\n        self.lhs += var\n    else:  # pragma: no cover\n        # TODO\n        raise NotImplementedError(\n            \"Relaxation for equalities has not yet been implemented. Submit a pull request!\"\n        )\n\n    penalty = var * cost\n    if self.dimensions:\n        penalty = penalty.sum()\n    if m.sense is None:\n        raise ValueError(\n            \"Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\"\n        )\n    elif m.sense == ObjSense.MAX:\n        penalty *= -1\n    if m.has_objective:\n        m.objective += penalty\n    else:\n        m.objective = penalty\n\n    return self\n</code></pre>"},{"location":"reference/public/Constraint/#pyoframe.Constraint.to_str","title":"<code>to_str(return_df: bool = False) -&gt; str | pl.DataFrame</code>","text":"<pre><code>to_str(return_df: Literal[False] = False) -&gt; str\n</code></pre><pre><code>to_str(return_df: Literal[True] = True) -&gt; pl.DataFrame\n</code></pre> <p>Converts the constraint to a human-readable string, or several arranged in a table.</p> <p>Long expressions are truncated according to <code>Config.print_max_terms</code> and <code>Config.print_polars_config</code>.</p> <p>Parameters:</p> Name Type Description Default <code>return_df</code> <code>bool</code> <p>If <code>True</code>, returns a DataFrame containing strings instead of the string representation of the DataFrame.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; x = pf.Set(x=range(1000))\n&gt;&gt;&gt; y = pf.Set(y=range(1000))\n&gt;&gt;&gt; m.V = pf.Variable(x, y)\n&gt;&gt;&gt; expr = 2 * m.V * m.V\n&gt;&gt;&gt; print((expr &lt;= 3).to_str())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x      \u2506 y      \u2506 constraint                     \u2502\n\u2502 (1000) \u2506 (1000) \u2506                                \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 0      \u2506 2\u00a0V[0,0] * V[0,0] &lt;=\u00a03         \u2502\n\u2502 0      \u2506 1      \u2506 2\u00a0V[0,1] * V[0,1] &lt;=\u00a03         \u2502\n\u2502 0      \u2506 2      \u2506 2\u00a0V[0,2] * V[0,2] &lt;=\u00a03         \u2502\n\u2502 0      \u2506 3      \u2506 2\u00a0V[0,3] * V[0,3] &lt;=\u00a03         \u2502\n\u2502 0      \u2506 4      \u2506 2\u00a0V[0,4] * V[0,4] &lt;=\u00a03         \u2502\n\u2502 \u2026      \u2506 \u2026      \u2506 \u2026                              \u2502\n\u2502 999    \u2506 995    \u2506 2\u00a0V[999,995] * V[999,995] &lt;=\u00a03 \u2502\n\u2502 999    \u2506 996    \u2506 2\u00a0V[999,996] * V[999,996] &lt;=\u00a03 \u2502\n\u2502 999    \u2506 997    \u2506 2\u00a0V[999,997] * V[999,997] &lt;=\u00a03 \u2502\n\u2502 999    \u2506 998    \u2506 2\u00a0V[999,998] * V[999,998] &lt;=\u00a03 \u2502\n\u2502 999    \u2506 999    \u2506 2\u00a0V[999,999] * V[999,999] &lt;=\u00a03 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr = expr.sum(\"x\")\n&gt;&gt;&gt; print((expr &gt;= 3).to_str())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 y      \u2506 constraint                                                                              \u2502\n\u2502 (1000) \u2506                                                                                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 2\u00a0V[0,0] * V[0,0] +2\u00a0V[1,0] * V[1,0] +2\u00a0V[2,0] * V[2,0] +2\u00a0V[3,0] * V[3,0] +2\u00a0V[4,0] *  \u2502\n\u2502        \u2506 V[4,0] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 1      \u2506 2\u00a0V[0,1] * V[0,1] +2\u00a0V[1,1] * V[1,1] +2\u00a0V[2,1] * V[2,1] +2\u00a0V[3,1] * V[3,1] +2\u00a0V[4,1] *  \u2502\n\u2502        \u2506 V[4,1] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 2      \u2506 2\u00a0V[0,2] * V[0,2] +2\u00a0V[1,2] * V[1,2] +2\u00a0V[2,2] * V[2,2] +2\u00a0V[3,2] * V[3,2] +2\u00a0V[4,2] *  \u2502\n\u2502        \u2506 V[4,2] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 3      \u2506 2\u00a0V[0,3] * V[0,3] +2\u00a0V[1,3] * V[1,3] +2\u00a0V[2,3] * V[2,3] +2\u00a0V[3,3] * V[3,3] +2\u00a0V[4,3] *  \u2502\n\u2502        \u2506 V[4,3] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 4      \u2506 2\u00a0V[0,4] * V[0,4] +2\u00a0V[1,4] * V[1,4] +2\u00a0V[2,4] * V[2,4] +2\u00a0V[3,4] * V[3,4] +2\u00a0V[4,4] *  \u2502\n\u2502        \u2506 V[4,4] \u2026 &gt;=\u00a03                                                                           \u2502\n\u2502 \u2026      \u2506 \u2026                                                                                       \u2502\n\u2502 995    \u2506 2\u00a0V[0,995] * V[0,995] +2\u00a0V[1,995] * V[1,995] +2\u00a0V[2,995] * V[2,995] +2\u00a0V[3,995] *       \u2502\n\u2502        \u2506 V[3,995] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2502 996    \u2506 2\u00a0V[0,996] * V[0,996] +2\u00a0V[1,996] * V[1,996] +2\u00a0V[2,996] * V[2,996] +2\u00a0V[3,996] *       \u2502\n\u2502        \u2506 V[3,996] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2502 997    \u2506 2\u00a0V[0,997] * V[0,997] +2\u00a0V[1,997] * V[1,997] +2\u00a0V[2,997] * V[2,997] +2\u00a0V[3,997] *       \u2502\n\u2502        \u2506 V[3,997] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2502 998    \u2506 2\u00a0V[0,998] * V[0,998] +2\u00a0V[1,998] * V[1,998] +2\u00a0V[2,998] * V[2,998] +2\u00a0V[3,998] *       \u2502\n\u2502        \u2506 V[3,998] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2502 999    \u2506 2\u00a0V[0,999] * V[0,999] +2\u00a0V[1,999] * V[1,999] +2\u00a0V[2,999] * V[2,999] +2\u00a0V[3,999] *       \u2502\n\u2502        \u2506 V[3,999] +2\u00a0V[4,99\u2026                                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr = expr.sum(\"y\")\n&gt;&gt;&gt; print((expr == 3).to_str())\n2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] +2\u00a0V[0,4] * V[0,4] \u2026 =\u00a03\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_str(self, return_df: bool = False) -&gt; str | pl.DataFrame:\n    \"\"\"Converts the constraint to a human-readable string, or several arranged in a table.\n\n    Long expressions are truncated according to [`Config.print_max_terms`][pyoframe._Config.print_max_terms] and [`Config.print_polars_config`][pyoframe._Config.print_polars_config].\n\n    Parameters:\n        return_df:\n            If `True`, returns a DataFrame containing strings instead of the string representation of the DataFrame.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; x = pf.Set(x=range(1000))\n        &gt;&gt;&gt; y = pf.Set(y=range(1000))\n        &gt;&gt;&gt; m.V = pf.Variable(x, y)\n        &gt;&gt;&gt; expr = 2 * m.V * m.V\n        &gt;&gt;&gt; print((expr &lt;= 3).to_str())\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x      \u2506 y      \u2506 constraint                     \u2502\n        \u2502 (1000) \u2506 (1000) \u2506                                \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0      \u2506 0      \u2506 2\u00a0V[0,0] * V[0,0] &lt;=\u00a03         \u2502\n        \u2502 0      \u2506 1      \u2506 2\u00a0V[0,1] * V[0,1] &lt;=\u00a03         \u2502\n        \u2502 0      \u2506 2      \u2506 2\u00a0V[0,2] * V[0,2] &lt;=\u00a03         \u2502\n        \u2502 0      \u2506 3      \u2506 2\u00a0V[0,3] * V[0,3] &lt;=\u00a03         \u2502\n        \u2502 0      \u2506 4      \u2506 2\u00a0V[0,4] * V[0,4] &lt;=\u00a03         \u2502\n        \u2502 \u2026      \u2506 \u2026      \u2506 \u2026                              \u2502\n        \u2502 999    \u2506 995    \u2506 2\u00a0V[999,995] * V[999,995] &lt;=\u00a03 \u2502\n        \u2502 999    \u2506 996    \u2506 2\u00a0V[999,996] * V[999,996] &lt;=\u00a03 \u2502\n        \u2502 999    \u2506 997    \u2506 2\u00a0V[999,997] * V[999,997] &lt;=\u00a03 \u2502\n        \u2502 999    \u2506 998    \u2506 2\u00a0V[999,998] * V[999,998] &lt;=\u00a03 \u2502\n        \u2502 999    \u2506 999    \u2506 2\u00a0V[999,999] * V[999,999] &lt;=\u00a03 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr = expr.sum(\"x\")\n        &gt;&gt;&gt; print((expr &gt;= 3).to_str())\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 y      \u2506 constraint                                                                              \u2502\n        \u2502 (1000) \u2506                                                                                         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0      \u2506 2\u00a0V[0,0] * V[0,0] +2\u00a0V[1,0] * V[1,0] +2\u00a0V[2,0] * V[2,0] +2\u00a0V[3,0] * V[3,0] +2\u00a0V[4,0] *  \u2502\n        \u2502        \u2506 V[4,0] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 1      \u2506 2\u00a0V[0,1] * V[0,1] +2\u00a0V[1,1] * V[1,1] +2\u00a0V[2,1] * V[2,1] +2\u00a0V[3,1] * V[3,1] +2\u00a0V[4,1] *  \u2502\n        \u2502        \u2506 V[4,1] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 2      \u2506 2\u00a0V[0,2] * V[0,2] +2\u00a0V[1,2] * V[1,2] +2\u00a0V[2,2] * V[2,2] +2\u00a0V[3,2] * V[3,2] +2\u00a0V[4,2] *  \u2502\n        \u2502        \u2506 V[4,2] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 3      \u2506 2\u00a0V[0,3] * V[0,3] +2\u00a0V[1,3] * V[1,3] +2\u00a0V[2,3] * V[2,3] +2\u00a0V[3,3] * V[3,3] +2\u00a0V[4,3] *  \u2502\n        \u2502        \u2506 V[4,3] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 4      \u2506 2\u00a0V[0,4] * V[0,4] +2\u00a0V[1,4] * V[1,4] +2\u00a0V[2,4] * V[2,4] +2\u00a0V[3,4] * V[3,4] +2\u00a0V[4,4] *  \u2502\n        \u2502        \u2506 V[4,4] \u2026 &gt;=\u00a03                                                                           \u2502\n        \u2502 \u2026      \u2506 \u2026                                                                                       \u2502\n        \u2502 995    \u2506 2\u00a0V[0,995] * V[0,995] +2\u00a0V[1,995] * V[1,995] +2\u00a0V[2,995] * V[2,995] +2\u00a0V[3,995] *       \u2502\n        \u2502        \u2506 V[3,995] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2502 996    \u2506 2\u00a0V[0,996] * V[0,996] +2\u00a0V[1,996] * V[1,996] +2\u00a0V[2,996] * V[2,996] +2\u00a0V[3,996] *       \u2502\n        \u2502        \u2506 V[3,996] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2502 997    \u2506 2\u00a0V[0,997] * V[0,997] +2\u00a0V[1,997] * V[1,997] +2\u00a0V[2,997] * V[2,997] +2\u00a0V[3,997] *       \u2502\n        \u2502        \u2506 V[3,997] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2502 998    \u2506 2\u00a0V[0,998] * V[0,998] +2\u00a0V[1,998] * V[1,998] +2\u00a0V[2,998] * V[2,998] +2\u00a0V[3,998] *       \u2502\n        \u2502        \u2506 V[3,998] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2502 999    \u2506 2\u00a0V[0,999] * V[0,999] +2\u00a0V[1,999] * V[1,999] +2\u00a0V[2,999] * V[2,999] +2\u00a0V[3,999] *       \u2502\n        \u2502        \u2506 V[3,999] +2\u00a0V[4,99\u2026                                                                     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr = expr.sum(\"y\")\n        &gt;&gt;&gt; print((expr == 3).to_str())\n        2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] +2\u00a0V[0,4] * V[0,4] \u2026 =\u00a03\n    \"\"\"\n    dims = self.dimensions\n    str_table = self.lhs.to_str(\n        include_const_term=False, return_df=True, str_col_name=\"constraint\"\n    )\n    rhs = self.lhs.constant_terms.with_columns(pl.col(COEF_KEY) * -1)\n    rhs = cast_coef_to_string(rhs, drop_ones=False, always_show_sign=False)\n    rhs = rhs.rename({COEF_KEY: \"rhs\"})\n    if dims:\n        constr_str = str_table.join(\n            rhs, on=dims, how=\"left\", maintain_order=\"left\", coalesce=True\n        )\n    else:\n        constr_str = pl.concat([str_table, rhs], how=\"horizontal\")\n    constr_str = constr_str.with_columns(\n        pl.concat_str(\"constraint\", pl.lit(f\" {self.sense.value}\u00a0\"), \"rhs\")\n    ).drop(\"rhs\")\n\n    if not return_df:\n        if self.dimensions is None:\n            constr_str = constr_str.item()\n        else:\n            constr_str = self._add_shape_to_columns(constr_str)\n            with Config.print_polars_config:\n                constr_str = repr(constr_str)\n\n    return constr_str\n</code></pre>"},{"location":"reference/public/Expression/","title":"Expression","text":"<p>               Bases: <code>BaseOperableBlock</code></p> <p>Represents a linear or quadratic mathematical expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame(\n...     {\n...         \"item\": [1, 1, 1, 2, 2],\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"cost\": [1, 2, 3, 4, 5],\n...     }\n... ).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.Time = pf.Variable(df.index)\n&gt;&gt;&gt; m.Size = pf.Variable(df.index)\n&gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n&gt;&gt;&gt; expr\n&lt;Expression height=5 terms=10 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 time \u2506 expression                   \u2502\n\u2502 (2)  \u2506 (3)  \u2506                              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 mon  \u2506 Time[1,mon] +\u00a0Size[1,mon]    \u2502\n\u2502 1    \u2506 tue  \u2506 2\u00a0Time[1,tue] +2\u00a0Size[1,tue] \u2502\n\u2502 1    \u2506 wed  \u2506 3\u00a0Time[1,wed] +3\u00a0Size[1,wed] \u2502\n\u2502 2    \u2506 mon  \u2506 4\u00a0Time[2,mon] +4\u00a0Size[2,mon] \u2502\n\u2502 2    \u2506 tue  \u2506 5\u00a0Time[2,tue] +5\u00a0Size[2,tue] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Methods:</p> Name Description <code>constant</code> <p>Creates a new expression equal to the given constant.</p> <code>degree</code> <p>Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).</p> <code>evaluate</code> <p>Computes the value of the expression using the variables' solutions.</p> <code>map</code> <p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <code>rolling_sum</code> <p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <code>sum</code> <p>Sums an expression over specified dimensions.</p> <code>sum_by</code> <p>Like <code>Expression.sum</code>, but the sum is taken over all dimensions except those specified in <code>by</code> (just like a <code>group_by().sum()</code> operation).</p> <code>to_expr</code> <p>Returns the expression itself.</p> <code>to_str</code> <p>Converts the expression to a human-readable string, or several arranged in a table.</p> <code>within</code> <p>Filters this expression to only include the dimensions within the provided set.</p> <p>Attributes:</p> Name Type Description <code>constant_terms</code> <code>DataFrame</code> <p>Returns all the constant terms in the expression.</p> <code>is_quadratic</code> <code>bool</code> <p>Returns <code>True</code> if the expression is quadratic, False otherwise.</p> <code>terms</code> <code>int</code> <p>The number of terms across all subexpressions.</p> <code>variable_terms</code> <code>DataFrame</code> <p>Returns all the non-constant terms in the expression.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(self, data: pl.DataFrame, name: str | None = None):\n    # Sanity checks, VAR_KEY and COEF_KEY must be present\n    assert VAR_KEY in data.columns, \"Missing variable column.\"\n    assert COEF_KEY in data.columns, \"Missing coefficient column.\"\n\n    # Sanity check no duplicates labels\n    if Config.enable_is_duplicated_expression_safety_check:\n        duplicated_mask = data.drop(COEF_KEY).is_duplicated()\n        # In theory this should never happen unless there's a bug in the library\n        if duplicated_mask.any():\n            duplicated_data = data.filter(duplicated_mask)\n            raise ValueError(\n                f\"Cannot create an expression with duplicate labels:\\n{duplicated_data}.\"\n            )\n\n    data = _simplify_expr_df(data)\n\n    if name is None:\n        warnings.warn(\n            \"Expression should be given a name to support troubleshooting.\",\n            UserWarning,\n        )\n\n        super().__init__(data)\n    else:\n        super().__init__(data, name=name)\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.constant_terms","title":"<code>constant_terms: pl.DataFrame</code>","text":"<p>Returns all the constant terms in the expression.</p>"},{"location":"reference/public/Expression/#pyoframe.Expression.is_quadratic","title":"<code>is_quadratic: bool</code>","text":"<p>Returns <code>True</code> if the expression is quadratic, False otherwise.</p> <p>Computes in O(1) since expressions are quadratic if and only if self.data contain the QUAD_VAR_KEY column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}) * m.v\n&gt;&gt;&gt; expr *= m.v\n&gt;&gt;&gt; expr.is_quadratic\nTrue\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.terms","title":"<code>terms: int</code>","text":"<p>The number of terms across all subexpressions.</p> <p>Expressions equal to zero count as one term.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable({\"t\": [1, 2]})\n&gt;&gt;&gt; coef = pl.DataFrame({\"t\": [1, 2], \"coef\": [0, 1]})\n&gt;&gt;&gt; coef * (m.v + 4)\n&lt;Expression height=2 terms=3 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 t   \u2506 expression \u2502\n\u2502 (2) \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0          \u2502\n\u2502 2   \u2506 4 +\u00a0v[2]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; (coef * (m.v + 4)).terms\n3\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.variable_terms","title":"<code>variable_terms: pl.DataFrame</code>","text":"<p>Returns all the non-constant terms in the expression.</p>"},{"location":"reference/public/Expression/#pyoframe.Expression.constant","title":"<code>constant(constant: int | float) -&gt; Expression</code>","text":"<p>Creates a new expression equal to the given constant.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Expression.constant(5)\n&lt;Expression terms=1 type=constant&gt;\n5\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@classmethod\ndef constant(cls, constant: int | float) -&gt; Expression:\n    \"\"\"Creates a new expression equal to the given constant.\n\n    Examples:\n        &gt;&gt;&gt; pf.Expression.constant(5)\n        &lt;Expression terms=1 type=constant&gt;\n        5\n    \"\"\"\n    return cls(\n        pl.DataFrame(\n            {\n                COEF_KEY: [constant],\n                VAR_KEY: [CONST_TERM],\n            },\n            schema={COEF_KEY: pl.Float64, VAR_KEY: Config.id_dtype},\n        ),\n        name=str(constant),\n    )\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.degree","title":"<code>degree(return_str: bool = False) -&gt; int | str</code>","text":"<pre><code>degree(return_str: Literal[False] = False) -&gt; int\n</code></pre><pre><code>degree(return_str: Literal[True] = True) -&gt; str\n</code></pre> <p>Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).</p> <p>Parameters:</p> Name Type Description Default <code>return_str</code> <code>bool</code> <p>If <code>True</code>, returns the degree as a string (<code>\"constant\"</code>, <code>\"linear\"</code>, or <code>\"quadratic\"</code>). If <code>False</code>, returns the degree as an integer (0, 1, or 2).</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v1 = pf.Variable()\n&gt;&gt;&gt; m.v2 = pf.Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n&gt;&gt;&gt; expr.degree()\n0\n&gt;&gt;&gt; expr *= m.v1\n&gt;&gt;&gt; expr.degree()\n1\n&gt;&gt;&gt; expr += (m.v2**2).over(\"dim1\")\n&gt;&gt;&gt; expr.degree()\n2\n&gt;&gt;&gt; expr.degree(return_str=True)\n'quadratic'\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def degree(self, return_str: bool = False) -&gt; int | str:\n    \"\"\"Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).\n\n    Parameters:\n        return_str: If `True`, returns the degree as a string (`\"constant\"`, `\"linear\"`, or `\"quadratic\"`).\n            If `False`, returns the degree as an integer (0, 1, or 2).\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v1 = pf.Variable()\n        &gt;&gt;&gt; m.v2 = pf.Variable()\n        &gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n        &gt;&gt;&gt; expr.degree()\n        0\n        &gt;&gt;&gt; expr *= m.v1\n        &gt;&gt;&gt; expr.degree()\n        1\n        &gt;&gt;&gt; expr += (m.v2**2).over(\"dim1\")\n        &gt;&gt;&gt; expr.degree()\n        2\n        &gt;&gt;&gt; expr.degree(return_str=True)\n        'quadratic'\n    \"\"\"\n    if self.is_quadratic:\n        return \"quadratic\" if return_str else 2\n    # TODO improve performance of .evaluate() by ensuring early exit if linear\n    elif (self.data.get_column(VAR_KEY) != CONST_TERM).any():\n        return \"linear\" if return_str else 1\n    else:\n        return \"constant\" if return_str else 0\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.evaluate","title":"<code>evaluate() -&gt; pl.DataFrame</code>","text":"<p>Computes the value of the expression using the variables' solutions.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A Polars <code>DataFrame</code> for dimensioned expressions a <code>float</code> for dimensionless expressions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, lb=10, ub=10)\n&gt;&gt;&gt; m.expr = 2 * m.X * m.X + 1\n</code></pre> <pre><code>&gt;&gt;&gt; m.expr.evaluate()\nTraceback (most recent call last):\n...\nValueError: Cannot evaluate the expression 'expr' before calling model.optimize().\n</code></pre> <pre><code>&gt;&gt;&gt; m.constant_expression = m.expr - 2 * m.X * m.X\n&gt;&gt;&gt; m.constant_expression.evaluate()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0      \u2502\n\u2502 2    \u2506 1.0      \u2502\n\u2502 3    \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.expr.evaluate()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 201.0    \u2502\n\u2502 2    \u2506 201.0    \u2502\n\u2502 3    \u2506 201.0    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; m.expr.sum().evaluate()\n603.0\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@unwrap_single_values\ndef evaluate(self) -&gt; pl.DataFrame:\n    \"\"\"Computes the value of the expression using the variables' solutions.\n\n    Returns:\n        A Polars `DataFrame` for dimensioned expressions a `float` for dimensionless expressions.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, lb=10, ub=10)\n        &gt;&gt;&gt; m.expr = 2 * m.X * m.X + 1\n\n        &gt;&gt;&gt; m.expr.evaluate()\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot evaluate the expression 'expr' before calling model.optimize().\n\n        &gt;&gt;&gt; m.constant_expression = m.expr - 2 * m.X * m.X\n        &gt;&gt;&gt; m.constant_expression.evaluate()\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 solution \u2502\n        \u2502 ---  \u2506 ---      \u2502\n        \u2502 i64  \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0      \u2502\n        \u2502 2    \u2506 1.0      \u2502\n        \u2502 3    \u2506 1.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.expr.evaluate()\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 solution \u2502\n        \u2502 ---  \u2506 ---      \u2502\n        \u2502 i64  \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 201.0    \u2502\n        \u2502 2    \u2506 201.0    \u2502\n        \u2502 3    \u2506 201.0    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; m.expr.sum().evaluate()\n        603.0\n\n    \"\"\"\n    assert self._model is not None, (\n        \"Expression must be added to the model to use .value\"\n    )\n\n    df = self.data.rename({COEF_KEY: SOLUTION_KEY})\n    sm = self._model.poi\n    attr = poi.VariableAttribute.Value\n\n    if self.degree() == 0:\n        df = df.drop(self._variable_columns)\n    elif (\n        self._model.attr.TerminationStatus\n        == poi.TerminationStatusCode.OPTIMIZE_NOT_CALLED\n    ):\n        raise ValueError(\n            f\"Cannot evaluate the expression '{self.name}' before calling model.optimize().\"\n        )\n    else:\n        for var_col in self._variable_columns:\n            values = [\n                sm.get_variable_attribute(poi.VariableIndex(v_id), attr)\n                for v_id in df.get_column(var_col).to_list()\n            ]\n\n            df = df.drop(var_col).with_columns(\n                pl.col(SOLUTION_KEY) * pl.Series(values, dtype=pl.Float64)\n            )\n\n    dims = self.dimensions\n    if dims is not None:\n        df = df.group_by(dims, maintain_order=Config.maintain_order)\n    return df.sum()\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.map","title":"<code>map(mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression</code>","text":"<p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <p>This is particularly useful to go from one type of dimensions to another. For example, to convert data that is indexed by city to data indexed by country (see example).</p> <p>Parameters:</p> Name Type Description Default <code>mapping_set</code> <code>SetTypes</code> <p>The set to map the expression to. This can be a DataFrame, Index, or another Set.</p> required <code>drop_shared_dims</code> <code>bool</code> <p>If <code>True</code>, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and     repeated rows are summed. If <code>False</code>, the shared dimensions are kept in the resulting expression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression containing the result of the mapping operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; pop_data = pl.DataFrame(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n...         \"year\": [2024, 2024, 2024],\n...         \"population\": [10, 2, 8],\n...     }\n... ).to_expr()\n&gt;&gt;&gt; cities_and_countries = pl.DataFrame(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n...         \"country\": [\"Canada\", \"Canada\", \"USA\"],\n...     }\n... )\n&gt;&gt;&gt; pop_data.map(cities_and_countries)\n&lt;Expression height=2 terms=2 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 year \u2506 country \u2506 expression \u2502\n\u2502 (1)  \u2506 (2)     \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024 \u2506 Canada  \u2506 12         \u2502\n\u2502 2024 \u2506 USA     \u2506 8          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n&lt;Expression height=3 terms=3 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 city      \u2506 year \u2506 country \u2506 expression \u2502\n\u2502 (3)       \u2506 (1)  \u2506 (2)     \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto   \u2506 2024 \u2506 Canada  \u2506 10         \u2502\n\u2502 Vancouver \u2506 2024 \u2506 Canada  \u2506 2          \u2502\n\u2502 Boston    \u2506 2024 \u2506 USA     \u2506 8          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def map(self, mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression:\n    \"\"\"Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.\n\n    This is particularly useful to go from one type of dimensions to another. For example, to convert data that\n    is indexed by city to data indexed by country (see example).\n\n    Parameters:\n        mapping_set:\n            The set to map the expression to. This can be a DataFrame, Index, or another Set.\n        drop_shared_dims:\n            If `True`, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and\n                repeated rows are summed.\n            If `False`, the shared dimensions are kept in the resulting expression.\n\n    Returns:\n        A new Expression containing the result of the mapping operation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; pop_data = pl.DataFrame(\n        ...     {\n        ...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n        ...         \"year\": [2024, 2024, 2024],\n        ...         \"population\": [10, 2, 8],\n        ...     }\n        ... ).to_expr()\n        &gt;&gt;&gt; cities_and_countries = pl.DataFrame(\n        ...     {\n        ...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n        ...         \"country\": [\"Canada\", \"Canada\", \"USA\"],\n        ...     }\n        ... )\n        &gt;&gt;&gt; pop_data.map(cities_and_countries)\n        &lt;Expression height=2 terms=2 type=constant&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 year \u2506 country \u2506 expression \u2502\n        \u2502 (1)  \u2506 (2)     \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 2024 \u2506 Canada  \u2506 12         \u2502\n        \u2502 2024 \u2506 USA     \u2506 8          \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n        &lt;Expression height=3 terms=3 type=constant&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 city      \u2506 year \u2506 country \u2506 expression \u2502\n        \u2502 (3)       \u2506 (1)  \u2506 (2)     \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Toronto   \u2506 2024 \u2506 Canada  \u2506 10         \u2502\n        \u2502 Vancouver \u2506 2024 \u2506 Canada  \u2506 2          \u2502\n        \u2502 Boston    \u2506 2024 \u2506 USA     \u2506 8          \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    mapping_set = Set(mapping_set)\n\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot use .map() on an expression with no dimensions.\")\n\n    mapping_dims = mapping_set.dimensions\n    if mapping_dims is None:\n        raise ValueError(\n            \"Cannot use .map() with a mapping set containing no dimensions.\"\n        )\n\n    shared_dims = [dim for dim in dims if dim in mapping_dims]\n    if not shared_dims:\n        raise ValueError(\n            f\"Cannot apply .map() as there are no shared dimensions between the expression (dims={self.dimensions}) and the mapping set (dims={mapping_set.dimensions}).\"\n        )\n\n    mapped_expression = self * mapping_set\n\n    if drop_shared_dims:\n        mapped_expression = mapped_expression.sum(*shared_dims)\n\n    mapped_expression.name = f\"{self.name}.map(\u2026)\"\n\n    return mapped_expression\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.rolling_sum","title":"<code>rolling_sum(over: str, window_size: int) -&gt; Expression</code>","text":"<p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <p>This method applies a rolling sum operation over the dimension specified by <code>over</code>, using a window defined by <code>window_size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>over</code> <code>str</code> <p>The name of the dimension (column) over which the rolling sum is calculated. This dimension must exist within the Expression's dimensions.</p> required <code>window_size</code> <code>int</code> <p>The size of the moving window in terms of number of records. The rolling sum is calculated over this many consecutive elements.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression instance containing the result of the rolling sum operation. This new Expression retains all dimensions (columns) of the original data, with the rolling sum applied over the specified dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; cost = pl.DataFrame(\n...     {\n...         \"item\": [1, 1, 1, 2, 2],\n...         \"time\": [1, 2, 3, 1, 2],\n...         \"cost\": [1, 2, 3, 4, 5],\n...     }\n... )\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n&gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n&lt;Expression height=5 terms=8 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 time \u2506 expression                       \u2502\n\u2502 (2)  \u2506 (3)  \u2506                                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 quantity[1,1]                    \u2502\n\u2502 1    \u2506 2    \u2506 quantity[1,1] +2\u00a0quantity[1,2]   \u2502\n\u2502 1    \u2506 3    \u2506 2\u00a0quantity[1,2] +3\u00a0quantity[1,3] \u2502\n\u2502 2    \u2506 1    \u2506 4\u00a0quantity[2,1]                  \u2502\n\u2502 2    \u2506 2    \u2506 4\u00a0quantity[2,1] +5\u00a0quantity[2,2] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef rolling_sum(self, over: str, window_size: int):\n    \"\"\"Calculates the rolling sum of the Expression over a specified window size for a given dimension.\n\n    This method applies a rolling sum operation over the dimension specified by `over`,\n    using a window defined by `window_size`.\n\n\n    Parameters:\n        over:\n            The name of the dimension (column) over which the rolling sum is calculated.\n            This dimension must exist within the Expression's dimensions.\n        window_size:\n            The size of the moving window in terms of number of records.\n            The rolling sum is calculated over this many consecutive elements.\n\n    Returns:\n        A new Expression instance containing the result of the rolling sum operation.\n            This new Expression retains all dimensions (columns) of the original data,\n            with the rolling sum applied over the specified dimension.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; cost = pl.DataFrame(\n        ...     {\n        ...         \"item\": [1, 1, 1, 2, 2],\n        ...         \"time\": [1, 2, 3, 1, 2],\n        ...         \"cost\": [1, 2, 3, 4, 5],\n        ...     }\n        ... )\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n        &gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n        &lt;Expression height=5 terms=8 type=linear&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 item \u2506 time \u2506 expression                       \u2502\n        \u2502 (2)  \u2506 (3)  \u2506                                  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1    \u2506 quantity[1,1]                    \u2502\n        \u2502 1    \u2506 2    \u2506 quantity[1,1] +2\u00a0quantity[1,2]   \u2502\n        \u2502 1    \u2506 3    \u2506 2\u00a0quantity[1,2] +3\u00a0quantity[1,3] \u2502\n        \u2502 2    \u2506 1    \u2506 4\u00a0quantity[2,1]                  \u2502\n        \u2502 2    \u2506 2    \u2506 4\u00a0quantity[2,1] +5\u00a0quantity[2,2] \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\n            \"Cannot use rolling_sum() with an expression with no dimensions.\"\n        )\n    assert over in dims, f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return pl.concat(\n        [\n            df.with_columns(pl.col(over).max())\n            for _, df in self.data.rolling(\n                index_column=over,\n                period=f\"{window_size}i\",\n                group_by=remaining_dims,\n            )\n        ]\n    )\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.sum","title":"<code>sum(*over: str) -&gt; Expression</code>","text":"<p>Sums an expression over specified dimensions.</p> <p>If no dimensions are specified, the sum is taken over all of the expression's dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = pl.DataFrame(\n...     {\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"place\": [\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Vancouver\",\n...             \"Vancouver\",\n...         ],\n...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n...     }\n... ).to_expr()\n&gt;&gt;&gt; expr\n&lt;Expression height=5 terms=5 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time \u2506 place     \u2506 expression \u2502\n\u2502 (3)  \u2506 (2)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 mon  \u2506 Toronto   \u2506 1000000    \u2502\n\u2502 tue  \u2506 Toronto   \u2506 3000000    \u2502\n\u2502 wed  \u2506 Toronto   \u2506 2000000    \u2502\n\u2502 mon  \u2506 Vancouver \u2506 1000000    \u2502\n\u2502 tue  \u2506 Vancouver \u2506 2000000    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr.sum(\"time\")\n&lt;Expression height=2 terms=2 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 place     \u2506 expression \u2502\n\u2502 (2)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto   \u2506 6000000    \u2502\n\u2502 Vancouver \u2506 3000000    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr.sum()\n&lt;Expression terms=1 type=constant&gt;\n9000000\n</code></pre> <p>If the given dimensions don't exist, an error will be raised:</p> <pre><code>&gt;&gt;&gt; expr.sum(\"city\")\nTraceback (most recent call last):\n...\nAssertionError: Cannot sum over ['city'] as it is not in ['time', 'place']\n</code></pre> See Also <p>pyoframe.Expression.sum_by for summing over all dimensions except those that are specified.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef sum(self, *over: str):\n    \"\"\"Sums an expression over specified dimensions.\n\n    If no dimensions are specified, the sum is taken over all of the expression's dimensions.\n\n    Examples:\n        &gt;&gt;&gt; expr = pl.DataFrame(\n        ...     {\n        ...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n        ...         \"place\": [\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Vancouver\",\n        ...             \"Vancouver\",\n        ...         ],\n        ...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n        ...     }\n        ... ).to_expr()\n        &gt;&gt;&gt; expr\n        &lt;Expression height=5 terms=5 type=constant&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time \u2506 place     \u2506 expression \u2502\n        \u2502 (3)  \u2506 (2)       \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 mon  \u2506 Toronto   \u2506 1000000    \u2502\n        \u2502 tue  \u2506 Toronto   \u2506 3000000    \u2502\n        \u2502 wed  \u2506 Toronto   \u2506 2000000    \u2502\n        \u2502 mon  \u2506 Vancouver \u2506 1000000    \u2502\n        \u2502 tue  \u2506 Vancouver \u2506 2000000    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr.sum(\"time\")\n        &lt;Expression height=2 terms=2 type=constant&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 place     \u2506 expression \u2502\n        \u2502 (2)       \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Toronto   \u2506 6000000    \u2502\n        \u2502 Vancouver \u2506 3000000    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr.sum()\n        &lt;Expression terms=1 type=constant&gt;\n        9000000\n\n        If the given dimensions don't exist, an error will be raised:\n\n        &gt;&gt;&gt; expr.sum(\"city\")\n        Traceback (most recent call last):\n        ...\n        AssertionError: Cannot sum over ['city'] as it is not in ['time', 'place']\n\n    See Also:\n        [pyoframe.Expression.sum_by][] for summing over all dimensions _except_ those that are specified.\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot sum a dimensionless expression.\")\n    if not over:\n        over = tuple(dims)\n    assert set(over) &lt;= set(dims), (\n        f\"Cannot sum over {list(over)} as it is not in {dims}\"\n    )\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return (\n        self.data.drop(over)\n        .group_by(\n            remaining_dims + self._variable_columns,\n            maintain_order=Config.maintain_order,\n        )\n        .sum()\n    )\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.sum_by","title":"<code>sum_by(*by: str)</code>","text":"<p>Like <code>Expression.sum</code>, but the sum is taken over all dimensions except those specified in <code>by</code> (just like a <code>group_by().sum()</code> operation).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = pl.DataFrame(\n...     {\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"place\": [\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Vancouver\",\n...             \"Vancouver\",\n...         ],\n...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n...     }\n... ).to_expr()\n&gt;&gt;&gt; expr\n&lt;Expression height=5 terms=5 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time \u2506 place     \u2506 expression \u2502\n\u2502 (3)  \u2506 (2)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 mon  \u2506 Toronto   \u2506 1000000    \u2502\n\u2502 tue  \u2506 Toronto   \u2506 3000000    \u2502\n\u2502 wed  \u2506 Toronto   \u2506 2000000    \u2502\n\u2502 mon  \u2506 Vancouver \u2506 1000000    \u2502\n\u2502 tue  \u2506 Vancouver \u2506 2000000    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; expr.sum_by(\"place\")\n&lt;Expression height=2 terms=2 type=constant&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 place     \u2506 expression \u2502\n\u2502 (2)       \u2506            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Toronto   \u2506 6000000    \u2502\n\u2502 Vancouver \u2506 3000000    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If the specified dimensions don't exist, an error will be raised:</p> <pre><code>&gt;&gt;&gt; expr.sum_by(\"city\")\nTraceback (most recent call last):\n...\nValueError: Cannot sum by ['city'] because it is not a valid dimension. The expression's dimensions are: ['time', 'place'].\n</code></pre> <pre><code>&gt;&gt;&gt; total_sum = expr.sum()\n&gt;&gt;&gt; total_sum.sum_by(\"time\")\nTraceback (most recent call last):\n...\nValueError: Cannot sum a dimensionless expression.\n</code></pre> See Also <p>pyoframe.Expression.sum for summing over specified dimensions.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def sum_by(self, *by: str):\n    \"\"\"Like [`Expression.sum`][pyoframe.Expression.sum], but the sum is taken over all dimensions *except* those specified in `by` (just like a `group_by().sum()` operation).\n\n    Examples:\n        &gt;&gt;&gt; expr = pl.DataFrame(\n        ...     {\n        ...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n        ...         \"place\": [\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Vancouver\",\n        ...             \"Vancouver\",\n        ...         ],\n        ...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n        ...     }\n        ... ).to_expr()\n        &gt;&gt;&gt; expr\n        &lt;Expression height=5 terms=5 type=constant&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time \u2506 place     \u2506 expression \u2502\n        \u2502 (3)  \u2506 (2)       \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 mon  \u2506 Toronto   \u2506 1000000    \u2502\n        \u2502 tue  \u2506 Toronto   \u2506 3000000    \u2502\n        \u2502 wed  \u2506 Toronto   \u2506 2000000    \u2502\n        \u2502 mon  \u2506 Vancouver \u2506 1000000    \u2502\n        \u2502 tue  \u2506 Vancouver \u2506 2000000    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; expr.sum_by(\"place\")\n        &lt;Expression height=2 terms=2 type=constant&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 place     \u2506 expression \u2502\n        \u2502 (2)       \u2506            \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Toronto   \u2506 6000000    \u2502\n        \u2502 Vancouver \u2506 3000000    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        If the specified dimensions don't exist, an error will be raised:\n\n        &gt;&gt;&gt; expr.sum_by(\"city\")\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot sum by ['city'] because it is not a valid dimension. The expression's dimensions are: ['time', 'place'].\n\n        &gt;&gt;&gt; total_sum = expr.sum()\n        &gt;&gt;&gt; total_sum.sum_by(\"time\")\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot sum a dimensionless expression.\n\n    See Also:\n        [pyoframe.Expression.sum][] for summing over specified dimensions.\n    \"\"\"\n    if not by:\n        raise ValueError(\"sum_by requires at least 1 argument.\")\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot sum a dimensionless expression.\")\n    if not set(by) &lt;= set(dims):\n        raise ValueError(\n            f\"Cannot sum by {list(set(by) - set(dims))} because it is not a valid dimension. The expression's dimensions are: {list(dims)}.\"\n        )\n    remaining_dims = [dim for dim in dims if dim not in by]\n    return self.sum(*remaining_dims)\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.to_expr","title":"<code>to_expr() -&gt; Expression</code>","text":"<p>Returns the expression itself.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    \"\"\"Returns the expression itself.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.to_str","title":"<code>to_str(str_col_name: str = 'expression', include_const_term: bool = True, return_df: bool = False) -&gt; str | pl.DataFrame</code>","text":"<pre><code>to_str(\n    str_col_name: str = \"expression\",\n    include_const_term: bool = True,\n    return_df: Literal[False] = False,\n) -&gt; str\n</code></pre><pre><code>to_str(\n    str_col_name: str = \"expression\",\n    include_const_term: bool = True,\n    return_df: Literal[True] = True,\n) -&gt; pl.DataFrame\n</code></pre> <p>Converts the expression to a human-readable string, or several arranged in a table.</p> <p>Long expressions are truncated according to <code>Config.print_max_terms</code> and <code>Config.print_polars_config</code>.</p> <p><code>str(pyoframe.Expression)</code> is equivalent to <code>pyoframe.Expression.to_str()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>str_col_name</code> <code>str</code> <p>The name of the column containing the string representation of the expression (dimensioned expressions only).</p> <code>'expression'</code> <code>include_const_term</code> <code>bool</code> <p>If <code>False</code>, constant terms are omitted from the string representation.</p> <code>True</code> <code>return_df</code> <code>bool</code> <p>If <code>True</code>, returns a DataFrame containing the human-readable strings instead of the DataFrame's string representation.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; x = pf.Set(x=range(1000))\n&gt;&gt;&gt; y = pf.Set(y=range(1000))\n&gt;&gt;&gt; m.V = pf.Variable(x, y)\n&gt;&gt;&gt; expr = 2 * m.V * m.V + 3\n&gt;&gt;&gt; print(expr.to_str())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x      \u2506 y      \u2506 expression                   \u2502\n\u2502 (1000) \u2506 (1000) \u2506                              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 0      \u2506 3 +2\u00a0V[0,0] * V[0,0]         \u2502\n\u2502 0      \u2506 1      \u2506 3 +2\u00a0V[0,1] * V[0,1]         \u2502\n\u2502 0      \u2506 2      \u2506 3 +2\u00a0V[0,2] * V[0,2]         \u2502\n\u2502 0      \u2506 3      \u2506 3 +2\u00a0V[0,3] * V[0,3]         \u2502\n\u2502 0      \u2506 4      \u2506 3 +2\u00a0V[0,4] * V[0,4]         \u2502\n\u2502 \u2026      \u2506 \u2026      \u2506 \u2026                            \u2502\n\u2502 999    \u2506 995    \u2506 3 +2\u00a0V[999,995] * V[999,995] \u2502\n\u2502 999    \u2506 996    \u2506 3 +2\u00a0V[999,996] * V[999,996] \u2502\n\u2502 999    \u2506 997    \u2506 3 +2\u00a0V[999,997] * V[999,997] \u2502\n\u2502 999    \u2506 998    \u2506 3 +2\u00a0V[999,998] * V[999,998] \u2502\n\u2502 999    \u2506 999    \u2506 3 +2\u00a0V[999,999] * V[999,999] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr = expr.sum(\"y\")\n&gt;&gt;&gt; print(expr.to_str())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x      \u2506 expression                                                                              \u2502\n\u2502 (1000) \u2506                                                                                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 3000 +2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] \u2026      \u2502\n\u2502 1      \u2506 3000 +2\u00a0V[1,0] * V[1,0] +2\u00a0V[1,1] * V[1,1] +2\u00a0V[1,2] * V[1,2] +2\u00a0V[1,3] * V[1,3] \u2026      \u2502\n\u2502 2      \u2506 3000 +2\u00a0V[2,0] * V[2,0] +2\u00a0V[2,1] * V[2,1] +2\u00a0V[2,2] * V[2,2] +2\u00a0V[2,3] * V[2,3] \u2026      \u2502\n\u2502 3      \u2506 3000 +2\u00a0V[3,0] * V[3,0] +2\u00a0V[3,1] * V[3,1] +2\u00a0V[3,2] * V[3,2] +2\u00a0V[3,3] * V[3,3] \u2026      \u2502\n\u2502 4      \u2506 3000 +2\u00a0V[4,0] * V[4,0] +2\u00a0V[4,1] * V[4,1] +2\u00a0V[4,2] * V[4,2] +2\u00a0V[4,3] * V[4,3] \u2026      \u2502\n\u2502 \u2026      \u2506 \u2026                                                                                       \u2502\n\u2502 995    \u2506 3000 +2\u00a0V[995,0] * V[995,0] +2\u00a0V[995,1] * V[995,1] +2\u00a0V[995,2] * V[995,2] +2\u00a0V[995,3] * \u2502\n\u2502        \u2506 V[995,3] \u2026                                                                              \u2502\n\u2502 996    \u2506 3000 +2\u00a0V[996,0] * V[996,0] +2\u00a0V[996,1] * V[996,1] +2\u00a0V[996,2] * V[996,2] +2\u00a0V[996,3] * \u2502\n\u2502        \u2506 V[996,3] \u2026                                                                              \u2502\n\u2502 997    \u2506 3000 +2\u00a0V[997,0] * V[997,0] +2\u00a0V[997,1] * V[997,1] +2\u00a0V[997,2] * V[997,2] +2\u00a0V[997,3] * \u2502\n\u2502        \u2506 V[997,3] \u2026                                                                              \u2502\n\u2502 998    \u2506 3000 +2\u00a0V[998,0] * V[998,0] +2\u00a0V[998,1] * V[998,1] +2\u00a0V[998,2] * V[998,2] +2\u00a0V[998,3] * \u2502\n\u2502        \u2506 V[998,3] \u2026                                                                              \u2502\n\u2502 999    \u2506 3000 +2\u00a0V[999,0] * V[999,0] +2\u00a0V[999,1] * V[999,1] +2\u00a0V[999,2] * V[999,2] +2\u00a0V[999,3] * \u2502\n\u2502        \u2506 V[999,3] \u2026                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; expr = expr.sum(\"x\")\n&gt;&gt;&gt; print(expr.to_str())\n3000000 +2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] \u2026\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_str(\n    self,\n    str_col_name: str = \"expression\",\n    include_const_term: bool = True,\n    return_df: bool = False,\n) -&gt; str | pl.DataFrame:\n    \"\"\"Converts the expression to a human-readable string, or several arranged in a table.\n\n    Long expressions are truncated according to [`Config.print_max_terms`][pyoframe._Config.print_max_terms] and [`Config.print_polars_config`][pyoframe._Config.print_polars_config].\n\n    `str(pyoframe.Expression)` is equivalent to `pyoframe.Expression.to_str()`.\n\n    Parameters:\n        str_col_name:\n            The name of the column containing the string representation of the expression (dimensioned expressions only).\n        include_const_term:\n            If `False`, constant terms are omitted from the string representation.\n        return_df:\n            If `True`, returns a DataFrame containing the human-readable strings instead of the DataFrame's string representation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; x = pf.Set(x=range(1000))\n        &gt;&gt;&gt; y = pf.Set(y=range(1000))\n        &gt;&gt;&gt; m.V = pf.Variable(x, y)\n        &gt;&gt;&gt; expr = 2 * m.V * m.V + 3\n        &gt;&gt;&gt; print(expr.to_str())\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x      \u2506 y      \u2506 expression                   \u2502\n        \u2502 (1000) \u2506 (1000) \u2506                              \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0      \u2506 0      \u2506 3 +2\u00a0V[0,0] * V[0,0]         \u2502\n        \u2502 0      \u2506 1      \u2506 3 +2\u00a0V[0,1] * V[0,1]         \u2502\n        \u2502 0      \u2506 2      \u2506 3 +2\u00a0V[0,2] * V[0,2]         \u2502\n        \u2502 0      \u2506 3      \u2506 3 +2\u00a0V[0,3] * V[0,3]         \u2502\n        \u2502 0      \u2506 4      \u2506 3 +2\u00a0V[0,4] * V[0,4]         \u2502\n        \u2502 \u2026      \u2506 \u2026      \u2506 \u2026                            \u2502\n        \u2502 999    \u2506 995    \u2506 3 +2\u00a0V[999,995] * V[999,995] \u2502\n        \u2502 999    \u2506 996    \u2506 3 +2\u00a0V[999,996] * V[999,996] \u2502\n        \u2502 999    \u2506 997    \u2506 3 +2\u00a0V[999,997] * V[999,997] \u2502\n        \u2502 999    \u2506 998    \u2506 3 +2\u00a0V[999,998] * V[999,998] \u2502\n        \u2502 999    \u2506 999    \u2506 3 +2\u00a0V[999,999] * V[999,999] \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr = expr.sum(\"y\")\n        &gt;&gt;&gt; print(expr.to_str())\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x      \u2506 expression                                                                              \u2502\n        \u2502 (1000) \u2506                                                                                         \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0      \u2506 3000 +2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] \u2026      \u2502\n        \u2502 1      \u2506 3000 +2\u00a0V[1,0] * V[1,0] +2\u00a0V[1,1] * V[1,1] +2\u00a0V[1,2] * V[1,2] +2\u00a0V[1,3] * V[1,3] \u2026      \u2502\n        \u2502 2      \u2506 3000 +2\u00a0V[2,0] * V[2,0] +2\u00a0V[2,1] * V[2,1] +2\u00a0V[2,2] * V[2,2] +2\u00a0V[2,3] * V[2,3] \u2026      \u2502\n        \u2502 3      \u2506 3000 +2\u00a0V[3,0] * V[3,0] +2\u00a0V[3,1] * V[3,1] +2\u00a0V[3,2] * V[3,2] +2\u00a0V[3,3] * V[3,3] \u2026      \u2502\n        \u2502 4      \u2506 3000 +2\u00a0V[4,0] * V[4,0] +2\u00a0V[4,1] * V[4,1] +2\u00a0V[4,2] * V[4,2] +2\u00a0V[4,3] * V[4,3] \u2026      \u2502\n        \u2502 \u2026      \u2506 \u2026                                                                                       \u2502\n        \u2502 995    \u2506 3000 +2\u00a0V[995,0] * V[995,0] +2\u00a0V[995,1] * V[995,1] +2\u00a0V[995,2] * V[995,2] +2\u00a0V[995,3] * \u2502\n        \u2502        \u2506 V[995,3] \u2026                                                                              \u2502\n        \u2502 996    \u2506 3000 +2\u00a0V[996,0] * V[996,0] +2\u00a0V[996,1] * V[996,1] +2\u00a0V[996,2] * V[996,2] +2\u00a0V[996,3] * \u2502\n        \u2502        \u2506 V[996,3] \u2026                                                                              \u2502\n        \u2502 997    \u2506 3000 +2\u00a0V[997,0] * V[997,0] +2\u00a0V[997,1] * V[997,1] +2\u00a0V[997,2] * V[997,2] +2\u00a0V[997,3] * \u2502\n        \u2502        \u2506 V[997,3] \u2026                                                                              \u2502\n        \u2502 998    \u2506 3000 +2\u00a0V[998,0] * V[998,0] +2\u00a0V[998,1] * V[998,1] +2\u00a0V[998,2] * V[998,2] +2\u00a0V[998,3] * \u2502\n        \u2502        \u2506 V[998,3] \u2026                                                                              \u2502\n        \u2502 999    \u2506 3000 +2\u00a0V[999,0] * V[999,0] +2\u00a0V[999,1] * V[999,1] +2\u00a0V[999,2] * V[999,2] +2\u00a0V[999,3] * \u2502\n        \u2502        \u2506 V[999,3] \u2026                                                                              \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; expr = expr.sum(\"x\")\n        &gt;&gt;&gt; print(expr.to_str())\n        3000000 +2\u00a0V[0,0] * V[0,0] +2\u00a0V[0,1] * V[0,1] +2\u00a0V[0,2] * V[0,2] +2\u00a0V[0,3] * V[0,3] \u2026\n\n    \"\"\"\n    # TODO consider optimizing using LazyFrames since .head() could maybe be automatically pushed up the chain of operations.\n    data = self.data if include_const_term else self.variable_terms\n    data = cast_coef_to_string(data)\n\n    for var_col in self._variable_columns:\n        temp_var_column = f\"{var_col}_temp\"\n        if self._model is not None and self._model._var_map is not None:\n            data = self._model._var_map.apply(\n                data, to_col=temp_var_column, id_col=var_col\n            )\n        else:\n            data = data.with_columns(\n                pl.concat_str(pl.lit(\"x\"), var_col).alias(temp_var_column)\n            )\n        data = data.with_columns(\n            pl.when(pl.col(var_col) == CONST_TERM)\n            .then(pl.lit(\"\"))\n            .otherwise(temp_var_column)\n            .alias(var_col)\n        ).drop(temp_var_column)\n    if self.is_quadratic:\n        data = data.with_columns(\n            pl.when(pl.col(QUAD_VAR_KEY) == \"\")\n            .then(pl.col(VAR_KEY))\n            .otherwise(pl.concat_str(VAR_KEY, pl.lit(\" * \"), pl.col(QUAD_VAR_KEY)))\n            .alias(VAR_KEY)\n        ).drop(QUAD_VAR_KEY)\n\n    dimensions = self.dimensions\n\n    # Create a string for each term\n    data = data.with_columns(\n        pl.concat_str(\n            COEF_KEY,\n            pl.lit(\"\u00a0\"),\n            VAR_KEY,\n        )\n        .str.strip_chars(characters=\" \u00a0\")\n        .alias(str_col_name)\n    ).drop(COEF_KEY, VAR_KEY)\n\n    if dimensions is not None:\n        data = data.group_by(dimensions, maintain_order=Config.maintain_order).agg(\n            pl.concat_str(\n                pl.col(str_col_name)\n                .head(Config.print_max_terms)\n                .str.join(delimiter=\" \"),\n                pl.when(pl.len() &gt; Config.print_max_terms)\n                .then(pl.lit(\" \u2026\"))\n                .otherwise(pl.lit(\"\")),\n            )\n        )\n    else:\n        truncate = data.height &gt; Config.print_max_terms\n        if truncate:\n            data = data.head(Config.print_max_terms)\n\n        data = data.select(pl.col(str_col_name).str.join(delimiter=\" \"))\n\n        if truncate:\n            data = data.with_columns(\n                pl.concat_str(pl.col(str_col_name), pl.lit(\" \u2026\"))\n            )\n\n    # Remove leading +\n    data = data.with_columns(pl.col(str_col_name).str.strip_chars(characters=\" \u00a0+\"))\n\n    if not return_df:\n        if dimensions is None and not self._allowed_new_dims:\n            data = data.item()\n        else:\n            data = self._add_shape_to_columns(data)\n            data = self._add_allowed_new_dims_to_df(data)\n            with Config.print_polars_config:\n                data = repr(data)\n\n    return data\n</code></pre>"},{"location":"reference/public/Expression/#pyoframe.Expression.within","title":"<code>within(set: SetTypes) -&gt; Expression</code>","text":"<p>Filters this expression to only include the dimensions within the provided set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; general_expr = pd.DataFrame(\n...     {\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}\n... ).to_expr()\n&gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n&gt;&gt;&gt; general_expr.within(filter_expr).data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0     \u2506 0             \u2502\n\u2502 3    \u2506 3.0     \u2506 0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef within(self, set: SetTypes):\n    \"\"\"Filters this expression to only include the dimensions within the provided set.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; general_expr = pd.DataFrame(\n        ...     {\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}\n        ... ).to_expr()\n        &gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n        &gt;&gt;&gt; general_expr.within(filter_expr).data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0     \u2506 0             \u2502\n        \u2502 3    \u2506 3.0     \u2506 0             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df: pl.DataFrame = Set(set).data\n    set_dims = _get_dimensions(df)\n    assert set_dims is not None, (\n        \"Cannot use .within() with a set with no dimensions.\"\n    )\n    dims = self.dimensions\n    assert dims is not None, (\n        \"Cannot use .within() with an expression with no dimensions.\"\n    )\n    dims_in_common = [dim for dim in dims if dim in set_dims]\n    by_dims = df.select(dims_in_common).unique(maintain_order=Config.maintain_order)\n    return self.data.join(\n        by_dims,\n        on=dims_in_common,\n        maintain_order=\"left\" if Config.maintain_order else None,\n    )\n</code></pre>"},{"location":"reference/public/Model/","title":"Model","text":"<p>The founding block of any Pyoframe optimization model onto which variables, constraints, and an objective can be added.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>SUPPORTED_SOLVER_TYPES | _Solver | None</code> <p>The solver to use. If <code>None</code>, Pyoframe will try to use whichever solver is installed (unless Config.default_solver was changed from its default value of <code>auto</code>).</p> <code>None</code> <code>solver_env</code> <code>dict[str, str] | None</code> <p>Gurobi only: a dictionary of parameters to set when creating the Gurobi environment.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>The name of the model. Currently it is not used for much.</p> <code>None</code> <code>solver_uses_variable_names</code> <code>bool</code> <p>If <code>True</code>, the solver will use your custom variable names in its outputs (e.g. during <code>Model.write()</code>). This can be useful for debugging <code>.lp</code>, <code>.sol</code>, and <code>.ilp</code> files, but may worsen performance.</p> <code>False</code> <code>print_uses_variable_names</code> <code>bool</code> <p>If <code>True</code>, pyoframe will use your custom variables names when printing elements of the model to the console. This is useful for debugging, but may slightly worsen performance.</p> <code>True</code> <code>sense</code> <code>ObjSense | ObjSenseValue | None</code> <p>Either \"min\" or \"max\". Indicates whether it's a minimization or maximization problem. Typically, this parameter can be omitted (<code>None</code>) as it will automatically be set when the objective is set using <code>.minimize</code> or <code>.maximize</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.my_constraint = m.X &lt;= 10\n&gt;&gt;&gt; m\n&lt;Model vars=1 constrs=1 has_objective=False solver=gurobi&gt;\n</code></pre> <p>Use <code>solver_env</code> to, for example, connect to a Gurobi Compute Server:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\n...     \"gurobi\",\n...     solver_env=dict(ComputeServer=\"myserver\", ServerPassword=\"mypassword\"),\n... )\nTraceback (most recent call last):\n...\nRuntimeError: Could not resolve host: myserver (code 6, command POST http://myserver/api/v1/cluster/jobs)\n</code></pre> <p>Methods:</p> Name Description <code>compute_IIS</code> <p>Gurobi and COPT only: Computes the Irreducible Infeasible Set (IIS) of the model.</p> <code>convert_to_fixed</code> <p>Gurobi only: Converts a mixed integer program into a continuous one by fixing all the non-continuous variables to their solution values.</p> <code>dispose</code> <p>Disposes of the model and cleans up the solver environment.</p> <code>optimize</code> <p>Optimizes the model using your selected solver (e.g. Gurobi, HiGHS).</p> <code>write</code> <p>Outputs the model or the solution to a file (e.g. a <code>.lp</code>, <code>.sol</code>, <code>.mps</code>, or <code>.ilp</code> file).</p> <p>Attributes:</p> Name Type Description <code>attr</code> <code>Container</code> <p>An object that allows reading and writing model attributes.</p> <code>binary_variables</code> <code>Generator[Variable]</code> <p>Returns the model's binary variables.</p> <code>constraints</code> <code>list[Constraint]</code> <p>Returns the model's constraints.</p> <code>has_objective</code> <code>bool</code> <p>Returns whether the model's objective has been defined.</p> <code>integer_variables</code> <code>Generator[Variable]</code> <p>Returns the model's integer variables.</p> <code>maximize</code> <code>Objective | None</code> <p>Sets or gets the model's objective for maximization problems.</p> <code>minimize</code> <code>Objective | None</code> <p>Sets or gets the model's objective for minimization problems.</p> <code>name</code> <code>str | None</code> <code>objective</code> <code>Objective</code> <p>Returns the model's objective.</p> <code>params</code> <code>Container</code> <p>An object that allows reading and writing solver-specific parameters.</p> <code>poi</code> <p>The underlying PyOptInterface model used to interact with the solver.</p> <code>sense</code> <code>ObjSense | None</code> <code>solver_name</code> <code>str</code> <code>solver_uses_variable_names</code> <p>Whether to pass human-readable variable names to the solver.</p> <code>variables</code> <code>list[Variable]</code> <p>Returns a list of the model's variables.</p> Source code in <code>pyoframe/_model.py</code> <pre><code>def __init__(\n    self,\n    solver: SUPPORTED_SOLVER_TYPES | _Solver | None = None,\n    solver_env: dict[str, str] | None = None,\n    *,\n    name: str | None = None,\n    solver_uses_variable_names: bool = False,\n    print_uses_variable_names: bool = True,\n    sense: ObjSense | ObjSenseValue | None = None,\n):\n    self._poi, self.solver = Model._create_poi_model(solver, solver_env)\n    self.solver_name: str = self.solver.name\n    self._variables: list[Variable] = []\n    self._constraints: list[Constraint] = []\n    self.sense: ObjSense | None = ObjSense(sense) if sense is not None else None\n    self._objective: Objective | None = None\n    self._var_map = NamedVariableMapper() if print_uses_variable_names else None\n    self.name: str | None = name\n\n    self._params = Container(self._set_param, self._get_param)\n    self._attr = Container(self._set_attr, self._get_attr)\n    self._solver_uses_variable_names = solver_uses_variable_names\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.attr","title":"<code>attr: Container</code>","text":"<p>An object that allows reading and writing model attributes.</p> <p>Several model attributes are common across all solvers making it easy to switch between solvers (see supported attributes for Gurobi, HiGHS, Ipopt), and COPT.</p> <p>We additionally support all of Gurobi's attributes when using Gurobi.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable(lb=1, ub=1, vtype=\"integer\")\n&gt;&gt;&gt; m.attr.Silent = True  # Prevent solver output from being printed\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus\n&lt;TerminationStatusCode.OPTIMAL: 2&gt;\n</code></pre> <p>Some attributes, like <code>NumVars</code>, are solver-specific.</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"gurobi\")\n&gt;&gt;&gt; m.attr.NumConstrs\n0\n&gt;&gt;&gt; m = pf.Model(\"highs\")\n&gt;&gt;&gt; m.attr.NumConstrs\nTraceback (most recent call last):\n...\nKeyError: 'NumConstrs'\n</code></pre> See Also <p>Variable.attr for setting variable attributes and Constraint.attr for setting constraint attributes.</p>"},{"location":"reference/public/Model/#pyoframe.Model.binary_variables","title":"<code>binary_variables: Generator[Variable]</code>","text":"<p>Returns the model's binary variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.binary_variables))\n1\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.constraints","title":"<code>constraints: list[Constraint]</code>","text":"<p>Returns the model's constraints.</p>"},{"location":"reference/public/Model/#pyoframe.Model.has_objective","title":"<code>has_objective: bool</code>","text":"<p>Returns whether the model's objective has been defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.has_objective\nFalse\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.maximize = m.X\n&gt;&gt;&gt; m.has_objective\nTrue\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.integer_variables","title":"<code>integer_variables: Generator[Variable]</code>","text":"<p>Returns the model's integer variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.INTEGER)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.integer_variables))\n1\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.maximize","title":"<code>maximize: Objective | None</code>","text":"<p>Sets or gets the model's objective for maximization problems.</p>"},{"location":"reference/public/Model/#pyoframe.Model.minimize","title":"<code>minimize: Objective | None</code>","text":"<p>Sets or gets the model's objective for minimization problems.</p>"},{"location":"reference/public/Model/#pyoframe.Model.name","title":"<code>name: str | None = name</code>","text":""},{"location":"reference/public/Model/#pyoframe.Model.objective","title":"<code>objective: Objective</code>","text":"<p>Returns the model's objective.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the objective has not been defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.objective\nTraceback (most recent call last):\n...\nValueError: Objective is not defined.\n&gt;&gt;&gt; m.maximize = m.X\n&gt;&gt;&gt; m.objective\n&lt;Objective terms=1 type=linear&gt;\nX\n</code></pre> See Also <p><code>Model.has_objective</code></p>"},{"location":"reference/public/Model/#pyoframe.Model.params","title":"<code>params: Container</code>","text":"<p>An object that allows reading and writing solver-specific parameters.</p> <p>See the list of available parameters for Gurobi, HiGHS, Ipopt, and COPT.</p> <p>Examples:</p> <p>For example, if you'd like to use Gurobi's barrier method, you can set the <code>Method</code> parameter:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"gurobi\")\n&gt;&gt;&gt; m.params.Method = 2\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.poi","title":"<code>poi</code>","text":"<p>The underlying PyOptInterface model used to interact with the solver.</p> <p>Modifying the underlying model directly is not recommended and may lead to unexpected behaviors.</p>"},{"location":"reference/public/Model/#pyoframe.Model.sense","title":"<code>sense: ObjSense | None = ObjSense(sense) if sense is not None else None</code>","text":""},{"location":"reference/public/Model/#pyoframe.Model.solver_name","title":"<code>solver_name: str = self.solver.name</code>","text":""},{"location":"reference/public/Model/#pyoframe.Model.solver_uses_variable_names","title":"<code>solver_uses_variable_names</code>","text":"<p>Whether to pass human-readable variable names to the solver.</p>"},{"location":"reference/public/Model/#pyoframe.Model.variables","title":"<code>variables: list[Variable]</code>","text":"<p>Returns a list of the model's variables.</p>"},{"location":"reference/public/Model/#pyoframe.Model.compute_IIS","title":"<code>compute_IIS()</code>","text":"<p>Gurobi and COPT only: Computes the Irreducible Infeasible Set (IIS) of the model.</p> <p>Gurobi and COPT only</p> <p>This method only works with the Gurobi and COPT solver. Open an issue if you'd like to see support for other solvers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"gurobi\")\n&gt;&gt;&gt; m.X = pf.Variable(lb=0, ub=2)\n&gt;&gt;&gt; m.Y = pf.Variable(lb=0, ub=2)\n&gt;&gt;&gt; m.bad_constraint = m.X &gt;= 3\n&gt;&gt;&gt; m.minimize = m.X + m.Y\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus\n&lt;TerminationStatusCode.INFEASIBLE: 3&gt;\n&gt;&gt;&gt; m.bad_constraint.attr.IIS\nTraceback (most recent call last):\n...\nRuntimeError: Unable to retrieve attribute 'IISConstr'\n&gt;&gt;&gt; m.compute_IIS()\n&gt;&gt;&gt; m.bad_constraint.attr.IIS\nTrue\n</code></pre> Source code in <code>pyoframe/_model.py</code> <pre><code>@for_solvers(\"gurobi\", \"copt\")\ndef compute_IIS(self):\n    \"\"\"Gurobi and COPT only: Computes the Irreducible Infeasible Set (IIS) of the model.\n\n    !!! warning \"Gurobi and COPT only\"\n        This method only works with the Gurobi and COPT solver. Open an issue if you'd like to see support for other solvers.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model(\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.Y = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.bad_constraint = m.X &gt;= 3\n        &gt;&gt;&gt; m.minimize = m.X + m.Y\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.attr.TerminationStatus\n        &lt;TerminationStatusCode.INFEASIBLE: 3&gt;\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        Traceback (most recent call last):\n        ...\n        RuntimeError: Unable to retrieve attribute 'IISConstr'\n        &gt;&gt;&gt; m.compute_IIS()\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        True\n    \"\"\"\n    self.poi.computeIIS()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.convert_to_fixed","title":"<code>convert_to_fixed() -&gt; None</code>","text":"<p>Gurobi only: Converts a mixed integer program into a continuous one by fixing all the non-continuous variables to their solution values.</p> <p>Gurobi only</p> <p>This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"gurobi\")\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0)\n&gt;&gt;&gt; m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0)\n&gt;&gt;&gt; m.Z = pf.Variable(lb=0)\n&gt;&gt;&gt; m.my_constraint = m.X + m.Y + m.Z &lt;= 10\n&gt;&gt;&gt; m.maximize = 3 * m.X + 2 * m.Y + m.Z\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.X.solution, m.Y.solution, m.Z.solution\n(1, 9, 0.0)\n&gt;&gt;&gt; m.my_constraint.dual\nTraceback (most recent call last):\n...\nRuntimeError: Unable to retrieve attribute 'Pi'\n&gt;&gt;&gt; m.convert_to_fixed()\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.my_constraint.dual\n1.0\n</code></pre> <p>Only works for Gurobi:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"highs\")\n&gt;&gt;&gt; m.convert_to_fixed()\nTraceback (most recent call last):\n...\nNotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.\n</code></pre> Source code in <code>pyoframe/_model.py</code> <pre><code>@for_solvers(\"gurobi\")\ndef convert_to_fixed(self) -&gt; None:\n    \"\"\"Gurobi only: Converts a mixed integer program into a continuous one by fixing all the non-continuous variables to their solution values.\n\n    !!! warning \"Gurobi only\"\n        This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model(\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0)\n        &gt;&gt;&gt; m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0)\n        &gt;&gt;&gt; m.Z = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.my_constraint = m.X + m.Y + m.Z &lt;= 10\n        &gt;&gt;&gt; m.maximize = 3 * m.X + 2 * m.Y + m.Z\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.X.solution, m.Y.solution, m.Z.solution\n        (1, 9, 0.0)\n        &gt;&gt;&gt; m.my_constraint.dual\n        Traceback (most recent call last):\n        ...\n        RuntimeError: Unable to retrieve attribute 'Pi'\n        &gt;&gt;&gt; m.convert_to_fixed()\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.my_constraint.dual\n        1.0\n\n        Only works for Gurobi:\n\n        &gt;&gt;&gt; m = pf.Model(\"highs\")\n        &gt;&gt;&gt; m.convert_to_fixed()\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.\n    \"\"\"\n    self.poi._converttofixed()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.dispose","title":"<code>dispose()</code>","text":"<p>Disposes of the model and cleans up the solver environment.</p> <p>When using Gurobi compute server, this cleanup will ensure your run is not marked as 'ABORTED'.</p> <p>Note that once the model is disposed, it cannot be used anymore.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(ub=1)\n&gt;&gt;&gt; m.maximize = m.X\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.X.solution\n1.0\n&gt;&gt;&gt; m.dispose()\n</code></pre> Source code in <code>pyoframe/_model.py</code> <pre><code>def dispose(self):\n    \"\"\"Disposes of the model and cleans up the solver environment.\n\n    When using Gurobi compute server, this cleanup will\n    ensure your run is not marked as 'ABORTED'.\n\n    Note that once the model is disposed, it cannot be used anymore.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable(ub=1)\n        &gt;&gt;&gt; m.maximize = m.X\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.X.solution\n        1.0\n        &gt;&gt;&gt; m.dispose()\n    \"\"\"\n    env = None\n    if hasattr(self.poi, \"_env\"):\n        env = self.poi._env\n    self.poi.close()\n    if env is not None:\n        env.close()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.optimize","title":"<code>optimize()</code>","text":"<p>Optimizes the model using your selected solver (e.g. Gurobi, HiGHS).</p> Source code in <code>pyoframe/_model.py</code> <pre><code>def optimize(self):\n    \"\"\"Optimizes the model using your selected solver (e.g. Gurobi, HiGHS).\"\"\"\n    self.poi.optimize()\n</code></pre>"},{"location":"reference/public/Model/#pyoframe.Model.write","title":"<code>write(file_path: Path | str, pretty: bool = False)</code>","text":"<p>Outputs the model or the solution to a file (e.g. a <code>.lp</code>, <code>.sol</code>, <code>.mps</code>, or <code>.ilp</code> file).</p> <p>These files can be useful for manually debugging a model. Consult your solver documentation to learn more.</p> <p>When creating your model, set <code>solver_uses_variable_names</code> to make the outputed file human-readable.</p> <pre><code>m = pf.Model(solver_uses_variable_names=True)\n</code></pre> <p>For Gurobi, <code>solver_uses_variable_names=True</code> is mandatory when using .write(). This may become mandatory for other solvers too without notice.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>The path to the file to write to.</p> required <code>pretty</code> <code>bool</code> <p>Only used when writing .sol files in HiGHS. If <code>True</code>, will use HiGH's pretty print columnar style which contains more information.</p> <code>False</code> Source code in <code>pyoframe/_model.py</code> <pre><code>def write(self, file_path: Path | str, pretty: bool = False):\n    \"\"\"Outputs the model or the solution to a file (e.g. a `.lp`, `.sol`, `.mps`, or `.ilp` file).\n\n    These files can be useful for manually debugging a model.\n    Consult your solver documentation to learn more.\n\n    When creating your model, set [`solver_uses_variable_names`][pyoframe.Model]\n    to make the outputed file human-readable.\n\n    ```python\n    m = pf.Model(solver_uses_variable_names=True)\n    ```\n\n    For Gurobi, `solver_uses_variable_names=True` is mandatory when using\n    .write(). This may become mandatory for other solvers too without notice.\n\n    Parameters:\n        file_path:\n            The path to the file to write to.\n        pretty:\n            Only used when writing .sol files in HiGHS. If `True`, will use HiGH's pretty print columnar style which contains more information.\n    \"\"\"\n    if not self.solver.supports_write:\n        raise NotImplementedError(f\"{self.solver.name} does not support .write()\")\n    if (\n        not self.solver_uses_variable_names\n        and self.solver.accelerate_with_repeat_names\n    ):\n        raise ValueError(\n            f\"{self.solver.name} requires solver_uses_variable_names=True to use .write()\"\n        )\n\n    file_path = Path(file_path)\n    file_path.parent.mkdir(parents=True, exist_ok=True)\n\n    kwargs = {}\n    if self.solver.name == \"highs\":\n        if self.solver_uses_variable_names:\n            self.params.write_solution_style = 1\n        kwargs[\"pretty\"] = pretty\n    self.poi.write(str(file_path), **kwargs)\n</code></pre>"},{"location":"reference/public/ObjSense/","title":"ObjSense","text":"<p>               Bases: <code>Enum</code></p> <p>Attributes:</p> Name Type Description <code>MAX</code> <code>MIN</code>"},{"location":"reference/public/ObjSense/#pyoframe.ObjSense.MAX","title":"<code>MAX = 'max'</code>","text":""},{"location":"reference/public/ObjSense/#pyoframe.ObjSense.MIN","title":"<code>MIN = 'min'</code>","text":""},{"location":"reference/public/Objective/","title":"Objective","text":"<p>               Bases: <code>Expression</code></p> <p>The objective for an optimization model.</p> <p>Examples:</p> <p>An <code>Objective</code> is automatically created when an <code>Expression</code> is assigned to <code>.minimize</code> or <code>.maximize</code></p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.A, m.B = pf.Variable(lb=0), pf.Variable(lb=0)\n&gt;&gt;&gt; m.con = m.A + m.B &lt;= 10\n&gt;&gt;&gt; m.maximize = 2 * m.B + 4\n&gt;&gt;&gt; m.maximize\n&lt;Objective terms=2 type=linear&gt;\n2\u00a0B +4\n</code></pre> <p>The objective value can be retrieved with from the solver once the model is solved using <code>.value</code>.</p> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n24.0\n</code></pre> <p>Objectives support <code>+=</code> and <code>-=</code> operators.</p> <pre><code>&gt;&gt;&gt; m.maximize += 3 * m.A\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.A.solution, m.B.solution\n(10.0, 0.0)\n&gt;&gt;&gt; m.maximize -= 2 * m.A\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.A.solution, m.B.solution\n(0.0, 10.0)\n</code></pre> <p>Objectives cannot be created from dimensioned expressions since an objective must be a single expression.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.dimensioned_variable = pf.Variable(\n...     {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}\n... )\n&gt;&gt;&gt; m.maximize = m.dimensioned_variable\nTraceback (most recent call last):\n...\nValueError: Objective cannot be created from a dimensioned expression. Did you forget to use .sum()?\n</code></pre> <p>Objectives cannot be overwritten.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.A = pf.Variable(lb=0)\n&gt;&gt;&gt; m.maximize = 2 * m.A\n&gt;&gt;&gt; m.maximize = 3 * m.A\nTraceback (most recent call last):\n...\nValueError: An objective already exists. Use += or -= to modify it.\n</code></pre> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The value of the objective function (only available after solving the model).</p> Source code in <code>pyoframe/_objective.py</code> <pre><code>def __init__(self, expr: Operable, _constructive: bool = False) -&gt; None:\n    self._constructive = _constructive\n    if isinstance(expr, (int, float)):\n        expr = Expression.constant(expr)\n    else:\n        expr = expr.to_expr()\n    super().__init__(expr.data, name=\"objective\")\n    self._model = expr._model\n    if self.dimensions is not None:\n        raise ValueError(\n            \"Objective cannot be created from a dimensioned expression. Did you forget to use .sum()?\"\n        )\n</code></pre>"},{"location":"reference/public/Objective/#pyoframe.Objective.value","title":"<code>value: float</code>","text":"<p>The value of the objective function (only available after solving the model).</p> <p>This value is obtained by directly querying the solver.</p>"},{"location":"reference/public/PyoframeError/","title":"PyoframeError","text":"<p>               Bases: <code>Exception</code></p> <p>Class for all Pyoframe-specific errors, typically errors arising from improper arithmetic operations.</p>"},{"location":"reference/public/Set/","title":"Set","text":"<p>               Bases: <code>BaseOperableBlock</code></p> <p>A set which can then be used to index variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Set(x=range(2), y=range(3))\n&lt;Set 'unnamed' height=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2506 y   \u2502\n\u2502 (2) \u2506 (3) \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 0   \u2502\n\u2502 0   \u2506 1   \u2502\n\u2502 0   \u2506 2   \u2502\n\u2502 1   \u2506 0   \u2502\n\u2502 1   \u2506 1   \u2502\n\u2502 1   \u2506 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Methods:</p> Name Description <code>drop</code> <p>Returns a new Set with the given dimensions dropped.</p> <code>to_expr</code> <p>Converts the Set to an Expression equal to 1 for each index.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(self, *data: SetTypes | Iterable[SetTypes], **named_data):\n    data_list = list(data)\n    for name, set in named_data.items():\n        data_list.append({name: set})\n    df = self._parse_acceptable_sets(*data_list)\n    if not df.is_empty() and df.is_duplicated().any():\n        raise ValueError(\"Duplicate rows found in input data.\")\n    super().__init__(df, name=\"unnamed_set\")\n</code></pre>"},{"location":"reference/public/Set/#pyoframe.Set.drop","title":"<code>drop(*dims: str) -&gt; Set</code>","text":"<p>Returns a new Set with the given dimensions dropped.</p> <p>Only unique rows are kept in the resulting Set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xy = pf.Set(x=range(3), y=range(2))\n&gt;&gt;&gt; xy\n&lt;Set 'unnamed' height=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2506 y   \u2502\n\u2502 (3) \u2506 (2) \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 0   \u2502\n\u2502 0   \u2506 1   \u2502\n\u2502 1   \u2506 0   \u2502\n\u2502 1   \u2506 1   \u2502\n\u2502 2   \u2506 0   \u2502\n\u2502 2   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; x = xy.drop(\"y\")\n&gt;&gt;&gt; x\n&lt;Set 'unnamed_set.drop(\u2026)' height=3&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2502\n\u2502 (3) \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2502\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>def drop(self, *dims: str) -&gt; Set:\n    \"\"\"Returns a new Set with the given dimensions dropped.\n\n    Only unique rows are kept in the resulting Set.\n\n    Examples:\n        &gt;&gt;&gt; xy = pf.Set(x=range(3), y=range(2))\n        &gt;&gt;&gt; xy\n        &lt;Set 'unnamed' height=6&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x   \u2506 y   \u2502\n        \u2502 (3) \u2506 (2) \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0   \u2506 0   \u2502\n        \u2502 0   \u2506 1   \u2502\n        \u2502 1   \u2506 0   \u2502\n        \u2502 1   \u2506 1   \u2502\n        \u2502 2   \u2506 0   \u2502\n        \u2502 2   \u2506 1   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; x = xy.drop(\"y\")\n        &gt;&gt;&gt; x\n        &lt;Set 'unnamed_set.drop(\u2026)' height=3&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x   \u2502\n        \u2502 (3) \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 0   \u2502\n        \u2502 1   \u2502\n        \u2502 2   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if not dims:\n        raise ValueError(\"At least one dimension must be provided to drop.\")\n    return self._new(\n        self.data.drop(dims).unique(maintain_order=Config.maintain_order),\n        name=f\"{self.name}.drop(\u2026)\",\n    )\n</code></pre>"},{"location":"reference/public/Set/#pyoframe.Set.to_expr","title":"<code>to_expr() -&gt; Expression</code>","text":"<p>Converts the Set to an Expression equal to 1 for each index.</p> <p>Useful when multiplying a Set by an Expression.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    \"\"\"Converts the Set to an Expression equal to 1 for each index.\n\n    Useful when multiplying a Set by an Expression.\n    \"\"\"\n    return Expression(\n        self.data.with_columns(\n            pl.lit(1).alias(COEF_KEY), pl.lit(CONST_TERM).alias(VAR_KEY)\n        ),\n        name=self.name,\n    )\n</code></pre>"},{"location":"reference/public/VType/","title":"VType","text":"<p>               Bases: <code>Enum</code></p> <p>An Enum that can be used to specify the variable type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=VType.BINARY)\n</code></pre> <p>The enum's string values can also be used directly although this is prone to typos:</p> <pre><code>&gt;&gt;&gt; m.Y = pf.Variable(vtype=\"binary\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>BINARY</code> <p>Variables that must be either 0 or 1.</p> <code>CONTINUOUS</code> <p>Variables that can be any real value.</p> <code>INTEGER</code> <p>Variables that must be integer values.</p>"},{"location":"reference/public/VType/#pyoframe.VType.BINARY","title":"<code>BINARY = 'binary'</code>","text":"<p>Variables that must be either 0 or 1.</p>"},{"location":"reference/public/VType/#pyoframe.VType.CONTINUOUS","title":"<code>CONTINUOUS = 'continuous'</code>","text":"<p>Variables that can be any real value.</p>"},{"location":"reference/public/VType/#pyoframe.VType.INTEGER","title":"<code>INTEGER = 'integer'</code>","text":"<p>Variables that must be integer values.</p>"},{"location":"reference/public/Variable/","title":"Variable","text":"<p>               Bases: <code>BaseOperableBlock</code></p> <p>A decision variable for an optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>*indexing_sets</code> <code>SetTypes | Iterable[SetTypes]</code> <p>If no indexing_sets are provided, a single variable with no dimensions is created. Otherwise, a variable is created for each element in the Cartesian product of the indexing_sets (see Set for details on behaviour).</p> <code>()</code> <code>lb</code> <code>Operable | None</code> <p>The lower bound for all variables.</p> <code>None</code> <code>ub</code> <code>Operable | None</code> <p>The upper bound for all variables.</p> <code>None</code> <code>vtype</code> <code>VType | VTypeValue</code> <p>The type of the variable. Can be either a VType enum or a string. Default is VType.CONTINUOUS.</p> <code>CONTINUOUS</code> <code>equals</code> <code>Operable | None</code> <p>When specified, a variable is created and a constraint is added to make the variable equal to the provided expression.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; df = pd.DataFrame(\n...     {\"dim1\": [1, 1, 2, 2, 3, 3], \"dim2\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]}\n... )\n&gt;&gt;&gt; Variable(df)\n&lt;Variable 'unnamed' height=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2502\n\u2502 (3)  \u2506 (2)  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2502\n\u2502 1    \u2506 b    \u2502\n\u2502 2    \u2506 a    \u2502\n\u2502 2    \u2506 b    \u2502\n\u2502 3    \u2506 a    \u2502\n\u2502 3    \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Variables cannot be used until they're added to the model.</p> <pre><code>&gt;&gt;&gt; m.constraint = Variable(df) &lt;= 3\nTraceback (most recent call last):\n...\nValueError: Cannot use 'Variable' before it has been added to a model.\n</code></pre> <p>Instead, assign the variable to the model first:</p> <pre><code>&gt;&gt;&gt; m.v = Variable(df)\n&gt;&gt;&gt; m.constraint = m.v &lt;= 3\n</code></pre> <pre><code>&gt;&gt;&gt; m.v\n&lt;Variable 'v' height=6&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2506 variable \u2502\n\u2502 (3)  \u2506 (2)  \u2506          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2506 v[1,a]   \u2502\n\u2502 1    \u2506 b    \u2506 v[1,b]   \u2502\n\u2502 2    \u2506 a    \u2506 v[2,a]   \u2502\n\u2502 2    \u2506 b    \u2506 v[2,b]   \u2502\n\u2502 3    \u2506 a    \u2506 v[3,a]   \u2502\n\u2502 3    \u2506 b    \u2506 v[3,b]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; m.v2 = Variable(df[[\"dim1\"]])\nTraceback (most recent call last):\n...\nValueError: Duplicate rows found in input data.\n&gt;&gt;&gt; m.v3 = Variable(df[[\"dim1\"]].drop_duplicates())\n&gt;&gt;&gt; m.v3\n&lt;Variable 'v3' height=3&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 variable \u2502\n\u2502 (3)  \u2506          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 v3[1]    \u2502\n\u2502 2    \u2506 v3[2]    \u2502\n\u2502 3    \u2506 v3[3]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Methods:</p> Name Description <code>next</code> <p>Creates an expression where the variable at each label is the next variable in the specified dimension.</p> <code>to_expr</code> <p>Converts the Variable to an Expression.</p> <p>Attributes:</p> Name Type Description <code>attr</code> <code>Container</code> <p>Allows reading and writing variable attributes similarly to Model.attr.</p> <code>solution</code> <p>Retrieves a variable's optimal value after the model has been solved.</p> <code>vtype</code> <code>VType</code> Source code in <code>pyoframe/_core.py</code> <pre><code>def __init__(\n    self,\n    *indexing_sets: SetTypes | Iterable[SetTypes],\n    lb: Operable | None = None,\n    ub: Operable | None = None,\n    vtype: VType | VTypeValue = VType.CONTINUOUS,\n    equals: Operable | None = None,\n):\n    if equals is not None:\n        if isinstance(equals, (float, int)):\n            if lb is not None:\n                raise ValueError(\"Cannot specify 'lb' when 'equals' is a constant.\")\n            if ub is not None:\n                raise ValueError(\"Cannot specify 'ub' when 'equals' is a constant.\")\n            lb = ub = equals\n            equals = None\n        else:\n            assert len(indexing_sets) == 0, (\n                \"Cannot specify both 'equals' and 'indexing_sets'\"\n            )\n            equals = equals.to_expr()\n            indexing_sets = (equals,)\n\n    data = Set(*indexing_sets).data if len(indexing_sets) &gt; 0 else pl.DataFrame()\n    super().__init__(data)\n\n    self.vtype: VType = VType(vtype)\n    self._attr = Container(self._set_attribute, self._get_attribute)\n    self._equals: Expression | None = equals\n\n    if lb is not None and not isinstance(lb, (float, int)):\n        self._lb_expr, self.lb = lb, None\n    else:\n        self._lb_expr, self.lb = None, lb\n    if ub is not None and not isinstance(ub, (float, int)):\n        self._ub_expr, self.ub = ub, None\n    else:\n        self._ub_expr, self.ub = None, ub\n</code></pre>"},{"location":"reference/public/Variable/#pyoframe.Variable.attr","title":"<code>attr: Container</code>","text":"<p>Allows reading and writing variable attributes similarly to Model.attr.</p>"},{"location":"reference/public/Variable/#pyoframe.Variable.solution","title":"<code>solution</code>","text":"<p>Retrieves a variable's optimal value after the model has been solved.</p> <p>Return type is a DataFrame if the variable has dimensions, otherwise it is a single value. Binary and integer variables are returned as integers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.var_continuous = pf.Variable({\"dim1\": [1, 2, 3]}, lb=5, ub=5)\n&gt;&gt;&gt; m.var_integer = pf.Variable(\n...     {\"dim1\": [1, 2, 3]}, lb=4.5, ub=5.5, vtype=pf.VType.INTEGER\n... )\n&gt;&gt;&gt; m.var_dimensionless = pf.Variable(\n...     lb=4.5, ub=5.5, vtype=pf.VType.INTEGER\n... )\n&gt;&gt;&gt; m.var_continuous.solution\nTraceback (most recent call last):\n...\nRuntimeError: Failed to retrieve solution for variable. Are you sure the model has been solved?\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.var_continuous.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5.0      \u2502\n\u2502 2    \u2506 5.0      \u2502\n\u2502 3    \u2506 5.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.var_integer.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5        \u2502\n\u2502 2    \u2506 5        \u2502\n\u2502 3    \u2506 5        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.var_dimensionless.solution\n5\n</code></pre>"},{"location":"reference/public/Variable/#pyoframe.Variable.vtype","title":"<code>vtype: VType = VType(vtype)</code>","text":""},{"location":"reference/public/Variable/#pyoframe.Variable.next","title":"<code>next(dim: str, wrap_around: bool = False) -&gt; Expression</code>","text":"<p>Creates an expression where the variable at each label is the next variable in the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>str</code> <p>The dimension over which to shift the variable.</p> required <code>wrap_around</code> <code>bool</code> <p>If <code>True</code>, the last label in the dimension is connected to the first label.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n&gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; # Fails because the dimensions are not the same\n&gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\nTraceback (most recent call last):\n...\npyoframe._constants.PyoframeError: Cannot subtract the two expressions below because expression 1 has extra labels.\nExpression 1:       (bat_charge + bat_flow)\nExpression 2:       bat_charge.next(\u2026)\nExtra labels in expression 1:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 18:00 \u2506 Toronto \u2502\n\u2502 18:00 \u2506 Berlin  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nUse .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n    https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_extras() == m.bat_charge.next(\"time\")\n&lt;Constraint 'unnamed' height=6 terms=18 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 constraint                                                                     \u2502\n\u2502 (3)   \u2506 (2)     \u2506                                                                                \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00 \u2506 Toronto \u2506 bat_charge[00:00,Toronto] +\u00a0bat_flow[00:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[06:00,Toronto] =\u00a00                                                \u2502\n\u2502 00:00 \u2506 Berlin  \u2506 bat_charge[00:00,Berlin] +\u00a0bat_flow[00:00,Berlin] -\u00a0bat_charge[06:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 06:00 \u2506 Toronto \u2506 bat_charge[06:00,Toronto] +\u00a0bat_flow[06:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[12:00,Toronto] =\u00a00                                                \u2502\n\u2502 06:00 \u2506 Berlin  \u2506 bat_charge[06:00,Berlin] +\u00a0bat_flow[06:00,Berlin] -\u00a0bat_charge[12:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 12:00 \u2506 Toronto \u2506 bat_charge[12:00,Toronto] +\u00a0bat_flow[12:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[18:00,Toronto] =\u00a00                                                \u2502\n\u2502 12:00 \u2506 Berlin  \u2506 bat_charge[12:00,Berlin] +\u00a0bat_flow[12:00,Berlin] -\u00a0bat_charge[18:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\n...     \"time\", wrap_around=True\n... )\n&lt;Constraint 'unnamed' height=8 terms=24 type=linear&gt;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 constraint                                                                     \u2502\n\u2502 (4)   \u2506 (2)     \u2506                                                                                \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00 \u2506 Toronto \u2506 bat_charge[00:00,Toronto] +\u00a0bat_flow[00:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[06:00,Toronto] =\u00a00                                                \u2502\n\u2502 00:00 \u2506 Berlin  \u2506 bat_charge[00:00,Berlin] +\u00a0bat_flow[00:00,Berlin] -\u00a0bat_charge[06:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 06:00 \u2506 Toronto \u2506 bat_charge[06:00,Toronto] +\u00a0bat_flow[06:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[12:00,Toronto] =\u00a00                                                \u2502\n\u2502 06:00 \u2506 Berlin  \u2506 bat_charge[06:00,Berlin] +\u00a0bat_flow[06:00,Berlin] -\u00a0bat_charge[12:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 12:00 \u2506 Toronto \u2506 bat_charge[12:00,Toronto] +\u00a0bat_flow[12:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[18:00,Toronto] =\u00a00                                                \u2502\n\u2502 12:00 \u2506 Berlin  \u2506 bat_charge[12:00,Berlin] +\u00a0bat_flow[12:00,Berlin] -\u00a0bat_charge[18:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2502 18:00 \u2506 Toronto \u2506 bat_charge[18:00,Toronto] +\u00a0bat_flow[18:00,Toronto]                            \u2502\n\u2502       \u2506         \u2506 -\u00a0bat_charge[00:00,Toronto] =\u00a00                                                \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 bat_charge[18:00,Berlin] +\u00a0bat_flow[18:00,Berlin] -\u00a0bat_charge[00:00,Berlin]   \u2502\n\u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/_core.py</code> <pre><code>@return_new\ndef next(self, dim: str, wrap_around: bool = False):\n    \"\"\"Creates an expression where the variable at each label is the next variable in the specified dimension.\n\n    Parameters:\n        dim:\n            The dimension over which to shift the variable.\n        wrap_around:\n            If `True`, the last label in the dimension is connected to the first label.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n        &gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; # Fails because the dimensions are not the same\n        &gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\n        Traceback (most recent call last):\n        ...\n        pyoframe._constants.PyoframeError: Cannot subtract the two expressions below because expression 1 has extra labels.\n        Expression 1:\t(bat_charge + bat_flow)\n        Expression 2:\tbat_charge.next(\u2026)\n        Extra labels in expression 1:\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 18:00 \u2506 Toronto \u2502\n        \u2502 18:00 \u2506 Berlin  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        Use .drop_extras() or .keep_extras() to indicate how the extra labels should be handled. Learn more at\n            https://bravos-power.github.io/pyoframe/latest/learn/concepts/addition\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_extras() == m.bat_charge.next(\"time\")\n        &lt;Constraint 'unnamed' height=6 terms=18 type=linear&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 constraint                                                                     \u2502\n        \u2502 (3)   \u2506 (2)     \u2506                                                                                \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 00:00 \u2506 Toronto \u2506 bat_charge[00:00,Toronto] +\u00a0bat_flow[00:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[06:00,Toronto] =\u00a00                                                \u2502\n        \u2502 00:00 \u2506 Berlin  \u2506 bat_charge[00:00,Berlin] +\u00a0bat_flow[00:00,Berlin] -\u00a0bat_charge[06:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 06:00 \u2506 Toronto \u2506 bat_charge[06:00,Toronto] +\u00a0bat_flow[06:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[12:00,Toronto] =\u00a00                                                \u2502\n        \u2502 06:00 \u2506 Berlin  \u2506 bat_charge[06:00,Berlin] +\u00a0bat_flow[06:00,Berlin] -\u00a0bat_charge[12:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 12:00 \u2506 Toronto \u2506 bat_charge[12:00,Toronto] +\u00a0bat_flow[12:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[18:00,Toronto] =\u00a00                                                \u2502\n        \u2502 12:00 \u2506 Berlin  \u2506 bat_charge[12:00,Berlin] +\u00a0bat_flow[12:00,Berlin] -\u00a0bat_charge[18:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\n        ...     \"time\", wrap_around=True\n        ... )\n        &lt;Constraint 'unnamed' height=8 terms=24 type=linear&gt;\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 constraint                                                                     \u2502\n        \u2502 (4)   \u2506 (2)     \u2506                                                                                \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 00:00 \u2506 Toronto \u2506 bat_charge[00:00,Toronto] +\u00a0bat_flow[00:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[06:00,Toronto] =\u00a00                                                \u2502\n        \u2502 00:00 \u2506 Berlin  \u2506 bat_charge[00:00,Berlin] +\u00a0bat_flow[00:00,Berlin] -\u00a0bat_charge[06:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 06:00 \u2506 Toronto \u2506 bat_charge[06:00,Toronto] +\u00a0bat_flow[06:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[12:00,Toronto] =\u00a00                                                \u2502\n        \u2502 06:00 \u2506 Berlin  \u2506 bat_charge[06:00,Berlin] +\u00a0bat_flow[06:00,Berlin] -\u00a0bat_charge[12:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 12:00 \u2506 Toronto \u2506 bat_charge[12:00,Toronto] +\u00a0bat_flow[12:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[18:00,Toronto] =\u00a00                                                \u2502\n        \u2502 12:00 \u2506 Berlin  \u2506 bat_charge[12:00,Berlin] +\u00a0bat_flow[12:00,Berlin] -\u00a0bat_charge[18:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2502 18:00 \u2506 Toronto \u2506 bat_charge[18:00,Toronto] +\u00a0bat_flow[18:00,Toronto]                            \u2502\n        \u2502       \u2506         \u2506 -\u00a0bat_charge[00:00,Toronto] =\u00a00                                                \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 bat_charge[18:00,Berlin] +\u00a0bat_flow[18:00,Berlin] -\u00a0bat_charge[00:00,Berlin]   \u2502\n        \u2502       \u2506         \u2506 =\u00a00                                                                            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n    wrapped = (\n        self.data.select(dim)\n        .unique(maintain_order=Config.maintain_order)\n        .sort(by=dim)\n    )\n    wrapped = wrapped.with_columns(pl.col(dim).shift(-1).alias(\"__next\"))\n    if wrap_around:\n        wrapped = wrapped.with_columns(pl.col(\"__next\").fill_null(pl.first(dim)))\n    else:\n        wrapped = wrapped.drop_nulls(dim)\n\n    expr = self.to_expr()\n    data = expr.data.rename({dim: \"__prev\"})\n\n    data = data.join(\n        wrapped,\n        left_on=\"__prev\",\n        right_on=\"__next\",\n        # We use \"right\" instead of \"left\" to maintain consistency with the behavior without maintain_order\n        maintain_order=\"right\" if Config.maintain_order else None,\n    ).drop([\"__prev\", \"__next\"], strict=False)\n\n    return data\n</code></pre>"},{"location":"reference/public/Variable/#pyoframe.Variable.to_expr","title":"<code>to_expr() -&gt; Expression</code>","text":"<p>Converts the Variable to an Expression.</p> Source code in <code>pyoframe/_core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    \"\"\"Converts the Variable to an Expression.\"\"\"\n    self._assert_has_ids()\n    return self._new(self.data.drop(SOLUTION_KEY, strict=False), self.name)  # pyright: ignore[reportArgumentType], we know it's safe after _assert_has_ids()\n</code></pre>"},{"location":"reference/types/Operable/","title":"Operable","text":"<p>Any of the following objects: <code>int</code>, <code>float</code>, Variable, Expression, Set, polars or pandas DataFrame, or pandas Series.</p>"},{"location":"why-pyoframe/","title":"Why Pyoframe?","text":"<p>A growing community of users are choosing Pyoframe for its speed, memory efficiency, model readability, and ease-of-development!</p> <p>We are actively developing performance benchmarks against other libraries. Preliminary (unpublished) results indicate that Pyoframe is much faster!</p> <p>Kjartan has also kindly developed a notebook showcasing Pyoframe for its speed, memory efficiency and readability compared to GAMS, Gurobipy, and Linopy.</p>"}]}