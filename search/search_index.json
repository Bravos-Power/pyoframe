{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyoframe: Formulate huge optimization models","text":"<p>Tired of slow or archaic modelling frameworks like Pyomo and GAMS?  Here are some reasons we think you'd like Pyoframe:</p> <ul> <li>Python library for building LP and MILP models</li> <li>Open-source MIT License</li> <li>Works with Pandas dataframes</li> <li>Powered by Rust and Polars</li> </ul> <ul> <li> <p> Learn</p> <p>Install <code>pyoframe</code> and learn the library's basics.</p> <p> Get started</p> </li> </ul> <ul> <li> <p> API Reference</p> <p>Your go-to reference for understanding our API.</p> <p> Reference</p> </li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Learn</li> <li>Reference</li> <li>Contribute</li> </ul>"},{"location":"contribute/","title":"Contribute","text":"<p>Contributions are more than welcome! Submit a pull request, or open an issue and I (Martin) will gladly answer your questions on how to contribute.</p>"},{"location":"contribute/#setup-a-development-environment","title":"Setup a development environment","text":"<ol> <li> <p>Clone this repository. <code>git clone https://github.com/Bravos-Power/pyoframe</code></p> </li> <li> <p>Install the dependencies. <code>pip install --editable .[dev,docs]</code></p> </li> <li> <p>Install the pre-commit hooks. <code>pre-commit install</code></p> </li> <li> <p>Run <code>pytest</code> to make sure everything is working. If not, open an issue!</p> </li> </ol>"},{"location":"contribute/#documentation","title":"Documentation","text":"<p>We use Material Docs for documentation with several plugins to enable features like automatically compiling the docstrings into the reference API. Please follow the Google style for docstrings.</p>"},{"location":"contribute/#helpful-commands","title":"Helpful commands","text":"<ul> <li><code>pytest</code>: Runs all the tests. Tests are found under <code>/tests</code> and also as doc tests. Include the flag <code>--cov</code> to get test coverage information.</li> <li><code>mkdocs serve</code>: Generates the documentation locally. Navigate to <code>http://127.0.0.1:8000/pyoframe/</code> to check it out.</li> </ul>"},{"location":"learn/","title":"Overview","text":"<ul> <li> <p> Get Started</p> <p>Install <code>pyoframe</code> and learn the library's basics.</p> <p> Getting started</p> </li> <li> <p> Tutorials</p> <p>Step-by-step tutorials to make sense of important features</p> <p> Tutorials</p> </li> <li> <p> Concepts</p> <p>Understand the how and why of Pyoframe. </p> <p> Concepts</p> </li> <li> <p> Reference</p> <p>Your go-to reference for understanding our API.</p> <p> API Reference</p> </li> <li> <p> Examples</p> <p>Show don't tell!</p> <p> Examples</p> </li> </ul>"},{"location":"learn/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Getting Started</li> <li>Advanced Concepts</li> <li>Examples</li> </ul>"},{"location":"learn/01_getting-started/01_installation/","title":"Installation","text":""},{"location":"learn/01_getting-started/01_installation/#install-pyoframe","title":"Install Pyoframe","text":"<pre><code>pip install pyoframe\n</code></pre>"},{"location":"learn/01_getting-started/01_installation/#install-a-solver","title":"Install a solver","text":"HiGHS (free)Gurobi (commercial)Other Solvers <pre><code>pip install pyoframe[highs]\n</code></pre> <ol> <li>Install Gurobi from their website.</li> <li>Ensure you have a valid Gurobi license installed on your machine.</li> </ol> <p>Note: installing Gurobi via pip will not work since we access Gurobi through its C API not through Python.</p> <p>We'd be glad to add more solvers! Just let us know what you'd like :)</p>"},{"location":"learn/01_getting-started/02_build-simple-model/","title":"A simple model","text":"<p>Here's a simple model to show you Pyoframe's syntax. Click on the  buttons to discover what's happening.</p> <pre><code>import pyoframe as pf\n\nm = pf.Model()\n\n# You can buy tofu or chickpeas\nm.tofu = pf.Variable(lb=0)  # (1)!\nm.chickpeas = pf.Variable(lb=0)\n\n# You want to maximize your protein intake (10g per tofu, 8g per chickpeas)\nm.maximize = 10 * m.tofu + 8 * m.chickpeas # (2)!\n\n# You must stay with your $10 budget (4$ per tofu, $2 per chickpeas)\nm.budget_constraint = 4 * m.tofu + 2 * m.chickpeas &lt;= 10 # (3)!\n\nm.optimize()  # (4)!\n\nprint(\"You should buy:\")\nprint(f\"\\t{m.tofu.solution} blocks of tofu\")\nprint(f\"\\t{m.chickpeas.solution} cans of chickpeas\")\n</code></pre> <ol> <li>Create a variable with a lower bound of zero (<code>lb=0</code>) so that you can't buy a negative quantity of tofu!</li> <li>Define your objective by setting the reserved variables <code>.maximize</code> or <code>.minimize</code>.</li> <li>Creates constraints by using <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code>.</li> <li>Pyoframe automatically detects your installed solver and optimizes your model!</li> </ol>"},{"location":"learn/01_getting-started/02_build-simple-model/#use-dimensions","title":"Use dimensions","text":"<p>The above model would quickly become unworkable if we had more than just tofu and chickpeas. I'll walk you through how we can make a <code>food</code> dimension to make this scalable. You can also skip to the end to see the example in full!</p> <p>Note that instead of hardcoding our values, we'll be reading them from the following csv file.</p> <p><code>food_data.csv</code></p> food protein cost tofu 10 4 chickpeas 8 2"},{"location":"learn/01_getting-started/02_build-simple-model/#load-your-data","title":"Load your data","text":"<p>Nothing special here. Load your data using your favourite dataframe library. We like Polars because it's fast but Pandas works too.</p> PandasPolars <pre><code>import pandas as pd\n\ndata = pd.read_csv(\"food_data.csv\")\n</code></pre> <pre><code>import polars as pl\n\ndata = pl.read_csv(\"food_data.csv\")\n</code></pre>"},{"location":"learn/01_getting-started/02_build-simple-model/#create-the-model","title":"Create the model","text":"<pre><code>import pyoframe as pf\nm = pf.Model()\n</code></pre>"},{"location":"learn/01_getting-started/02_build-simple-model/#create-an-dimensioned-variable","title":"Create an dimensioned variable","text":"<p>Previously, we created two variables: <code>m.tofu</code> and <code>m.chickpeas</code>. Instead, we now create a single variable dimensioned over <code>food</code>.</p> <pre><code>m.Buy = pf.Variable(data[[\"food\"]], lb=0)\n</code></pre> <p>If you print the variable, you'll see it actually contains a <code>tofu</code> and <code>chickpeas</code> variable!</p> <pre><code>&gt;&gt;&gt; m.Buy\n&lt;Variable name=Buy lb=0 size=2 dimensions={'food': 2}&gt;\n[tofu]: Buy[tofu]\n[chickpeas]: Buy[chickpeas]\n</code></pre> <p>Tip</p> <p>Naming your model's decision variables with an uppercase first letter (e.g. <code>m.Buy</code>) makes it easier to remember what's a variable and what isn't.</p>"},{"location":"learn/01_getting-started/02_build-simple-model/#create-the-objective","title":"Create the objective","text":"<p>Previously we had: <pre><code>m.maximize = 10 * m.tofu + 8 * m.chickpeas\n</code></pre></p> <p>How do we make use of our dimensioned variable <code>m.Buy</code> instead?</p> <p>First, we multiply the variable by the protein amount.</p> <p><pre><code>&gt;&gt;&gt; data[[\"food\", \"protein\"]] * m.Buy\n&lt;Expression size=2 dimensions={'food': 2} terms=2&gt;\n[tofu]: 10 Buy[tofu]\n[chickpeas]: 8 Buy[chickpeas]\n</code></pre> As you can see, Pyoframe with a bit of magic converted our <code>Variable</code> into an <code>Expression</code> where the coefficients are the protein amounts!</p> <p>Second, notice that our <code>Expression</code> still has a <code>food</code> dimension\u2014it really contains two seperate expressions, one for tofu and one for chickpeas. Our model's objective must be a single expression (without dimensions) so let's sum over the <code>food</code> dimensions using <code>pf.sum()</code>.</p> <pre><code>&gt;&gt;&gt; pf.sum(\"food\", data[[\"food\", \"protein\"]] * m.Buy)\n&lt;Expression size=1 dimensions={} terms=2&gt;\n10 Buy[tofu] +8 Buy[chickpeas]\n</code></pre> <p>This works and since <code>food</code> is the only dimensions we don't even need to specify it. Putting it all together:</p> <pre><code>m.maximize = pf.sum(data[[\"food\", \"protein\"]] * m.Buy)\n</code></pre>"},{"location":"learn/01_getting-started/02_build-simple-model/#adding-the-constraint","title":"Adding the constraint","text":"<p>This is similar to how we created the objective, except now we're using <code>cost</code> and we turn our <code>Expression</code> into a <code>Constraint</code> by with the <code>&lt;=</code> operation.</p> <pre><code>m.budget_constraint = pf.sum(data[[\"food\", \"cost\"]] * m.Buy) &lt;= 10\n</code></pre>"},{"location":"learn/01_getting-started/02_build-simple-model/#putting-it-all-together","title":"Putting it all together","text":"<pre><code>import pandas as pd\nimport pyoframe as pf\n\ndata = pd.read_csv(\"food_data.csv\")\n\nm = pf.Model()\nm.Buy = pf.Variable(data[[\"food\"]], lb=0)\nm.maximize = pf.sum(data[[\"food\", \"protein\"]] * m.Buy)\nm.budget_constraint = pf.sum(data[[\"food\", \"cost\"]] * m.Buy) &lt;= 10\n\nm.optimize()\n</code></pre> <p>So you should buy: <pre><code>&gt;&gt;&gt; m.Buy.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food      \u2506 solution \u2502\n\u2502 ---       \u2506 ---      \u2502\n\u2502 str       \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 tofu      \u2506 0.0      \u2502\n\u2502 chickpeas \u2506 5.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Notice that since <code>m.Buy</code> is dimensioned, <code>m.Buy.solution</code> returned a dataframe with the solution for each of indices!</p> <p>info</p> <p>Pyoframe currently always returns Polars dataframes although we plan to add support for returning Pandas dataframes in the future. Upvote the issue if you'd like this feature and in the meantime use <code>.to_pandas()</code> to convert from a Polars dataframe.</p>"},{"location":"learn/01_getting-started/04_building_blocks/","title":"Model Building Blocks","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>In any linear program there are three key building blocks Variables, Constraints, and an Objective. We walk you through these as well as two more: Expressions and Sets</p>"},{"location":"learn/01_getting-started/04_building_blocks/#variable","title":"<code>Variable</code>","text":""},{"location":"learn/01_getting-started/04_building_blocks/#constraint","title":"<code>Constraint</code>","text":""},{"location":"learn/01_getting-started/04_building_blocks/#objective","title":"<code>Objective</code>","text":""},{"location":"learn/01_getting-started/04_building_blocks/#expression","title":"<code>Expression</code>","text":""},{"location":"learn/01_getting-started/04_building_blocks/#set","title":"<code>Set</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/","title":"Special functions","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>Pyoframe has a few special functions that make working with dataframes easy and intuitive. Here they are:</p>"},{"location":"learn/01_getting-started/05_special_functions/#pfsumexpression","title":"<code>pf.sum(Expression)</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/#expressionmap","title":"<code>Expression.map()</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/#expressionadd_dim","title":"<code>Expression.add_dim()</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/#expressiondrop_unmatched","title":"<code>Expression.drop_unmatched()</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/#expressionkeep_unmatched","title":"<code>Expression.keep_unmatched()</code>","text":""},{"location":"learn/01_getting-started/06_accessing_the_solver/","title":"Accessing the solver","text":""},{"location":"learn/01_getting-started/06_accessing_the_solver/#accessing-model-attributes","title":"Accessing model attributes","text":"<p>Pyoframe lets you read and set solver attributes using <code>model.attr.&lt;your-attribute&gt;</code>. For example, if you'd like to prevent the solver from printing to the console you can do:</p> <pre><code>m = pf.Model()\nm.attr.Silent = True\n</code></pre> <p>We support all of PyOptInterface's model attributes as well as Gurobi's attributes (only when using Gurobi).</p> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus  # Read a PyOptInterface model attribute (available with all solvers)\n&lt;TerminationStatusCode.OPTIMAL: 2&gt;\n&gt;&gt;&gt; m.attr.Status  # Read the Gurobi model attribute (available with Gurobi only)\n2\n</code></pre>"},{"location":"learn/01_getting-started/06_accessing_the_solver/#accessing-variable-and-constraint-attributes","title":"Accessing variable and constraint attributes","text":"<p>Similar to above, Pyoframe allows directly accessing the PyOptInterface or the solver's variable and constraint attributes.</p> <pre><code>m = pf.Model()\nm.X = pf.Variable()\nm.X.attr.PrimalStart = 5\n</code></pre> <p>If the variable or constraint is dimensioned, the attribute can accept/return a dataframe instead of a constant.</p>"},{"location":"learn/01_getting-started/06_accessing_the_solver/#accessing-model-parameters-gurobi-only","title":"Accessing model parameters (Gurobi only)","text":"<p>Gurobi supports model attributes (see above) and model parameters (full list here). You can read or set model parameters with <code>model.params.&lt;your-parameter&gt;</code>. For example:</p> <pre><code>m.params.method = 2  # Use a barrier method to solve\n</code></pre>"},{"location":"learn/01_getting-started/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Installation</li> <li>A simple model</li> <li>Model building blocks</li> <li>Special Functions</li> <li>Accessing the solver</li> </ul>"},{"location":"learn/02_tutorials/","title":"Tutorials","text":"<p>Work in progress</p> <p>We haven't created tutorials yet! Learn how you can contribute.</p>"},{"location":"learn/03_concepts/01_pyoframe-datastructure/","title":"The Pyoframe datastructure","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>So how does Pyoframe really work? Pyoframe uses dataframe operations to build your model's linear expressions. Here's what's happening under the hood.</p>"},{"location":"learn/03_concepts/02_performance_tips/","title":"Performance","text":"<p>Pyoframe is already one of the fastest and lowest-memory-footprint libraries to build optimization models since we leverage <code>Polars</code> internally. Here are some additional tips to squeeze out every bit of performance:</p> <ol> <li> <p>Use polars not pandas. Internally, pyoframe uses polars for everything. If you're using Pandas we'll just convert your dataframes to Polars. So might as well use polars from the very beginning! You'll save time during your pre-processing and data loading.</p> </li> <li> <p>Use integers not strings for indexing. Pyoframe works fine with dataframes that contain string columns but you should know that strings take up a lot more space than just numbering your values. When possible, use integer indices.</p> </li> <li> <p>Tweak the <code>pf.Config</code> settings. Take a look at our API Reference and you might find some settings to adjust to squeeze out the last bit of performance.</p> </li> </ol>"},{"location":"learn/03_concepts/02_performance_tips/#expression-or-variable","title":"<code>Expression</code> or <code>Variable</code> ?","text":"<p>One common question when building large models is, if you have a very long linear expression, should you assign it to a variable or simply use the expression directly? In some cases, it is best to assign it to a variable since Pyoframe will then only need to pass around the variable rather than all the terms in the linear expression. If you're concerned that you'll be adding more variables to your model, know that most solvers will rapidly and easily get rid of these variables during the presolve stage without any noticeable performance cost.</p>"},{"location":"learn/03_concepts/03_quadratic_expressions/","title":"Quadratic Expressions","text":"<p>Quadratic expressions work as you'd expect. Simply multiply two linear expression together (or square an expression with <code>**2</code>) and you'll get a quadratic. The quadratic can then be used in constraints or the objective. </p>"},{"location":"learn/03_concepts/03_quadratic_expressions/#example","title":"Example","text":""},{"location":"learn/03_concepts/03_quadratic_expressions/#maximize-area-of-box","title":"Maximize area of box","text":"<p>Here's a short example that shows that a square maximizes the area of any box with a fixed perimeter.</p> <pre><code>import pyoframe as pf\nmodel = pf.Model(\"max\")\nmodel.w = pf.Variable(lb=0)\nmodel.h = pf.Variable(lb=0)\nmodel.limit_perimter = 2 * (model.w + model.h) &lt;= 20\nmodel.objective = model.w * model.h\nmodel.solve()\nprint(f\"It's a square: {model.w.solution==model.h.solution}\")\n\n# Outputs: It's a square: True\n</code></pre>"},{"location":"learn/03_concepts/03_quadratic_expressions/#facility-location-problem","title":"Facility Location Problem","text":"<p>See examples/facility_location.</p>"},{"location":"learn/03_concepts/03_quadratic_expressions/#note-for-pyoframe-developers-internal-representation-of-quadratics","title":"Note for Pyoframe developers: Internal Representation of Quadratics","text":"<p>Internally, Pyoframe's <code>Expression</code> object is used for both linear and quadratic expressions. When the dataframe within an <code>Expression</code> object (i.e. <code>Expression.data</code>) contains an additional column (named <code>__quadratic_variable_id</code>) we know that the expression is a quadratic.</p> <p>This extra column stores the ID of the second variable in quadratic terms. For terms with only one variable, this column contains ID <code>0</code> (a reserved variable ID which can thought of as meaning 'no variable'). The variables in a quadratic are rearranged such that the ID in the <code>__variable_id</code> column is always greater or equal than the variable ID in the <code>__quadratic_variable_id</code> (recall: ab=ba). This rearranging not only ensures that ab+ba=2a*b but also generates a useful property: If the variable ID in the first column (<code>__variable_id</code>) is <code>0</code> we know the variable ID in the second must also be <code>0</code> and therefore the term must be a constant.</p> <p>The additional quadratic variable ID column is automatically dropped if through arithmetic the quadratic terms cancel out.</p>"},{"location":"learn/03_concepts/04_troubleshooting/","title":"Troubleshooting","text":"<p>Here are some potential errors and how to resolve them.</p>"},{"location":"learn/03_concepts/04_troubleshooting/#datatypes-of-join-keys-dont-match","title":"<code>datatypes of join keys don't match</code>","text":"<p>Often, this error indicates that two columns in your input dataframes, although representing the same dimension, have different datatypes (e.g. 16bit integer and 64bit integer). This is not allowed and you should ensure that for the same dimensions, datatypes are identical.</p>"},{"location":"learn/03_concepts/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Pyoframe datastructure</li> <li>Performance</li> <li>Quadratics</li> <li>Troubleshooting</li> </ul>"},{"location":"learn/04_examples/","title":"Examples","text":"<p>Beyond examples in this documentation, the following examples are available:</p> <ul> <li>Power grid example in Jupyter Notebooks (thanks Kjartan !)</li> <li>Diet problem example similar to the one presented in Getting Started</li> <li>A cutting stock problem example</li> <li>A facility location problem example</li> </ul>"},{"location":"reference/","title":"Index","text":"<p>Pyoframe's public API. Also applies the monkey patch to the DataFrame libraries.</p>"},{"location":"reference/#pyoframe.Config","title":"<code>Config</code>","text":"<p>Configuration options that apply to the entire library.</p>"},{"location":"reference/#pyoframe.Config.reset_defaults","title":"<code>reset_defaults()</code>  <code>classmethod</code>","text":"<p>Resets all configuration options to their default values.</p> Source code in <code>pyoframe/constants.py</code> <pre><code>@classmethod\ndef reset_defaults(cls):\n    \"\"\"\n    Resets all configuration options to their default values.\n    \"\"\"\n    for key, value in cls._defaults.items():\n        setattr(cls, key, value)\n</code></pre>"},{"location":"reference/#pyoframe.Constraint","title":"<code>Constraint(lhs, sense)</code>","text":"<p>               Bases: <code>ModelElementWithId</code></p> <p>A linear programming constraint.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expression</code> <p>The left hand side of the constraint.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, lhs: Expression, sense: ConstraintSense):\n    \"\"\"Initialize a constraint.\n\n    Parameters:\n        lhs:\n            The left hand side of the constraint.\n        sense:\n            The sense of the constraint.\n    \"\"\"\n    self.lhs = lhs\n    self._model = lhs._model\n    self.sense = sense\n    self.to_relax: Optional[FuncArgs] = None\n    self.attr = Container(self._set_attribute, self._get_attribute)\n\n    dims = self.lhs.dimensions\n    data = pl.DataFrame() if dims is None else self.lhs.data.select(dims).unique()\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/#pyoframe.Constraint.relax","title":"<code>relax(cost, max=None)</code>","text":"<p>Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>SupportsToExpr</code> <p>The cost of relaxing the constraint. Costs should be positives as they will automatically become negative for maximization problems.</p> required <code>max</code> <code>Optional[SupportsToExpr]</code> <p>The maximum value of the relaxation variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>The same constraint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.maximize = m.hours_day\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n16.0\n&gt;&gt;&gt; m.maximize += 2 * m.hours_day\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n19.0\n</code></pre> <p>Note: .relax() can only be called after the sense of the model has been defined.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\nTraceback (most recent call last):\n...\nValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n</code></pre> <p>One way to solve this is by setting the sense directly on the model. See how this works fine:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(sense=\"max\")\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n</code></pre> <p>And now an example with dimensions:</p> <pre><code>&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n&gt;&gt;&gt; m.must_finish_project = (m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]).relax(homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]], max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]])\n&gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n&gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n&gt;&gt;&gt; m.only_one_day.relax(1)\nTraceback (most recent call last):\n...\nValueError: .relax() must be called before the Constraint is added to the model\n&gt;&gt;&gt; m.attr.Silent = True\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n-50.0\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 8.0      \u2502\n\u2502 B       \u2506 7.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def relax(\n    self, cost: SupportsToExpr, max: Optional[SupportsToExpr] = None\n) -&gt; Constraint:\n    \"\"\"\n    Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.\n\n    Parameters:\n        cost:\n            The cost of relaxing the constraint. Costs should be positives as they will automatically\n            become negative for maximization problems.\n        max:\n            The maximum value of the relaxation variable.\n\n    Returns:\n        The same constraint\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.maximize = m.hours_day\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        16.0\n        &gt;&gt;&gt; m.maximize += 2 * m.hours_day\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        19.0\n\n        Note: .relax() can only be called after the sense of the model has been defined.\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n\n        One way to solve this is by setting the sense directly on the model. See how this works fine:\n\n        &gt;&gt;&gt; m = pf.Model(sense=\"max\")\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n\n        And now an example with dimensions:\n\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = (m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]).relax(homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]], max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]])\n        &gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n        &gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n        &gt;&gt;&gt; m.only_one_day.relax(1)\n        Traceback (most recent call last):\n        ...\n        ValueError: .relax() must be called before the Constraint is added to the model\n        &gt;&gt;&gt; m.attr.Silent = True\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.maximize.value\n        -50.0\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 8.0      \u2502\n        \u2502 B       \u2506 7.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if self._has_ids:\n        raise ValueError(\n            \".relax() must be called before the Constraint is added to the model\"\n        )\n\n    m = self._model\n    if m is None or self.name is None:\n        self.to_relax = FuncArgs(args=[cost, max])\n        return self\n\n    var_name = f\"{self.name}_relaxation\"\n    assert not hasattr(\n        m, var_name\n    ), \"Conflicting names, relaxation variable already exists on the model.\"\n    var = Variable(self, lb=0, ub=max)\n    setattr(m, var_name, var)\n\n    if self.sense == ConstraintSense.LE:\n        self.lhs -= var\n    elif self.sense == ConstraintSense.GE:\n        self.lhs += var\n    else:  # pragma: no cover\n        # TODO\n        raise NotImplementedError(\n            \"Relaxation for equalities has not yet been implemented. Submit a pull request!\"\n        )\n\n    penalty = var * cost\n    if self.dimensions:\n        penalty = sum(self.dimensions, penalty)\n    if m.sense is None:\n        raise ValueError(\n            \"Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\"\n        )\n    elif m.sense == ObjSense.MAX:\n        penalty *= -1\n    if m.objective is None:\n        m.objective = penalty\n    else:\n        m.objective += penalty\n\n    return self\n</code></pre>"},{"location":"reference/#pyoframe.Expression","title":"<code>Expression(data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A linear or quadratic expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.Time = pf.Variable(df.index)\n&gt;&gt;&gt; m.Size = pf.Variable(df.index)\n&gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n&gt;&gt;&gt; expr\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n[1,mon]: Time[1,mon] + Size[1,mon]\n[1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n[1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n[2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n[2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, data: pl.DataFrame):\n    \"\"\"\n    A linear expression.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.Time = pf.Variable(df.index)\n        &gt;&gt;&gt; m.Size = pf.Variable(df.index)\n        &gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n        &gt;&gt;&gt; expr\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n        [1,mon]: Time[1,mon] + Size[1,mon]\n        [1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n        [1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n        [2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n        [2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n    \"\"\"\n    # Sanity checks, VAR_KEY and COEF_KEY must be present\n    assert VAR_KEY in data.columns, \"Missing variable column.\"\n    assert COEF_KEY in data.columns, \"Missing coefficient column.\"\n\n    # Sanity check no duplicates indices\n    if Config.enable_is_duplicated_expression_safety_check:\n        duplicated_mask = data.drop(COEF_KEY).is_duplicated()\n        # In theory this should never happen unless there's a bug in the library\n        if duplicated_mask.any():  # pragma: no cover\n            duplicated_data = data.filter(duplicated_mask)\n            raise ValueError(\n                f\"Cannot create an expression with duplicate indices:\\n{duplicated_data}.\"\n            )\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/#pyoframe.Expression.is_quadratic","title":"<code>is_quadratic</code>  <code>property</code>","text":"<p>Returns True if the expression is quadratic, False otherwise.</p> <p>Computes in O(1) since expressions are quadratic if and only if self.data contain the QUAD_VAR_KEY column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}) * m.v\n&gt;&gt;&gt; expr *= m.v\n&gt;&gt;&gt; expr.is_quadratic\nTrue\n</code></pre>"},{"location":"reference/#pyoframe.Expression.__add__","title":"<code>__add__(other)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1,2,3], \"add\": [10, 20, 30]}).to_expr()\n&gt;&gt;&gt; m.v = Variable(add)\n&gt;&gt;&gt; m.v + add\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: v[1] +10\n[2]: v[2] +20\n[3]: v[3] +30\n&gt;&gt;&gt; m.v + add + 2\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: v[1] +12\n[2]: v[2] +22\n[3]: v[3] +32\n&gt;&gt;&gt; m.v + pd.DataFrame({\"dim1\": [1,2], \"add\": [10, 20]})\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim1_right \u2502\n\u2502 ---  \u2506 ---        \u2502\n\u2502 i64  \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3    \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.v2 = Variable()\n&gt;&gt;&gt; 5 + 2 * m.v2\n&lt;Expression size=1 dimensions={} terms=2&gt;\n2 v2 +5\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1,2,3], \"add\": [10, 20, 30]}).to_expr()\n        &gt;&gt;&gt; m.v = Variable(add)\n        &gt;&gt;&gt; m.v + add\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: v[1] +10\n        [2]: v[2] +20\n        [3]: v[3] +30\n        &gt;&gt;&gt; m.v + add + 2\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: v[1] +12\n        [2]: v[2] +22\n        [3]: v[3] +32\n        &gt;&gt;&gt; m.v + pd.DataFrame({\"dim1\": [1,2], \"add\": [10, 20]})\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (1, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim1_right \u2502\n        \u2502 ---  \u2506 ---        \u2502\n        \u2502 i64  \u2506 i64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 3    \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; m.v2 = Variable()\n        &gt;&gt;&gt; 5 + 2 * m.v2\n        &lt;Expression size=1 dimensions={} terms=2&gt;\n        2 v2 +5\n    \"\"\"\n    if isinstance(other, str):\n        raise ValueError(\n            \"Cannot add a string to an expression. Perhaps you meant to use pf.sum() instead of sum()?\"\n        )\n    if isinstance(other, (int, float)):\n        return self._add_const(other)\n    other = other.to_expr()\n    self._learn_from_other(other)\n    return _add_expressions(self, other)\n</code></pre>"},{"location":"reference/#pyoframe.Expression._add_const","title":"<code>_add_const(const)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.x1 = Variable()\n&gt;&gt;&gt; m.x2 = Variable()\n&gt;&gt;&gt; m.x1 + 5\n&lt;Expression size=1 dimensions={} terms=2&gt;\nx1 +5\n&gt;&gt;&gt; m.x1 ** 2 + 5\n&lt;Expression size=1 dimensions={} terms=2 degree=2&gt;\nx1 * x1 +5\n&gt;&gt;&gt; m.x1 ** 2 + m.x2 + 5\n&lt;Expression size=1 dimensions={} terms=3 degree=2&gt;\nx1 * x1 + x2 +5\n</code></pre> <p>It also works with dimensions</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable({\"dim1\": [1, 2, 3]})\n&gt;&gt;&gt; m.v * m.v + 5\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6 degree=2&gt;\n[1]: 5  + v[1] * v[1]\n[2]: 5  + v[2] * v[2]\n[3]: 5  + v[3] * v[3]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def _add_const(self, const: int | float) -&gt; Expression:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.x1 = Variable()\n        &gt;&gt;&gt; m.x2 = Variable()\n        &gt;&gt;&gt; m.x1 + 5\n        &lt;Expression size=1 dimensions={} terms=2&gt;\n        x1 +5\n        &gt;&gt;&gt; m.x1 ** 2 + 5\n        &lt;Expression size=1 dimensions={} terms=2 degree=2&gt;\n        x1 * x1 +5\n        &gt;&gt;&gt; m.x1 ** 2 + m.x2 + 5\n        &lt;Expression size=1 dimensions={} terms=3 degree=2&gt;\n        x1 * x1 + x2 +5\n\n        It also works with dimensions\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = Variable({\"dim1\": [1, 2, 3]})\n        &gt;&gt;&gt; m.v * m.v + 5\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6 degree=2&gt;\n        [1]: 5  + v[1] * v[1]\n        [2]: 5  + v[2] * v[2]\n        [3]: 5  + v[3] * v[3]\n    \"\"\"\n    dim = self.dimensions\n    data = self.data\n    # Fill in missing constant terms\n    if not dim:\n        if CONST_TERM not in data[VAR_KEY]:\n            const_df = pl.DataFrame(\n                {COEF_KEY: [0.0], VAR_KEY: [CONST_TERM]},\n                schema={COEF_KEY: pl.Float64, VAR_KEY: KEY_TYPE},\n            )\n            if self.is_quadratic:\n                const_df = const_df.with_columns(\n                    pl.lit(CONST_TERM).alias(QUAD_VAR_KEY).cast(KEY_TYPE)\n                )\n            data = pl.concat(\n                [data, const_df],\n                how=\"vertical_relaxed\",\n            )\n    else:\n        keys = (\n            data.select(dim)\n            .unique(maintain_order=True)\n            .with_columns(pl.lit(CONST_TERM).alias(VAR_KEY).cast(KEY_TYPE))\n        )\n        if self.is_quadratic:\n            keys = keys.with_columns(\n                pl.lit(CONST_TERM).alias(QUAD_VAR_KEY).cast(KEY_TYPE)\n            )\n        if POLARS_VERSION.major &gt;= 1:\n            data = data.join(\n                keys, on=dim + self._variable_columns, how=\"full\", coalesce=True\n            )\n        else:\n            data = data.join(\n                keys, on=dim + self._variable_columns, how=\"outer_coalesce\"\n            )\n        data = data.with_columns(pl.col(COEF_KEY).fill_null(0.0))\n\n    data = data.with_columns(\n        pl.when(pl.col(VAR_KEY) == CONST_TERM)\n        .then(pl.col(COEF_KEY) + const)\n        .otherwise(pl.col(COEF_KEY))\n    )\n\n    return self._new(data)\n</code></pre>"},{"location":"reference/#pyoframe.Expression.constant","title":"<code>constant(constant)</code>  <code>classmethod</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Expression.constant(5)\n&lt;Expression size=1 dimensions={} terms=1&gt;\n5\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>@classmethod\ndef constant(cls, constant: int | float) -&gt; \"Expression\":\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; pf.Expression.constant(5)\n        &lt;Expression size=1 dimensions={} terms=1&gt;\n        5\n    \"\"\"\n    return cls(\n        pl.DataFrame(\n            {\n                COEF_KEY: [constant],\n                VAR_KEY: [CONST_TERM],\n            },\n            schema={COEF_KEY: pl.Float64, VAR_KEY: KEY_TYPE},\n        )\n    )\n</code></pre>"},{"location":"reference/#pyoframe.Expression.degree","title":"<code>degree()</code>","text":"<p>Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v1 = pf.Variable()\n&gt;&gt;&gt; m.v2 = pf.Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n&gt;&gt;&gt; expr.degree()\n0\n&gt;&gt;&gt; expr *= m.v1\n&gt;&gt;&gt; expr.degree()\n1\n&gt;&gt;&gt; expr += (m.v2 ** 2).add_dim(\"dim1\")\n&gt;&gt;&gt; expr.degree()\n2\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def degree(self) -&gt; int:\n    \"\"\"\n    Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v1 = pf.Variable()\n        &gt;&gt;&gt; m.v2 = pf.Variable()\n        &gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n        &gt;&gt;&gt; expr.degree()\n        0\n        &gt;&gt;&gt; expr *= m.v1\n        &gt;&gt;&gt; expr.degree()\n        1\n        &gt;&gt;&gt; expr += (m.v2 ** 2).add_dim(\"dim1\")\n        &gt;&gt;&gt; expr.degree()\n        2\n    \"\"\"\n    if self.is_quadratic:\n        return 2\n    elif (self.data.get_column(VAR_KEY) != CONST_TERM).any():\n        return 1\n    else:\n        return 0\n</code></pre>"},{"location":"reference/#pyoframe.Expression.evaluate","title":"<code>evaluate()</code>","text":"<p>The value of the expression. Only available after the model has been solved.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, ub=10)\n&gt;&gt;&gt; m.expr_1 = 2 * m.X + 1\n&gt;&gt;&gt; m.expr_2 = pf.sum(m.expr_1)\n&gt;&gt;&gt; m.maximize = m.expr_2 - 3\n&gt;&gt;&gt; m.attr.Silent = True\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.expr_1.evaluate()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 21.0     \u2502\n\u2502 2    \u2506 21.0     \u2502\n\u2502 3    \u2506 21.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.expr_2.evaluate()\n63.0\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>@unwrap_single_values\ndef evaluate(self) -&gt; pl.DataFrame:\n    \"\"\"\n    The value of the expression. Only available after the model has been solved.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, ub=10)\n        &gt;&gt;&gt; m.expr_1 = 2 * m.X + 1\n        &gt;&gt;&gt; m.expr_2 = pf.sum(m.expr_1)\n        &gt;&gt;&gt; m.maximize = m.expr_2 - 3\n        &gt;&gt;&gt; m.attr.Silent = True\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.expr_1.evaluate()\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 solution \u2502\n        \u2502 ---  \u2506 ---      \u2502\n        \u2502 i64  \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 21.0     \u2502\n        \u2502 2    \u2506 21.0     \u2502\n        \u2502 3    \u2506 21.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; m.expr_2.evaluate()\n        63.0\n    \"\"\"\n    assert (\n        self._model is not None\n    ), \"Expression must be added to the model to use .value\"\n\n    df = self.data\n    sm = self._model.poi\n    attr = poi.VariableAttribute.Value\n    for var_col in self._variable_columns:\n        df = df.with_columns(\n            (\n                pl.col(COEF_KEY)\n                * pl.col(var_col).map_elements(\n                    lambda v_id: (\n                        sm.get_variable_attribute(poi.VariableIndex(v_id), attr)\n                        if v_id != CONST_TERM\n                        else 1\n                    ),\n                    return_dtype=pl.Float64,\n                )\n            ).alias(COEF_KEY)\n        ).drop(var_col)\n\n    df = df.rename({COEF_KEY: SOLUTION_KEY})\n\n    dims = self.dimensions\n    if dims is not None:\n        df = df.group_by(dims, maintain_order=True)\n    return df.sum()\n</code></pre>"},{"location":"reference/#pyoframe.Expression.map","title":"<code>map(mapping_set, drop_shared_dims=True)</code>","text":"<p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <p>This is particularly useful to go from one type of dimensions to another. For example, to convert data that is indexed by city to data indexed by country (see example).</p> <p>Parameters:</p> Name Type Description Default <code>mapping_set</code> <code>SetTypes</code> <p>The set to map the expression to. This can be a DataFrame, Index, or another Set.</p> required <code>drop_shared_dims</code> <code>bool</code> <p>If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and     repeated rows are summed. If False, the shared dimensions are kept in the resulting expression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression containing the result of the mapping operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; pop_data = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"year\": [2024, 2024, 2024], \"population\": [10, 2, 8]}).to_expr()\n&gt;&gt;&gt; cities_and_countries = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"country\": [\"Canada\", \"Canada\", \"USA\"]})\n&gt;&gt;&gt; pop_data.map(cities_and_countries)\n&lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n[2024,Canada]: 12\n[2024,USA]: 8\n&gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n&lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n[Toronto,2024,Canada]: 10\n[Vancouver,2024,Canada]: 2\n[Boston,2024,USA]: 8\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def map(self, mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression:\n    \"\"\"\n    Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.\n\n    This is particularly useful to go from one type of dimensions to another. For example, to convert data that\n    is indexed by city to data indexed by country (see example).\n\n    Parameters:\n        mapping_set:\n            The set to map the expression to. This can be a DataFrame, Index, or another Set.\n        drop_shared_dims:\n            If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and\n                repeated rows are summed.\n            If False, the shared dimensions are kept in the resulting expression.\n\n    Returns:\n        A new Expression containing the result of the mapping operation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; pop_data = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"year\": [2024, 2024, 2024], \"population\": [10, 2, 8]}).to_expr()\n        &gt;&gt;&gt; cities_and_countries = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"country\": [\"Canada\", \"Canada\", \"USA\"]})\n        &gt;&gt;&gt; pop_data.map(cities_and_countries)\n        &lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n        [2024,Canada]: 12\n        [2024,USA]: 8\n        &gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n        &lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n        [Toronto,2024,Canada]: 10\n        [Vancouver,2024,Canada]: 2\n        [Boston,2024,USA]: 8\n    \"\"\"\n    mapping_set = Set(mapping_set)\n\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot use .map() on an expression with no dimensions.\")\n\n    mapping_dims = mapping_set.dimensions\n    if mapping_dims is None:\n        raise ValueError(\n            \"Cannot use .map() with a mapping set containing no dimensions.\"\n        )\n\n    shared_dims = [dim for dim in dims if dim in mapping_dims]\n    if not shared_dims:\n        raise ValueError(\n            f\"Cannot apply .map() as there are no shared dimensions between the expression (dims={self.dimensions}) and the mapping set (dims={mapping_set.dimensions}).\"\n        )\n\n    mapped_expression = self * mapping_set\n\n    if drop_shared_dims:\n        return sum(shared_dims, mapped_expression)\n\n    return mapped_expression\n</code></pre>"},{"location":"reference/#pyoframe.Expression.rolling_sum","title":"<code>rolling_sum(over, window_size)</code>","text":"<p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <p>This method applies a rolling sum operation over the dimension specified by <code>over</code>, using a window defined by <code>window_size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>over</code> <p>The name of the dimension (column) over which the rolling sum is calculated. This dimension must exist within the Expression's dimensions.</p> required <code>window_size</code> <p>The size of the moving window in terms of number of records. The rolling sum is calculated over this many consecutive elements.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression instance containing the result of the rolling sum operation. This new Expression retains all dimensions (columns) of the original data, with the rolling sum applied over the specified dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; cost = pl.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [1, 2, 3, 1, 2], \"cost\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n&gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n[1,1]: quantity[1,1]\n[1,2]: quantity[1,1] +2 quantity[1,2]\n[1,3]: 2 quantity[1,2] +3 quantity[1,3]\n[2,1]: 4 quantity[2,1]\n[2,2]: 4 quantity[2,1] +5 quantity[2,2]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def rolling_sum(self, over: str, window_size: int) -&gt; Expression:\n    \"\"\"\n    Calculates the rolling sum of the Expression over a specified window size for a given dimension.\n\n    This method applies a rolling sum operation over the dimension specified by `over`,\n    using a window defined by `window_size`.\n\n\n    Parameters:\n        over :\n            The name of the dimension (column) over which the rolling sum is calculated.\n            This dimension must exist within the Expression's dimensions.\n        window_size :\n            The size of the moving window in terms of number of records.\n            The rolling sum is calculated over this many consecutive elements.\n\n    Returns:\n        A new Expression instance containing the result of the rolling sum operation.\n            This new Expression retains all dimensions (columns) of the original data,\n            with the rolling sum applied over the specified dimension.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; cost = pl.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [1, 2, 3, 1, 2], \"cost\": [1, 2, 3, 4, 5]})\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n        &gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n        [1,1]: quantity[1,1]\n        [1,2]: quantity[1,1] +2 quantity[1,2]\n        [1,3]: 2 quantity[1,2] +3 quantity[1,3]\n        [2,1]: 4 quantity[2,1]\n        [2,2]: 4 quantity[2,1] +5 quantity[2,2]\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\n            \"Cannot use rolling_sum() with an expression with no dimensions.\"\n        )\n    assert over in dims, f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        pl.concat(\n            [\n                df.with_columns(pl.col(over).max())\n                for _, df in self.data.rolling(\n                    index_column=over,\n                    period=f\"{window_size}i\",\n                    group_by=remaining_dims,\n                )\n            ]\n        )\n    )\n</code></pre>"},{"location":"reference/#pyoframe.Expression.sum","title":"<code>sum(over)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m.quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n&gt;&gt;&gt; expr = (m.quantity * df[\"cost\"]).sum(\"time\")\n&gt;&gt;&gt; expr.data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0     \u2506 1             \u2502\n\u2502 2    \u2506 9.0     \u2506 2             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def sum(self, over: Union[str, Iterable[str]]):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; m.quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n        &gt;&gt;&gt; expr = (m.quantity * df[\"cost\"]).sum(\"time\")\n        &gt;&gt;&gt; expr.data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 6.0     \u2506 1             \u2502\n        \u2502 2    \u2506 9.0     \u2506 2             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if isinstance(over, str):\n        over = [over]\n    dims = self.dimensions\n    if not dims:\n        raise ValueError(\n            f\"Cannot sum over dimensions {over} since the current expression has no dimensions.\"\n        )\n    assert set(over) &lt;= set(dims), f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        self.data.drop(over)\n        .group_by(remaining_dims + self._variable_columns, maintain_order=True)\n        .sum()\n    )\n</code></pre>"},{"location":"reference/#pyoframe.Expression.within","title":"<code>within(set)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; general_expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n&gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n&gt;&gt;&gt; general_expr.within(filter_expr).data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0     \u2506 0             \u2502\n\u2502 3    \u2506 3.0     \u2506 0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def within(self, set: \"SetTypes\") -&gt; Expression:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; general_expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n        &gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n        &gt;&gt;&gt; general_expr.within(filter_expr).data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0     \u2506 0             \u2502\n        \u2502 3    \u2506 3.0     \u2506 0             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df: pl.DataFrame = Set(set).data\n    set_dims = _get_dimensions(df)\n    assert (\n        set_dims is not None\n    ), \"Cannot use .within() with a set with no dimensions.\"\n    dims = self.dimensions\n    assert (\n        dims is not None\n    ), \"Cannot use .within() with an expression with no dimensions.\"\n    dims_in_common = [dim for dim in dims if dim in set_dims]\n    by_dims = df.select(dims_in_common).unique(maintain_order=True)\n    return self._new(self.data.join(by_dims, on=dims_in_common))\n</code></pre>"},{"location":"reference/#pyoframe.Model","title":"<code>Model(name=None, solver=None, solver_env=None, use_var_names=False, sense=None)</code>","text":"<p>The object that holds all the variables, constraints, and the objective.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The name of the model. Currently it is not used for much.</p> <code>None</code> <code>solver</code> <code>Optional[SUPPORTED_SOLVER_TYPES]</code> <p>The solver to use. If <code>None</code>, <code>Config.default_solver</code> will be used. If <code>Config.default_solver</code> has not been set (<code>None</code>), Pyoframe will try to detect whichever solver is already installed.</p> <code>None</code> <code>solver_env</code> <code>Optional[Dict[str, str]]</code> <p>Gurobi only: a dictionary of parameters to set when creating the Gurobi environment.</p> <code>None</code> <code>use_var_names</code> <p>Whether to pass variable names to the solver. Set to <code>True</code> if you'd like outputs from e.g. <code>Model.write()</code> to be legible.</p> <code>False</code> <code>sense</code> <code>Union[ObjSense, ObjSenseValue, None]</code> <p>Either \"min\" or \"max\". Indicates whether it's a minmization or maximization problem. Typically, this parameter can be omitted (<code>None</code>) as it will automatically be set when the objective is set using <code>.minimize</code> or <code>.maximize</code>.</p> <code>None</code> Example <p>m = pf.Model() m.X = pf.Variable() m.my_constraint = m.X &lt;= 10 m  <p>Try setting the Gurobi license:</p> <p>m = pf.Model(solver=\"gurobi\", solver_env=dict(ComputeServer=\"myserver\", ServerPassword=\"mypassword\")) Traceback (most recent call last): ... RuntimeError: Could not resolve host: myserver (code 6, command POST http://myserver/api/v1/cluster/jobs)</p> Source code in <code>pyoframe/model.py</code> <pre><code>def __init__(\n    self,\n    name=None,\n    solver: Optional[SUPPORTED_SOLVER_TYPES] = None,\n    solver_env: Optional[Dict[str, str]] = None,\n    use_var_names=False,\n    sense: Union[ObjSense, ObjSenseValue, None] = None,\n):\n    self.poi, self.solver_name = Model.create_poi_model(solver, solver_env)\n    self._variables: List[Variable] = []\n    self._constraints: List[Constraint] = []\n    self.sense = ObjSense(sense) if sense is not None else None\n    self._objective: Optional[Objective] = None\n    self.var_map = (\n        NamedVariableMapper(Variable) if Config.print_uses_variable_names else None\n    )\n    self.name = name\n\n    self.params = Container(self._set_param, self._get_param)\n    self.attr = Container(self._set_attr, self._get_attr)\n    self._use_var_names = use_var_names\n</code></pre>"},{"location":"reference/#pyoframe.Model.binary_variables","title":"<code>binary_variables</code>  <code>property</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.binary_variables))\n1\n</code></pre>"},{"location":"reference/#pyoframe.Model.integer_variables","title":"<code>integer_variables</code>  <code>property</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.INTEGER)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.integer_variables))\n1\n</code></pre>"},{"location":"reference/#pyoframe.Model.compute_IIS","title":"<code>compute_IIS()</code>","text":"<p>Computes the Irreducible Infeasible Set (IIS) of the model.</p> <p>Gurobi only</p> <p>This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.</p> Example <p>m = pf.Model(solver=\"gurobi\") m.X = pf.Variable(lb=0, ub=2) m.Y = pf.Variable(lb=0, ub=2) m.bad_constraint = m.X &gt;= 3 m.minimize = m.X + m.Y m.optimize() m.attr.TerminationStatus  m.bad_constraint.attr.IIS Traceback (most recent call last): ... polars.exceptions.ComputeError: RuntimeError: Unable to retrieve attribute 'IISConstr' m.compute_IIS() m.bad_constraint.attr.IIS True Source code in <code>pyoframe/model.py</code> <pre><code>@for_solvers(\"gurobi\", \"copt\")\ndef compute_IIS(self):\n    \"\"\"\n    Computes the Irreducible Infeasible Set (IIS) of the model.\n\n    !!! warning \"Gurobi only\"\n        This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.\n\n    Example:\n        &gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.Y = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.bad_constraint = m.X &gt;= 3\n        &gt;&gt;&gt; m.minimize = m.X + m.Y\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.attr.TerminationStatus\n        &lt;TerminationStatusCode.INFEASIBLE: 3&gt;\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        Traceback (most recent call last):\n        ...\n        polars.exceptions.ComputeError: RuntimeError: Unable to retrieve attribute 'IISConstr'\n        &gt;&gt;&gt; m.compute_IIS()\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        True\n    \"\"\"\n    self.poi.computeIIS()\n</code></pre>"},{"location":"reference/#pyoframe.Model.convert_to_fixed","title":"<code>convert_to_fixed()</code>","text":"<p>Turns a mixed integer program into a continuous one by fixing all the integer and binary variables to their solution values.</p> <p>Gurobi only</p> <p>This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.</p> Example <p>m = pf.Model(solver=\"gurobi\") m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0) m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0) m.Z = pf.Variable(lb=0) m.my_constraint = m.X + m.Y + m.Z &lt;= 10 m.maximize = 3 * m.X + 2 * m.Y + m.Z m.optimize() m.X.solution, m.Y.solution, m.Z.solution (1.0, 9.0, 0.0) m.my_constraint.dual Traceback (most recent call last): ... polars.exceptions.ComputeError: RuntimeError: Unable to retrieve attribute 'Pi' m.convert_to_fixed() m.optimize() m.my_constraint.dual 1.0</p> <p>Only works for Gurobi:</p> <p>m = pf.Model(\"max\", solver=\"highs\") m.convert_to_fixed() Traceback (most recent call last): ... NotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.</p> Source code in <code>pyoframe/model.py</code> <pre><code>@for_solvers(\"gurobi\")\ndef convert_to_fixed(self) -&gt; None:\n    \"\"\"\n    Turns a mixed integer program into a continuous one by fixing\n    all the integer and binary variables to their solution values.\n\n    !!! warning \"Gurobi only\"\n        This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.\n\n    Example:\n        &gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0)\n        &gt;&gt;&gt; m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0)\n        &gt;&gt;&gt; m.Z = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.my_constraint = m.X + m.Y + m.Z &lt;= 10\n        &gt;&gt;&gt; m.maximize = 3 * m.X + 2 * m.Y + m.Z\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.X.solution, m.Y.solution, m.Z.solution\n        (1.0, 9.0, 0.0)\n        &gt;&gt;&gt; m.my_constraint.dual\n        Traceback (most recent call last):\n        ...\n        polars.exceptions.ComputeError: RuntimeError: Unable to retrieve attribute 'Pi'\n        &gt;&gt;&gt; m.convert_to_fixed()\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.my_constraint.dual\n        1.0\n\n        Only works for Gurobi:\n\n        &gt;&gt;&gt; m = pf.Model(\"max\", solver=\"highs\")\n        &gt;&gt;&gt; m.convert_to_fixed()\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.\n    \"\"\"\n    self.poi._converttofixed()\n</code></pre>"},{"location":"reference/#pyoframe.Set","title":"<code>Set(*data, **named_data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A set which can then be used to index variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Set(x=range(2), y=range(3))\n&lt;Set size=6 dimensions={'x': 2, 'y': 3}&gt;\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, *data: SetTypes | Iterable[SetTypes], **named_data):\n    data_list = list(data)\n    for name, set in named_data.items():\n        data_list.append({name: set})\n    df = self._parse_acceptable_sets(*data_list)\n    if not df.is_empty() and df.is_duplicated().any():\n        raise ValueError(\"Duplicate rows found in input data.\")\n    super().__init__(df)\n</code></pre>"},{"location":"reference/#pyoframe.Set._parse_acceptable_sets","title":"<code>_parse_acceptable_sets(*over)</code>  <code>staticmethod</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; dim1 = pd.Index([1, 2, 3], name=\"dim1\")\n&gt;&gt;&gt; dim2 = pd.Index([\"a\", \"b\"], name=\"dim1\")\n&gt;&gt;&gt; Set._parse_acceptable_sets([dim1, dim2])\nTraceback (most recent call last):\n...\nAssertionError: All coordinates must have unique column names.\n&gt;&gt;&gt; dim2.name = \"dim2\"\n&gt;&gt;&gt; Set._parse_acceptable_sets([dim1, dim2])\nshape: (6, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2502\n\u2502 1    \u2506 b    \u2502\n\u2502 2    \u2506 a    \u2502\n\u2502 2    \u2506 b    \u2502\n\u2502 3    \u2506 a    \u2502\n\u2502 3    \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>@staticmethod\ndef _parse_acceptable_sets(\n    *over: SetTypes | Iterable[SetTypes],\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; dim1 = pd.Index([1, 2, 3], name=\"dim1\")\n        &gt;&gt;&gt; dim2 = pd.Index([\"a\", \"b\"], name=\"dim1\")\n        &gt;&gt;&gt; Set._parse_acceptable_sets([dim1, dim2])\n        Traceback (most recent call last):\n        ...\n        AssertionError: All coordinates must have unique column names.\n        &gt;&gt;&gt; dim2.name = \"dim2\"\n        &gt;&gt;&gt; Set._parse_acceptable_sets([dim1, dim2])\n        shape: (6, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim2 \u2502\n        \u2502 ---  \u2506 ---  \u2502\n        \u2502 i64  \u2506 str  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 a    \u2502\n        \u2502 1    \u2506 b    \u2502\n        \u2502 2    \u2506 a    \u2502\n        \u2502 2    \u2506 b    \u2502\n        \u2502 3    \u2506 a    \u2502\n        \u2502 3    \u2506 b    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    assert len(over) &gt; 0, \"At least one set must be provided.\"\n    over_iter: Iterable[SetTypes] = parse_inputs_as_iterable(*over)\n\n    over_frames: List[pl.DataFrame] = [Set._set_to_polars(set) for set in over_iter]\n\n    over_merged = over_frames[0]\n\n    for df in over_frames[1:]:\n        assert (\n            set(over_merged.columns) &amp; set(df.columns) == set()\n        ), \"All coordinates must have unique column names.\"\n        over_merged = over_merged.join(df, how=\"cross\")\n    return over_merged\n</code></pre>"},{"location":"reference/#pyoframe.Variable","title":"<code>Variable(*indexing_sets, lb=None, ub=None, vtype=VType.CONTINUOUS, equals=None)</code>","text":"<p>               Bases: <code>ModelElementWithId</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>Represents one or many decision variable in an optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>*indexing_sets</code> <code>SetTypes | Iterable[SetTypes]</code> <p>If no indexing_sets are provided, a single variable with no dimensions is created. Otherwise, a variable is created for each element in the Cartesian product of the indexing_sets (see Set for details on behaviour).</p> <code>()</code> <code>lb</code> <code>float | int | SupportsToExpr | None</code> <p>The lower bound for all variables.</p> <code>None</code> <code>ub</code> <code>float | int | SupportsToExpr | None</code> <p>The upper bound for all variables.</p> <code>None</code> <code>vtype</code> <code>VType | VTypeValue</code> <p>The type of the variable. Can be either a VType enum or a string. Default is VType.CONTINUOUS.</p> <code>CONTINUOUS</code> <code>equals</code> <code>Optional[SupportsMath]</code> <p>When specified, a variable is created and a constraint is added to make the variable equal to the provided expression.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; df = pd.DataFrame({\"dim1\": [1, 1, 2, 2, 3, 3], \"dim2\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]})\n&gt;&gt;&gt; v = Variable(df)\n&gt;&gt;&gt; v\n&lt;Variable size=6 dimensions={'dim1': 3, 'dim2': 2} added_to_model=False&gt;\n</code></pre> <p>Variables cannot be used until they're added to the model.</p> <pre><code>&gt;&gt;&gt; m.constraint = v &lt;= 3\nTraceback (most recent call last):\n...\nValueError: Cannot use 'Variable' before it has beed added to a model.\n&gt;&gt;&gt; m.v = v\n&gt;&gt;&gt; m.constraint = m.v &lt;= 3\n</code></pre> <pre><code>&gt;&gt;&gt; m.v\n&lt;Variable name=v size=6 dimensions={'dim1': 3, 'dim2': 2}&gt;\n[1,a]: v[1,a]\n[1,b]: v[1,b]\n[2,a]: v[2,a]\n[2,b]: v[2,b]\n[3,a]: v[3,a]\n[3,b]: v[3,b]\n&gt;&gt;&gt; m.v2 = Variable(df[[\"dim1\"]])\nTraceback (most recent call last):\n...\nValueError: Duplicate rows found in input data.\n&gt;&gt;&gt; m.v3 = Variable(df[[\"dim1\"]].drop_duplicates())\n&gt;&gt;&gt; m.v3\n&lt;Variable name=v3 size=3 dimensions={'dim1': 3}&gt;\n[1]: v3[1]\n[2]: v3[2]\n[3]: v3[3]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(\n    self,\n    *indexing_sets: SetTypes | Iterable[SetTypes],\n    lb: float | int | SupportsToExpr | None = None,\n    ub: float | int | SupportsToExpr | None = None,\n    vtype: VType | VTypeValue = VType.CONTINUOUS,\n    equals: Optional[SupportsMath] = None,\n):\n    if equals is not None:\n        assert (\n            len(indexing_sets) == 0\n        ), \"Cannot specify both 'equals' and 'indexing_sets'\"\n        indexing_sets = (equals,)\n\n    data = Set(*indexing_sets).data if len(indexing_sets) &gt; 0 else pl.DataFrame()\n    super().__init__(data)\n\n    self.vtype: VType = VType(vtype)\n    self.attr = Container(self._set_attribute, self._get_attribute)\n    self._equals = equals\n\n    if lb is not None and not isinstance(lb, (float, int)):\n        self._lb_expr, self.lb = lb, None\n    else:\n        self._lb_expr, self.lb = None, lb\n    if ub is not None and not isinstance(ub, (float, int)):\n        self._ub_expr, self.ub = ub, None\n    else:\n        self._ub_expr, self.ub = None, ub\n</code></pre>"},{"location":"reference/#pyoframe.Variable.next","title":"<code>next(dim, wrap_around=False)</code>","text":"<p>Creates an expression where the variable at each index is the next variable in the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>str</code> <p>The dimension over which to shift the variable.</p> required <code>wrap_around</code> <code>bool</code> <p>If True, the last index in the dimension is connected to the first index.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n&gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; # Fails because the dimensions are not the same\n&gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n\u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n\u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\"time\")\n&lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\"time\", wrap_around=True)\n&lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n[18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n[18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def next(self, dim: str, wrap_around: bool = False) -&gt; Expression:\n    \"\"\"\n    Creates an expression where the variable at each index is the next variable in the specified dimension.\n\n    Parameters:\n        dim:\n            The dimension over which to shift the variable.\n        wrap_around:\n            If True, the last index in the dimension is connected to the first index.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n        &gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; # Fails because the dimensions are not the same\n        &gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (2, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n        \u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n        \u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\"time\")\n        &lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\"time\", wrap_around=True)\n        &lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n        [18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n        [18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n    \"\"\"\n\n    wrapped = self.data.select(dim).unique(maintain_order=True).sort(by=dim)\n    wrapped = wrapped.with_columns(pl.col(dim).shift(-1).alias(\"__next\"))\n    if wrap_around:\n        wrapped = wrapped.with_columns(pl.col(\"__next\").fill_null(pl.first(dim)))\n    else:\n        wrapped = wrapped.drop_nulls(dim)\n\n    expr = self.to_expr()\n    data = expr.data.rename({dim: \"__prev\"})\n\n    if POLARS_VERSION.major &lt; 1:\n        data = data.join(\n            wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n        ).drop([\"__prev\", \"__next\"])\n    else:\n        data = data.join(\n            wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n        ).drop([\"__prev\", \"__next\"], strict=False)\n    return expr._new(data)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pyoframe<ul> <li>constants</li> <li>core</li> <li>model</li> <li>model_element</li> <li>monkey_patch</li> <li>objective</li> <li>util</li> </ul> </li> </ul>"},{"location":"reference/constants/","title":"constants","text":"<p>File containing shared constants used across the package.</p>"},{"location":"reference/constants/#pyoframe.constants.Config","title":"<code>Config</code>","text":"<p>Configuration options that apply to the entire library.</p>"},{"location":"reference/constants/#pyoframe.constants.Config.reset_defaults","title":"<code>reset_defaults()</code>  <code>classmethod</code>","text":"<p>Resets all configuration options to their default values.</p> Source code in <code>pyoframe/constants.py</code> <pre><code>@classmethod\ndef reset_defaults(cls):\n    \"\"\"\n    Resets all configuration options to their default values.\n    \"\"\"\n    for key, value in cls._defaults.items():\n        setattr(cls, key, value)\n</code></pre>"},{"location":"reference/constants/#pyoframe.constants._ConfigMeta","title":"<code>_ConfigMeta(name, bases, dct)</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass for Config that stores the default values of all configuration options.</p> Source code in <code>pyoframe/constants.py</code> <pre><code>def __init__(cls, name, bases, dct):\n    super().__init__(name, bases, dct)\n    cls._defaults = {\n        k: v\n        for k, v in dct.items()\n        if not k.startswith(\"_\") and type(v) != classmethod\n    }\n</code></pre>"},{"location":"reference/core/","title":"core","text":""},{"location":"reference/core/#pyoframe.core.Constraint","title":"<code>Constraint(lhs, sense)</code>","text":"<p>               Bases: <code>ModelElementWithId</code></p> <p>A linear programming constraint.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expression</code> <p>The left hand side of the constraint.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, lhs: Expression, sense: ConstraintSense):\n    \"\"\"Initialize a constraint.\n\n    Parameters:\n        lhs:\n            The left hand side of the constraint.\n        sense:\n            The sense of the constraint.\n    \"\"\"\n    self.lhs = lhs\n    self._model = lhs._model\n    self.sense = sense\n    self.to_relax: Optional[FuncArgs] = None\n    self.attr = Container(self._set_attribute, self._get_attribute)\n\n    dims = self.lhs.dimensions\n    data = pl.DataFrame() if dims is None else self.lhs.data.select(dims).unique()\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Constraint.relax","title":"<code>relax(cost, max=None)</code>","text":"<p>Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>SupportsToExpr</code> <p>The cost of relaxing the constraint. Costs should be positives as they will automatically become negative for maximization problems.</p> required <code>max</code> <code>Optional[SupportsToExpr]</code> <p>The maximum value of the relaxation variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>The same constraint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.maximize = m.hours_day\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n16.0\n&gt;&gt;&gt; m.maximize += 2 * m.hours_day\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n19.0\n</code></pre> <p>Note: .relax() can only be called after the sense of the model has been defined.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\nTraceback (most recent call last):\n...\nValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n</code></pre> <p>One way to solve this is by setting the sense directly on the model. See how this works fine:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(sense=\"max\")\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n</code></pre> <p>And now an example with dimensions:</p> <pre><code>&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n&gt;&gt;&gt; m.must_finish_project = (m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]).relax(homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]], max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]])\n&gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n&gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n&gt;&gt;&gt; m.only_one_day.relax(1)\nTraceback (most recent call last):\n...\nValueError: .relax() must be called before the Constraint is added to the model\n&gt;&gt;&gt; m.attr.Silent = True\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n-50.0\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 8.0      \u2502\n\u2502 B       \u2506 7.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def relax(\n    self, cost: SupportsToExpr, max: Optional[SupportsToExpr] = None\n) -&gt; Constraint:\n    \"\"\"\n    Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.\n\n    Parameters:\n        cost:\n            The cost of relaxing the constraint. Costs should be positives as they will automatically\n            become negative for maximization problems.\n        max:\n            The maximum value of the relaxation variable.\n\n    Returns:\n        The same constraint\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.maximize = m.hours_day\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        16.0\n        &gt;&gt;&gt; m.maximize += 2 * m.hours_day\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        19.0\n\n        Note: .relax() can only be called after the sense of the model has been defined.\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n\n        One way to solve this is by setting the sense directly on the model. See how this works fine:\n\n        &gt;&gt;&gt; m = pf.Model(sense=\"max\")\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n\n        And now an example with dimensions:\n\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = (m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]).relax(homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]], max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]])\n        &gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n        &gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n        &gt;&gt;&gt; m.only_one_day.relax(1)\n        Traceback (most recent call last):\n        ...\n        ValueError: .relax() must be called before the Constraint is added to the model\n        &gt;&gt;&gt; m.attr.Silent = True\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.maximize.value\n        -50.0\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 8.0      \u2502\n        \u2502 B       \u2506 7.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if self._has_ids:\n        raise ValueError(\n            \".relax() must be called before the Constraint is added to the model\"\n        )\n\n    m = self._model\n    if m is None or self.name is None:\n        self.to_relax = FuncArgs(args=[cost, max])\n        return self\n\n    var_name = f\"{self.name}_relaxation\"\n    assert not hasattr(\n        m, var_name\n    ), \"Conflicting names, relaxation variable already exists on the model.\"\n    var = Variable(self, lb=0, ub=max)\n    setattr(m, var_name, var)\n\n    if self.sense == ConstraintSense.LE:\n        self.lhs -= var\n    elif self.sense == ConstraintSense.GE:\n        self.lhs += var\n    else:  # pragma: no cover\n        # TODO\n        raise NotImplementedError(\n            \"Relaxation for equalities has not yet been implemented. Submit a pull request!\"\n        )\n\n    penalty = var * cost\n    if self.dimensions:\n        penalty = sum(self.dimensions, penalty)\n    if m.sense is None:\n        raise ValueError(\n            \"Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\"\n        )\n    elif m.sense == ObjSense.MAX:\n        penalty *= -1\n    if m.objective is None:\n        m.objective = penalty\n    else:\n        m.objective += penalty\n\n    return self\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression","title":"<code>Expression(data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A linear or quadratic expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.Time = pf.Variable(df.index)\n&gt;&gt;&gt; m.Size = pf.Variable(df.index)\n&gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n&gt;&gt;&gt; expr\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n[1,mon]: Time[1,mon] + Size[1,mon]\n[1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n[1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n[2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n[2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, data: pl.DataFrame):\n    \"\"\"\n    A linear expression.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.Time = pf.Variable(df.index)\n        &gt;&gt;&gt; m.Size = pf.Variable(df.index)\n        &gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n        &gt;&gt;&gt; expr\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n        [1,mon]: Time[1,mon] + Size[1,mon]\n        [1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n        [1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n        [2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n        [2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n    \"\"\"\n    # Sanity checks, VAR_KEY and COEF_KEY must be present\n    assert VAR_KEY in data.columns, \"Missing variable column.\"\n    assert COEF_KEY in data.columns, \"Missing coefficient column.\"\n\n    # Sanity check no duplicates indices\n    if Config.enable_is_duplicated_expression_safety_check:\n        duplicated_mask = data.drop(COEF_KEY).is_duplicated()\n        # In theory this should never happen unless there's a bug in the library\n        if duplicated_mask.any():  # pragma: no cover\n            duplicated_data = data.filter(duplicated_mask)\n            raise ValueError(\n                f\"Cannot create an expression with duplicate indices:\\n{duplicated_data}.\"\n            )\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.is_quadratic","title":"<code>is_quadratic</code>  <code>property</code>","text":"<p>Returns True if the expression is quadratic, False otherwise.</p> <p>Computes in O(1) since expressions are quadratic if and only if self.data contain the QUAD_VAR_KEY column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}) * m.v\n&gt;&gt;&gt; expr *= m.v\n&gt;&gt;&gt; expr.is_quadratic\nTrue\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.__add__","title":"<code>__add__(other)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1,2,3], \"add\": [10, 20, 30]}).to_expr()\n&gt;&gt;&gt; m.v = Variable(add)\n&gt;&gt;&gt; m.v + add\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: v[1] +10\n[2]: v[2] +20\n[3]: v[3] +30\n&gt;&gt;&gt; m.v + add + 2\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: v[1] +12\n[2]: v[2] +22\n[3]: v[3] +32\n&gt;&gt;&gt; m.v + pd.DataFrame({\"dim1\": [1,2], \"add\": [10, 20]})\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim1_right \u2502\n\u2502 ---  \u2506 ---        \u2502\n\u2502 i64  \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3    \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.v2 = Variable()\n&gt;&gt;&gt; 5 + 2 * m.v2\n&lt;Expression size=1 dimensions={} terms=2&gt;\n2 v2 +5\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1,2,3], \"add\": [10, 20, 30]}).to_expr()\n        &gt;&gt;&gt; m.v = Variable(add)\n        &gt;&gt;&gt; m.v + add\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: v[1] +10\n        [2]: v[2] +20\n        [3]: v[3] +30\n        &gt;&gt;&gt; m.v + add + 2\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: v[1] +12\n        [2]: v[2] +22\n        [3]: v[3] +32\n        &gt;&gt;&gt; m.v + pd.DataFrame({\"dim1\": [1,2], \"add\": [10, 20]})\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (1, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim1_right \u2502\n        \u2502 ---  \u2506 ---        \u2502\n        \u2502 i64  \u2506 i64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 3    \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; m.v2 = Variable()\n        &gt;&gt;&gt; 5 + 2 * m.v2\n        &lt;Expression size=1 dimensions={} terms=2&gt;\n        2 v2 +5\n    \"\"\"\n    if isinstance(other, str):\n        raise ValueError(\n            \"Cannot add a string to an expression. Perhaps you meant to use pf.sum() instead of sum()?\"\n        )\n    if isinstance(other, (int, float)):\n        return self._add_const(other)\n    other = other.to_expr()\n    self._learn_from_other(other)\n    return _add_expressions(self, other)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression._add_const","title":"<code>_add_const(const)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.x1 = Variable()\n&gt;&gt;&gt; m.x2 = Variable()\n&gt;&gt;&gt; m.x1 + 5\n&lt;Expression size=1 dimensions={} terms=2&gt;\nx1 +5\n&gt;&gt;&gt; m.x1 ** 2 + 5\n&lt;Expression size=1 dimensions={} terms=2 degree=2&gt;\nx1 * x1 +5\n&gt;&gt;&gt; m.x1 ** 2 + m.x2 + 5\n&lt;Expression size=1 dimensions={} terms=3 degree=2&gt;\nx1 * x1 + x2 +5\n</code></pre> <p>It also works with dimensions</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable({\"dim1\": [1, 2, 3]})\n&gt;&gt;&gt; m.v * m.v + 5\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6 degree=2&gt;\n[1]: 5  + v[1] * v[1]\n[2]: 5  + v[2] * v[2]\n[3]: 5  + v[3] * v[3]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def _add_const(self, const: int | float) -&gt; Expression:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.x1 = Variable()\n        &gt;&gt;&gt; m.x2 = Variable()\n        &gt;&gt;&gt; m.x1 + 5\n        &lt;Expression size=1 dimensions={} terms=2&gt;\n        x1 +5\n        &gt;&gt;&gt; m.x1 ** 2 + 5\n        &lt;Expression size=1 dimensions={} terms=2 degree=2&gt;\n        x1 * x1 +5\n        &gt;&gt;&gt; m.x1 ** 2 + m.x2 + 5\n        &lt;Expression size=1 dimensions={} terms=3 degree=2&gt;\n        x1 * x1 + x2 +5\n\n        It also works with dimensions\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = Variable({\"dim1\": [1, 2, 3]})\n        &gt;&gt;&gt; m.v * m.v + 5\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6 degree=2&gt;\n        [1]: 5  + v[1] * v[1]\n        [2]: 5  + v[2] * v[2]\n        [3]: 5  + v[3] * v[3]\n    \"\"\"\n    dim = self.dimensions\n    data = self.data\n    # Fill in missing constant terms\n    if not dim:\n        if CONST_TERM not in data[VAR_KEY]:\n            const_df = pl.DataFrame(\n                {COEF_KEY: [0.0], VAR_KEY: [CONST_TERM]},\n                schema={COEF_KEY: pl.Float64, VAR_KEY: KEY_TYPE},\n            )\n            if self.is_quadratic:\n                const_df = const_df.with_columns(\n                    pl.lit(CONST_TERM).alias(QUAD_VAR_KEY).cast(KEY_TYPE)\n                )\n            data = pl.concat(\n                [data, const_df],\n                how=\"vertical_relaxed\",\n            )\n    else:\n        keys = (\n            data.select(dim)\n            .unique(maintain_order=True)\n            .with_columns(pl.lit(CONST_TERM).alias(VAR_KEY).cast(KEY_TYPE))\n        )\n        if self.is_quadratic:\n            keys = keys.with_columns(\n                pl.lit(CONST_TERM).alias(QUAD_VAR_KEY).cast(KEY_TYPE)\n            )\n        if POLARS_VERSION.major &gt;= 1:\n            data = data.join(\n                keys, on=dim + self._variable_columns, how=\"full\", coalesce=True\n            )\n        else:\n            data = data.join(\n                keys, on=dim + self._variable_columns, how=\"outer_coalesce\"\n            )\n        data = data.with_columns(pl.col(COEF_KEY).fill_null(0.0))\n\n    data = data.with_columns(\n        pl.when(pl.col(VAR_KEY) == CONST_TERM)\n        .then(pl.col(COEF_KEY) + const)\n        .otherwise(pl.col(COEF_KEY))\n    )\n\n    return self._new(data)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.constant","title":"<code>constant(constant)</code>  <code>classmethod</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Expression.constant(5)\n&lt;Expression size=1 dimensions={} terms=1&gt;\n5\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>@classmethod\ndef constant(cls, constant: int | float) -&gt; \"Expression\":\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; pf.Expression.constant(5)\n        &lt;Expression size=1 dimensions={} terms=1&gt;\n        5\n    \"\"\"\n    return cls(\n        pl.DataFrame(\n            {\n                COEF_KEY: [constant],\n                VAR_KEY: [CONST_TERM],\n            },\n            schema={COEF_KEY: pl.Float64, VAR_KEY: KEY_TYPE},\n        )\n    )\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.degree","title":"<code>degree()</code>","text":"<p>Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v1 = pf.Variable()\n&gt;&gt;&gt; m.v2 = pf.Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n&gt;&gt;&gt; expr.degree()\n0\n&gt;&gt;&gt; expr *= m.v1\n&gt;&gt;&gt; expr.degree()\n1\n&gt;&gt;&gt; expr += (m.v2 ** 2).add_dim(\"dim1\")\n&gt;&gt;&gt; expr.degree()\n2\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def degree(self) -&gt; int:\n    \"\"\"\n    Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v1 = pf.Variable()\n        &gt;&gt;&gt; m.v2 = pf.Variable()\n        &gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n        &gt;&gt;&gt; expr.degree()\n        0\n        &gt;&gt;&gt; expr *= m.v1\n        &gt;&gt;&gt; expr.degree()\n        1\n        &gt;&gt;&gt; expr += (m.v2 ** 2).add_dim(\"dim1\")\n        &gt;&gt;&gt; expr.degree()\n        2\n    \"\"\"\n    if self.is_quadratic:\n        return 2\n    elif (self.data.get_column(VAR_KEY) != CONST_TERM).any():\n        return 1\n    else:\n        return 0\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.evaluate","title":"<code>evaluate()</code>","text":"<p>The value of the expression. Only available after the model has been solved.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, ub=10)\n&gt;&gt;&gt; m.expr_1 = 2 * m.X + 1\n&gt;&gt;&gt; m.expr_2 = pf.sum(m.expr_1)\n&gt;&gt;&gt; m.maximize = m.expr_2 - 3\n&gt;&gt;&gt; m.attr.Silent = True\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.expr_1.evaluate()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 21.0     \u2502\n\u2502 2    \u2506 21.0     \u2502\n\u2502 3    \u2506 21.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.expr_2.evaluate()\n63.0\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>@unwrap_single_values\ndef evaluate(self) -&gt; pl.DataFrame:\n    \"\"\"\n    The value of the expression. Only available after the model has been solved.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, ub=10)\n        &gt;&gt;&gt; m.expr_1 = 2 * m.X + 1\n        &gt;&gt;&gt; m.expr_2 = pf.sum(m.expr_1)\n        &gt;&gt;&gt; m.maximize = m.expr_2 - 3\n        &gt;&gt;&gt; m.attr.Silent = True\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.expr_1.evaluate()\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 solution \u2502\n        \u2502 ---  \u2506 ---      \u2502\n        \u2502 i64  \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 21.0     \u2502\n        \u2502 2    \u2506 21.0     \u2502\n        \u2502 3    \u2506 21.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; m.expr_2.evaluate()\n        63.0\n    \"\"\"\n    assert (\n        self._model is not None\n    ), \"Expression must be added to the model to use .value\"\n\n    df = self.data\n    sm = self._model.poi\n    attr = poi.VariableAttribute.Value\n    for var_col in self._variable_columns:\n        df = df.with_columns(\n            (\n                pl.col(COEF_KEY)\n                * pl.col(var_col).map_elements(\n                    lambda v_id: (\n                        sm.get_variable_attribute(poi.VariableIndex(v_id), attr)\n                        if v_id != CONST_TERM\n                        else 1\n                    ),\n                    return_dtype=pl.Float64,\n                )\n            ).alias(COEF_KEY)\n        ).drop(var_col)\n\n    df = df.rename({COEF_KEY: SOLUTION_KEY})\n\n    dims = self.dimensions\n    if dims is not None:\n        df = df.group_by(dims, maintain_order=True)\n    return df.sum()\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.map","title":"<code>map(mapping_set, drop_shared_dims=True)</code>","text":"<p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <p>This is particularly useful to go from one type of dimensions to another. For example, to convert data that is indexed by city to data indexed by country (see example).</p> <p>Parameters:</p> Name Type Description Default <code>mapping_set</code> <code>SetTypes</code> <p>The set to map the expression to. This can be a DataFrame, Index, or another Set.</p> required <code>drop_shared_dims</code> <code>bool</code> <p>If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and     repeated rows are summed. If False, the shared dimensions are kept in the resulting expression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression containing the result of the mapping operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; pop_data = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"year\": [2024, 2024, 2024], \"population\": [10, 2, 8]}).to_expr()\n&gt;&gt;&gt; cities_and_countries = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"country\": [\"Canada\", \"Canada\", \"USA\"]})\n&gt;&gt;&gt; pop_data.map(cities_and_countries)\n&lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n[2024,Canada]: 12\n[2024,USA]: 8\n&gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n&lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n[Toronto,2024,Canada]: 10\n[Vancouver,2024,Canada]: 2\n[Boston,2024,USA]: 8\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def map(self, mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression:\n    \"\"\"\n    Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.\n\n    This is particularly useful to go from one type of dimensions to another. For example, to convert data that\n    is indexed by city to data indexed by country (see example).\n\n    Parameters:\n        mapping_set:\n            The set to map the expression to. This can be a DataFrame, Index, or another Set.\n        drop_shared_dims:\n            If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and\n                repeated rows are summed.\n            If False, the shared dimensions are kept in the resulting expression.\n\n    Returns:\n        A new Expression containing the result of the mapping operation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; pop_data = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"year\": [2024, 2024, 2024], \"population\": [10, 2, 8]}).to_expr()\n        &gt;&gt;&gt; cities_and_countries = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"country\": [\"Canada\", \"Canada\", \"USA\"]})\n        &gt;&gt;&gt; pop_data.map(cities_and_countries)\n        &lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n        [2024,Canada]: 12\n        [2024,USA]: 8\n        &gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n        &lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n        [Toronto,2024,Canada]: 10\n        [Vancouver,2024,Canada]: 2\n        [Boston,2024,USA]: 8\n    \"\"\"\n    mapping_set = Set(mapping_set)\n\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot use .map() on an expression with no dimensions.\")\n\n    mapping_dims = mapping_set.dimensions\n    if mapping_dims is None:\n        raise ValueError(\n            \"Cannot use .map() with a mapping set containing no dimensions.\"\n        )\n\n    shared_dims = [dim for dim in dims if dim in mapping_dims]\n    if not shared_dims:\n        raise ValueError(\n            f\"Cannot apply .map() as there are no shared dimensions between the expression (dims={self.dimensions}) and the mapping set (dims={mapping_set.dimensions}).\"\n        )\n\n    mapped_expression = self * mapping_set\n\n    if drop_shared_dims:\n        return sum(shared_dims, mapped_expression)\n\n    return mapped_expression\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.rolling_sum","title":"<code>rolling_sum(over, window_size)</code>","text":"<p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <p>This method applies a rolling sum operation over the dimension specified by <code>over</code>, using a window defined by <code>window_size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>over</code> <p>The name of the dimension (column) over which the rolling sum is calculated. This dimension must exist within the Expression's dimensions.</p> required <code>window_size</code> <p>The size of the moving window in terms of number of records. The rolling sum is calculated over this many consecutive elements.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression instance containing the result of the rolling sum operation. This new Expression retains all dimensions (columns) of the original data, with the rolling sum applied over the specified dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; cost = pl.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [1, 2, 3, 1, 2], \"cost\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n&gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n[1,1]: quantity[1,1]\n[1,2]: quantity[1,1] +2 quantity[1,2]\n[1,3]: 2 quantity[1,2] +3 quantity[1,3]\n[2,1]: 4 quantity[2,1]\n[2,2]: 4 quantity[2,1] +5 quantity[2,2]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def rolling_sum(self, over: str, window_size: int) -&gt; Expression:\n    \"\"\"\n    Calculates the rolling sum of the Expression over a specified window size for a given dimension.\n\n    This method applies a rolling sum operation over the dimension specified by `over`,\n    using a window defined by `window_size`.\n\n\n    Parameters:\n        over :\n            The name of the dimension (column) over which the rolling sum is calculated.\n            This dimension must exist within the Expression's dimensions.\n        window_size :\n            The size of the moving window in terms of number of records.\n            The rolling sum is calculated over this many consecutive elements.\n\n    Returns:\n        A new Expression instance containing the result of the rolling sum operation.\n            This new Expression retains all dimensions (columns) of the original data,\n            with the rolling sum applied over the specified dimension.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; cost = pl.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [1, 2, 3, 1, 2], \"cost\": [1, 2, 3, 4, 5]})\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n        &gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n        [1,1]: quantity[1,1]\n        [1,2]: quantity[1,1] +2 quantity[1,2]\n        [1,3]: 2 quantity[1,2] +3 quantity[1,3]\n        [2,1]: 4 quantity[2,1]\n        [2,2]: 4 quantity[2,1] +5 quantity[2,2]\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\n            \"Cannot use rolling_sum() with an expression with no dimensions.\"\n        )\n    assert over in dims, f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        pl.concat(\n            [\n                df.with_columns(pl.col(over).max())\n                for _, df in self.data.rolling(\n                    index_column=over,\n                    period=f\"{window_size}i\",\n                    group_by=remaining_dims,\n                )\n            ]\n        )\n    )\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.sum","title":"<code>sum(over)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m.quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n&gt;&gt;&gt; expr = (m.quantity * df[\"cost\"]).sum(\"time\")\n&gt;&gt;&gt; expr.data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0     \u2506 1             \u2502\n\u2502 2    \u2506 9.0     \u2506 2             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def sum(self, over: Union[str, Iterable[str]]):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; m.quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n        &gt;&gt;&gt; expr = (m.quantity * df[\"cost\"]).sum(\"time\")\n        &gt;&gt;&gt; expr.data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 6.0     \u2506 1             \u2502\n        \u2502 2    \u2506 9.0     \u2506 2             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if isinstance(over, str):\n        over = [over]\n    dims = self.dimensions\n    if not dims:\n        raise ValueError(\n            f\"Cannot sum over dimensions {over} since the current expression has no dimensions.\"\n        )\n    assert set(over) &lt;= set(dims), f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        self.data.drop(over)\n        .group_by(remaining_dims + self._variable_columns, maintain_order=True)\n        .sum()\n    )\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.within","title":"<code>within(set)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; general_expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n&gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n&gt;&gt;&gt; general_expr.within(filter_expr).data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0     \u2506 0             \u2502\n\u2502 3    \u2506 3.0     \u2506 0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def within(self, set: \"SetTypes\") -&gt; Expression:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; general_expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n        &gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n        &gt;&gt;&gt; general_expr.within(filter_expr).data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0     \u2506 0             \u2502\n        \u2502 3    \u2506 3.0     \u2506 0             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df: pl.DataFrame = Set(set).data\n    set_dims = _get_dimensions(df)\n    assert (\n        set_dims is not None\n    ), \"Cannot use .within() with a set with no dimensions.\"\n    dims = self.dimensions\n    assert (\n        dims is not None\n    ), \"Cannot use .within() with an expression with no dimensions.\"\n    dims_in_common = [dim for dim in dims if dim in set_dims]\n    by_dims = df.select(dims_in_common).unique(maintain_order=True)\n    return self._new(self.data.join(by_dims, on=dims_in_common))\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Set","title":"<code>Set(*data, **named_data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A set which can then be used to index variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Set(x=range(2), y=range(3))\n&lt;Set size=6 dimensions={'x': 2, 'y': 3}&gt;\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, *data: SetTypes | Iterable[SetTypes], **named_data):\n    data_list = list(data)\n    for name, set in named_data.items():\n        data_list.append({name: set})\n    df = self._parse_acceptable_sets(*data_list)\n    if not df.is_empty() and df.is_duplicated().any():\n        raise ValueError(\"Duplicate rows found in input data.\")\n    super().__init__(df)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Set._parse_acceptable_sets","title":"<code>_parse_acceptable_sets(*over)</code>  <code>staticmethod</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; dim1 = pd.Index([1, 2, 3], name=\"dim1\")\n&gt;&gt;&gt; dim2 = pd.Index([\"a\", \"b\"], name=\"dim1\")\n&gt;&gt;&gt; Set._parse_acceptable_sets([dim1, dim2])\nTraceback (most recent call last):\n...\nAssertionError: All coordinates must have unique column names.\n&gt;&gt;&gt; dim2.name = \"dim2\"\n&gt;&gt;&gt; Set._parse_acceptable_sets([dim1, dim2])\nshape: (6, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2502\n\u2502 1    \u2506 b    \u2502\n\u2502 2    \u2506 a    \u2502\n\u2502 2    \u2506 b    \u2502\n\u2502 3    \u2506 a    \u2502\n\u2502 3    \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>@staticmethod\ndef _parse_acceptable_sets(\n    *over: SetTypes | Iterable[SetTypes],\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; dim1 = pd.Index([1, 2, 3], name=\"dim1\")\n        &gt;&gt;&gt; dim2 = pd.Index([\"a\", \"b\"], name=\"dim1\")\n        &gt;&gt;&gt; Set._parse_acceptable_sets([dim1, dim2])\n        Traceback (most recent call last):\n        ...\n        AssertionError: All coordinates must have unique column names.\n        &gt;&gt;&gt; dim2.name = \"dim2\"\n        &gt;&gt;&gt; Set._parse_acceptable_sets([dim1, dim2])\n        shape: (6, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim2 \u2502\n        \u2502 ---  \u2506 ---  \u2502\n        \u2502 i64  \u2506 str  \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 a    \u2502\n        \u2502 1    \u2506 b    \u2502\n        \u2502 2    \u2506 a    \u2502\n        \u2502 2    \u2506 b    \u2502\n        \u2502 3    \u2506 a    \u2502\n        \u2502 3    \u2506 b    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    assert len(over) &gt; 0, \"At least one set must be provided.\"\n    over_iter: Iterable[SetTypes] = parse_inputs_as_iterable(*over)\n\n    over_frames: List[pl.DataFrame] = [Set._set_to_polars(set) for set in over_iter]\n\n    over_merged = over_frames[0]\n\n    for df in over_frames[1:]:\n        assert (\n            set(over_merged.columns) &amp; set(df.columns) == set()\n        ), \"All coordinates must have unique column names.\"\n        over_merged = over_merged.join(df, how=\"cross\")\n    return over_merged\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath","title":"<code>SupportsMath(**kwargs)</code>","text":"<p>               Bases: <code>ABC</code>, <code>SupportsToExpr</code></p> <p>Any object that can be converted into an expression.</p> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, **kwargs):\n    self.unmatched_strategy = UnmatchedStrategy.UNSET\n    self.allowed_new_dims: List[str] = []\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__eq__","title":"<code>__eq__(value)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable()\n&gt;&gt;&gt; m.v == 1\n&lt;Constraint sense='=' size=1 dimensions={} terms=2&gt;\nv = 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __eq__(self, value: object):  # type: ignore\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable()\n        &gt;&gt;&gt; m.v == 1\n        &lt;Constraint sense='=' size=1 dimensions={} terms=2&gt;\n        v = 1\n    \"\"\"\n    return Constraint(self - value, ConstraintSense.EQ)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable()\n&gt;&gt;&gt; m.v &gt;= 1\n&lt;Constraint sense='&gt;=' size=1 dimensions={} terms=2&gt;\nv &gt;= 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __ge__(self, other):\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable()\n        &gt;&gt;&gt; m.v &gt;= 1\n        &lt;Constraint sense='&gt;=' size=1 dimensions={} terms=2&gt;\n        v &gt;= 1\n    \"\"\"\n    return Constraint(self - other, ConstraintSense.GE)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__le__","title":"<code>__le__(other)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable()\n&gt;&gt;&gt; m.v &lt;= 1\n&lt;Constraint sense='&lt;=' size=1 dimensions={} terms=2&gt;\nv &lt;= 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __le__(self, other):\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable()\n        &gt;&gt;&gt; m.v &lt;= 1\n        &lt;Constraint sense='&lt;=' size=1 dimensions={} terms=2&gt;\n        v &lt;= 1\n    \"\"\"\n    return Constraint(self - other, ConstraintSense.LE)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Support squaring expressions:</p> <p>m = pf.Model() m.v = pf.Variable() m.v ** 2  v * v m.v ** 3 Traceback (most recent call last): ... ValueError: Raising an expressions to 3 is not supported. Expressions can only be squared (2). Source code in <code>pyoframe/core.py</code> <pre><code>def __pow__(self, power: int):\n    \"\"\"\n    Support squaring expressions:\n    &gt;&gt;&gt; m = pf.Model()\n    &gt;&gt;&gt; m.v = pf.Variable()\n    &gt;&gt;&gt; m.v ** 2\n    &lt;Expression size=1 dimensions={} terms=1 degree=2&gt;\n    v * v\n    &gt;&gt;&gt; m.v ** 3\n    Traceback (most recent call last):\n    ...\n    ValueError: Raising an expressions to **3 is not supported. Expressions can only be squared (**2).\n    \"\"\"\n    if power == 2:\n        return self * self\n    raise ValueError(\n        f\"Raising an expressions to **{power} is not supported. Expressions can only be squared (**2).\"\n    )\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__rsub__","title":"<code>__rsub__(other)</code>","text":"<p>Support right subtraction.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable({\"dim1\": [1,2,3]})\n&gt;&gt;&gt; 1 - m.v\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: 1  - v[1]\n[2]: 1  - v[2]\n[3]: 1  - v[3]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __rsub__(self, other):\n    \"\"\"\n    Support right subtraction.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = Variable({\"dim1\": [1,2,3]})\n        &gt;&gt;&gt; 1 - m.v\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: 1  - v[1]\n        [2]: 1  - v[2]\n        [3]: 1  - v[3]\n    \"\"\"\n    return other + (-self.to_expr())\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__sub__","title":"<code>__sub__(other)</code>","text":"<p>import polars as pl m = pf.Model() df = pl.DataFrame({\"dim1\": [1,2,3], \"value\": [1,2,3]}) m.v = pf.Variable(df[\"dim1\"]) m.v - df  [1]: v[1] -1 [2]: v[2] -2 [3]: v[3] -3 Source code in <code>pyoframe/core.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"\n    &gt;&gt;&gt; import polars as pl\n    &gt;&gt;&gt; m = pf.Model()\n    &gt;&gt;&gt; df = pl.DataFrame({\"dim1\": [1,2,3], \"value\": [1,2,3]})\n    &gt;&gt;&gt; m.v = pf.Variable(df[\"dim1\"])\n    &gt;&gt;&gt; m.v - df\n    &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n    [1]: v[1] -1\n    [2]: v[2] -2\n    [3]: v[3] -3\n    \"\"\"\n    if not isinstance(other, (int, float)):\n        other = other.to_expr()\n    return self.to_expr() + (-other)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Examples:</p> <p>Support division.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable({\"dim1\": [1,2,3]})\n&gt;&gt;&gt; m.v / 2\n&lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt;\n[1]: 0.5 v[1]\n[2]: 0.5 v[2]\n[3]: 0.5 v[3]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"\n\n    Examples:\n        Support division.\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = Variable({\"dim1\": [1,2,3]})\n        &gt;&gt;&gt; m.v / 2\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt;\n        [1]: 0.5 v[1]\n        [2]: 0.5 v[2]\n        [3]: 0.5 v[3]\n    \"\"\"\n    return self.to_expr() * (1 / other)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Variable","title":"<code>Variable(*indexing_sets, lb=None, ub=None, vtype=VType.CONTINUOUS, equals=None)</code>","text":"<p>               Bases: <code>ModelElementWithId</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>Represents one or many decision variable in an optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>*indexing_sets</code> <code>SetTypes | Iterable[SetTypes]</code> <p>If no indexing_sets are provided, a single variable with no dimensions is created. Otherwise, a variable is created for each element in the Cartesian product of the indexing_sets (see Set for details on behaviour).</p> <code>()</code> <code>lb</code> <code>float | int | SupportsToExpr | None</code> <p>The lower bound for all variables.</p> <code>None</code> <code>ub</code> <code>float | int | SupportsToExpr | None</code> <p>The upper bound for all variables.</p> <code>None</code> <code>vtype</code> <code>VType | VTypeValue</code> <p>The type of the variable. Can be either a VType enum or a string. Default is VType.CONTINUOUS.</p> <code>CONTINUOUS</code> <code>equals</code> <code>Optional[SupportsMath]</code> <p>When specified, a variable is created and a constraint is added to make the variable equal to the provided expression.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; df = pd.DataFrame({\"dim1\": [1, 1, 2, 2, 3, 3], \"dim2\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]})\n&gt;&gt;&gt; v = Variable(df)\n&gt;&gt;&gt; v\n&lt;Variable size=6 dimensions={'dim1': 3, 'dim2': 2} added_to_model=False&gt;\n</code></pre> <p>Variables cannot be used until they're added to the model.</p> <pre><code>&gt;&gt;&gt; m.constraint = v &lt;= 3\nTraceback (most recent call last):\n...\nValueError: Cannot use 'Variable' before it has beed added to a model.\n&gt;&gt;&gt; m.v = v\n&gt;&gt;&gt; m.constraint = m.v &lt;= 3\n</code></pre> <pre><code>&gt;&gt;&gt; m.v\n&lt;Variable name=v size=6 dimensions={'dim1': 3, 'dim2': 2}&gt;\n[1,a]: v[1,a]\n[1,b]: v[1,b]\n[2,a]: v[2,a]\n[2,b]: v[2,b]\n[3,a]: v[3,a]\n[3,b]: v[3,b]\n&gt;&gt;&gt; m.v2 = Variable(df[[\"dim1\"]])\nTraceback (most recent call last):\n...\nValueError: Duplicate rows found in input data.\n&gt;&gt;&gt; m.v3 = Variable(df[[\"dim1\"]].drop_duplicates())\n&gt;&gt;&gt; m.v3\n&lt;Variable name=v3 size=3 dimensions={'dim1': 3}&gt;\n[1]: v3[1]\n[2]: v3[2]\n[3]: v3[3]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(\n    self,\n    *indexing_sets: SetTypes | Iterable[SetTypes],\n    lb: float | int | SupportsToExpr | None = None,\n    ub: float | int | SupportsToExpr | None = None,\n    vtype: VType | VTypeValue = VType.CONTINUOUS,\n    equals: Optional[SupportsMath] = None,\n):\n    if equals is not None:\n        assert (\n            len(indexing_sets) == 0\n        ), \"Cannot specify both 'equals' and 'indexing_sets'\"\n        indexing_sets = (equals,)\n\n    data = Set(*indexing_sets).data if len(indexing_sets) &gt; 0 else pl.DataFrame()\n    super().__init__(data)\n\n    self.vtype: VType = VType(vtype)\n    self.attr = Container(self._set_attribute, self._get_attribute)\n    self._equals = equals\n\n    if lb is not None and not isinstance(lb, (float, int)):\n        self._lb_expr, self.lb = lb, None\n    else:\n        self._lb_expr, self.lb = None, lb\n    if ub is not None and not isinstance(ub, (float, int)):\n        self._ub_expr, self.ub = ub, None\n    else:\n        self._ub_expr, self.ub = None, ub\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Variable.next","title":"<code>next(dim, wrap_around=False)</code>","text":"<p>Creates an expression where the variable at each index is the next variable in the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>str</code> <p>The dimension over which to shift the variable.</p> required <code>wrap_around</code> <code>bool</code> <p>If True, the last index in the dimension is connected to the first index.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n&gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; # Fails because the dimensions are not the same\n&gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n\u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n\u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\"time\")\n&lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\"time\", wrap_around=True)\n&lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n[18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n[18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def next(self, dim: str, wrap_around: bool = False) -&gt; Expression:\n    \"\"\"\n    Creates an expression where the variable at each index is the next variable in the specified dimension.\n\n    Parameters:\n        dim:\n            The dimension over which to shift the variable.\n        wrap_around:\n            If True, the last index in the dimension is connected to the first index.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n        &gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; # Fails because the dimensions are not the same\n        &gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (2, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n        \u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n        \u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\"time\")\n        &lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\"time\", wrap_around=True)\n        &lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n        [18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n        [18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n    \"\"\"\n\n    wrapped = self.data.select(dim).unique(maintain_order=True).sort(by=dim)\n    wrapped = wrapped.with_columns(pl.col(dim).shift(-1).alias(\"__next\"))\n    if wrap_around:\n        wrapped = wrapped.with_columns(pl.col(\"__next\").fill_null(pl.first(dim)))\n    else:\n        wrapped = wrapped.drop_nulls(dim)\n\n    expr = self.to_expr()\n    data = expr.data.rename({dim: \"__prev\"})\n\n    if POLARS_VERSION.major &lt; 1:\n        data = data.join(\n            wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n        ).drop([\"__prev\", \"__next\"])\n    else:\n        data = data.join(\n            wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n        ).drop([\"__prev\", \"__next\"], strict=False)\n    return expr._new(data)\n</code></pre>"},{"location":"reference/model/","title":"model","text":""},{"location":"reference/model/#pyoframe.model.Model","title":"<code>Model(name=None, solver=None, solver_env=None, use_var_names=False, sense=None)</code>","text":"<p>The object that holds all the variables, constraints, and the objective.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The name of the model. Currently it is not used for much.</p> <code>None</code> <code>solver</code> <code>Optional[SUPPORTED_SOLVER_TYPES]</code> <p>The solver to use. If <code>None</code>, <code>Config.default_solver</code> will be used. If <code>Config.default_solver</code> has not been set (<code>None</code>), Pyoframe will try to detect whichever solver is already installed.</p> <code>None</code> <code>solver_env</code> <code>Optional[Dict[str, str]]</code> <p>Gurobi only: a dictionary of parameters to set when creating the Gurobi environment.</p> <code>None</code> <code>use_var_names</code> <p>Whether to pass variable names to the solver. Set to <code>True</code> if you'd like outputs from e.g. <code>Model.write()</code> to be legible.</p> <code>False</code> <code>sense</code> <code>Union[ObjSense, ObjSenseValue, None]</code> <p>Either \"min\" or \"max\". Indicates whether it's a minmization or maximization problem. Typically, this parameter can be omitted (<code>None</code>) as it will automatically be set when the objective is set using <code>.minimize</code> or <code>.maximize</code>.</p> <code>None</code> Example <p>m = pf.Model() m.X = pf.Variable() m.my_constraint = m.X &lt;= 10 m  <p>Try setting the Gurobi license:</p> <p>m = pf.Model(solver=\"gurobi\", solver_env=dict(ComputeServer=\"myserver\", ServerPassword=\"mypassword\")) Traceback (most recent call last): ... RuntimeError: Could not resolve host: myserver (code 6, command POST http://myserver/api/v1/cluster/jobs)</p> Source code in <code>pyoframe/model.py</code> <pre><code>def __init__(\n    self,\n    name=None,\n    solver: Optional[SUPPORTED_SOLVER_TYPES] = None,\n    solver_env: Optional[Dict[str, str]] = None,\n    use_var_names=False,\n    sense: Union[ObjSense, ObjSenseValue, None] = None,\n):\n    self.poi, self.solver_name = Model.create_poi_model(solver, solver_env)\n    self._variables: List[Variable] = []\n    self._constraints: List[Constraint] = []\n    self.sense = ObjSense(sense) if sense is not None else None\n    self._objective: Optional[Objective] = None\n    self.var_map = (\n        NamedVariableMapper(Variable) if Config.print_uses_variable_names else None\n    )\n    self.name = name\n\n    self.params = Container(self._set_param, self._get_param)\n    self.attr = Container(self._set_attr, self._get_attr)\n    self._use_var_names = use_var_names\n</code></pre>"},{"location":"reference/model/#pyoframe.model.Model.binary_variables","title":"<code>binary_variables</code>  <code>property</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.binary_variables))\n1\n</code></pre>"},{"location":"reference/model/#pyoframe.model.Model.integer_variables","title":"<code>integer_variables</code>  <code>property</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.INTEGER)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.integer_variables))\n1\n</code></pre>"},{"location":"reference/model/#pyoframe.model.Model.compute_IIS","title":"<code>compute_IIS()</code>","text":"<p>Computes the Irreducible Infeasible Set (IIS) of the model.</p> <p>Gurobi only</p> <p>This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.</p> Example <p>m = pf.Model(solver=\"gurobi\") m.X = pf.Variable(lb=0, ub=2) m.Y = pf.Variable(lb=0, ub=2) m.bad_constraint = m.X &gt;= 3 m.minimize = m.X + m.Y m.optimize() m.attr.TerminationStatus  m.bad_constraint.attr.IIS Traceback (most recent call last): ... polars.exceptions.ComputeError: RuntimeError: Unable to retrieve attribute 'IISConstr' m.compute_IIS() m.bad_constraint.attr.IIS True Source code in <code>pyoframe/model.py</code> <pre><code>@for_solvers(\"gurobi\", \"copt\")\ndef compute_IIS(self):\n    \"\"\"\n    Computes the Irreducible Infeasible Set (IIS) of the model.\n\n    !!! warning \"Gurobi only\"\n        This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.\n\n    Example:\n        &gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.Y = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.bad_constraint = m.X &gt;= 3\n        &gt;&gt;&gt; m.minimize = m.X + m.Y\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.attr.TerminationStatus\n        &lt;TerminationStatusCode.INFEASIBLE: 3&gt;\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        Traceback (most recent call last):\n        ...\n        polars.exceptions.ComputeError: RuntimeError: Unable to retrieve attribute 'IISConstr'\n        &gt;&gt;&gt; m.compute_IIS()\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        True\n    \"\"\"\n    self.poi.computeIIS()\n</code></pre>"},{"location":"reference/model/#pyoframe.model.Model.convert_to_fixed","title":"<code>convert_to_fixed()</code>","text":"<p>Turns a mixed integer program into a continuous one by fixing all the integer and binary variables to their solution values.</p> <p>Gurobi only</p> <p>This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.</p> Example <p>m = pf.Model(solver=\"gurobi\") m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0) m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0) m.Z = pf.Variable(lb=0) m.my_constraint = m.X + m.Y + m.Z &lt;= 10 m.maximize = 3 * m.X + 2 * m.Y + m.Z m.optimize() m.X.solution, m.Y.solution, m.Z.solution (1.0, 9.0, 0.0) m.my_constraint.dual Traceback (most recent call last): ... polars.exceptions.ComputeError: RuntimeError: Unable to retrieve attribute 'Pi' m.convert_to_fixed() m.optimize() m.my_constraint.dual 1.0</p> <p>Only works for Gurobi:</p> <p>m = pf.Model(\"max\", solver=\"highs\") m.convert_to_fixed() Traceback (most recent call last): ... NotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.</p> Source code in <code>pyoframe/model.py</code> <pre><code>@for_solvers(\"gurobi\")\ndef convert_to_fixed(self) -&gt; None:\n    \"\"\"\n    Turns a mixed integer program into a continuous one by fixing\n    all the integer and binary variables to their solution values.\n\n    !!! warning \"Gurobi only\"\n        This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.\n\n    Example:\n        &gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0)\n        &gt;&gt;&gt; m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0)\n        &gt;&gt;&gt; m.Z = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.my_constraint = m.X + m.Y + m.Z &lt;= 10\n        &gt;&gt;&gt; m.maximize = 3 * m.X + 2 * m.Y + m.Z\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.X.solution, m.Y.solution, m.Z.solution\n        (1.0, 9.0, 0.0)\n        &gt;&gt;&gt; m.my_constraint.dual\n        Traceback (most recent call last):\n        ...\n        polars.exceptions.ComputeError: RuntimeError: Unable to retrieve attribute 'Pi'\n        &gt;&gt;&gt; m.convert_to_fixed()\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.my_constraint.dual\n        1.0\n\n        Only works for Gurobi:\n\n        &gt;&gt;&gt; m = pf.Model(\"max\", solver=\"highs\")\n        &gt;&gt;&gt; m.convert_to_fixed()\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.\n    \"\"\"\n    self.poi._converttofixed()\n</code></pre>"},{"location":"reference/model_element/","title":"model_element","text":""},{"location":"reference/model_element/#pyoframe.model_element.ModelElement","title":"<code>ModelElement(data, **kwargs)</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>pyoframe/model_element.py</code> <pre><code>def __init__(self, data: pl.DataFrame, **kwargs) -&gt; None:\n    # Sanity checks, no duplicate column names\n    assert len(data.columns) == len(\n        set(data.columns)\n    ), \"Duplicate column names found.\"\n\n    cols = _get_dimensions(data)\n    if cols is None:\n        cols = []\n    cols += [col for col in RESERVED_COL_KEYS if col in data.columns]\n\n    # Reorder columns to keep things consistent\n    data = data.select(cols)\n\n    # Cast to proper dtype\n    if COEF_KEY in data.columns:\n        data = data.cast({COEF_KEY: pl.Float64})\n    if VAR_KEY in data.columns:\n        data = data.cast({VAR_KEY: KEY_TYPE})\n    if QUAD_VAR_KEY in data.columns:\n        data = data.cast({QUAD_VAR_KEY: KEY_TYPE})\n\n    self._data = data\n    self._model: Optional[Model] = None\n    self.name = None\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElement.dimensions","title":"<code>dimensions</code>  <code>property</code>","text":"<p>The names of the data's dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # A variable with no dimensions\n&gt;&gt;&gt; pf.Variable().dimensions\n</code></pre> <pre><code>&gt;&gt;&gt; # A variable with dimensions of \"hour\" and \"city\"\n&gt;&gt;&gt; pf.Variable([{\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]}, {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}]).dimensions\n['hour', 'city']\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElement.dimensions_unsafe","title":"<code>dimensions_unsafe</code>  <code>property</code>","text":"<p>Same as <code>dimensions</code> but returns an empty list if there are no dimensions instead of None. When unsure, use <code>dimensions</code> instead since the type checker forces users to handle the None case (no dimensions).</p>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElement.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>The number of indices in each dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # A variable with no dimensions\n&gt;&gt;&gt; pf.Variable().shape\n{}\n&gt;&gt;&gt; # A variable with dimensions of \"hour\" and \"city\"\n&gt;&gt;&gt; pf.Variable([{\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]}, {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}]).shape\n{'hour': 4, 'city': 3}\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElementWithId","title":"<code>ModelElementWithId(data, **kwargs)</code>","text":"<p>               Bases: <code>ModelElement</code></p> <p>Provides a method that assigns a unique ID to each row in a DataFrame. IDs start at 1 and go up consecutively. No zero ID is assigned since it is reserved for the constant variable term. IDs are only unique for the subclass since different subclasses have different counters.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>def __init__(self, data: pl.DataFrame, **kwargs) -&gt; None:\n    # Sanity checks, no duplicate column names\n    assert len(data.columns) == len(\n        set(data.columns)\n    ), \"Duplicate column names found.\"\n\n    cols = _get_dimensions(data)\n    if cols is None:\n        cols = []\n    cols += [col for col in RESERVED_COL_KEYS if col in data.columns]\n\n    # Reorder columns to keep things consistent\n    data = data.select(cols)\n\n    # Cast to proper dtype\n    if COEF_KEY in data.columns:\n        data = data.cast({COEF_KEY: pl.Float64})\n    if VAR_KEY in data.columns:\n        data = data.cast({VAR_KEY: KEY_TYPE})\n    if QUAD_VAR_KEY in data.columns:\n        data = data.cast({QUAD_VAR_KEY: KEY_TYPE})\n\n    self._data = data\n    self._model: Optional[Model] = None\n    self.name = None\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElementWithId.get_id_column_name","title":"<code>get_id_column_name()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Returns the name of the column containing the IDs.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_id_column_name(cls) -&gt; str:\n    \"\"\"\n    Returns the name of the column containing the IDs.\n    \"\"\"\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.SupportPolarsMethodMixin","title":"<code>SupportPolarsMethodMixin</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/model_element/#pyoframe.model_element.SupportPolarsMethodMixin._new","title":"<code>_new(data)</code>  <code>abstractmethod</code>","text":"<p>Used to create a new instance of the same class with the given data (for e.g. on .rename(), .with_columns(), etc.).</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>@abstractmethod\ndef _new(self, data: pl.DataFrame):\n    \"\"\"\n    Used to create a new instance of the same class with the given data (for e.g. on .rename(), .with_columns(), etc.).\n    \"\"\"\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.SupportPolarsMethodMixin.pick","title":"<code>pick(**kwargs)</code>","text":"<p>Filters elements by the given criteria and then drops the filtered dimensions.</p> Example <p>m = pf.Model() m.v = pf.Variable([{\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]}, {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}]) m.v.pick(hour=\"06:00\")  <p>m.v.pick(hour=\"06:00\", city=\"Toronto\")  v[06:00,Toronto] Source code in <code>pyoframe/model_element.py</code> <pre><code>def pick(self, **kwargs):\n    \"\"\"\n    Filters elements by the given criteria and then drops the filtered dimensions.\n\n    Example:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable([{\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]}, {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}])\n        &gt;&gt;&gt; m.v.pick(hour=\"06:00\")\n        &lt;Expression size=3 dimensions={'city': 3} terms=3&gt;\n        [Toronto]: v[06:00,Toronto]\n        [Berlin]: v[06:00,Berlin]\n        [Paris]: v[06:00,Paris]\n        &gt;&gt;&gt; m.v.pick(hour=\"06:00\", city=\"Toronto\")\n        &lt;Expression size=1 dimensions={} terms=1&gt;\n        v[06:00,Toronto]\n    \"\"\"\n    return self._new(self.data.filter(**kwargs).drop(kwargs.keys()))\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element._support_polars_method","title":"<code>_support_polars_method(method_name)</code>","text":"<p>Wrapper to add a method to ModelElement that simply calls the underlying Polars method on the data attribute.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>def _support_polars_method(method_name: str):\n    \"\"\"\n    Wrapper to add a method to ModelElement that simply calls the underlying Polars method on the data attribute.\n    \"\"\"\n\n    def method(self: \"SupportPolarsMethodMixin\", *args, **kwargs) -&gt; Any:\n        result_from_polars = getattr(self.data, method_name)(*args, **kwargs)\n        if isinstance(result_from_polars, pl.DataFrame):\n            return self._new(result_from_polars)\n        else:\n            return result_from_polars\n\n    return method\n</code></pre>"},{"location":"reference/monkey_patch/","title":"monkey_patch","text":""},{"location":"reference/monkey_patch/#pyoframe.monkey_patch.patch_dataframe_libraries","title":"<code>patch_dataframe_libraries()</code>","text":"<p>Applies two patches to the DataFrame and Series classes of both pandas and polars. 1) Patches arithmetic operators (e.g. <code>__add__</code>) such that operations between DataFrames/Series and <code>Expressionable</code>s     are not supported (i.e. <code>return NotImplemented</code>). This leads Python to try the reverse operation (e.g. <code>__radd__</code>)     which is supported by the <code>Expressionable</code> class. 2) Adds a <code>to_expr</code> method to DataFrame/Series that allows them to be converted to an <code>Expression</code> object.     Series become dataframes and dataframes become expressions where everything but the last column are treated as dimensions.</p> Source code in <code>pyoframe/monkey_patch.py</code> <pre><code>def patch_dataframe_libraries():\n    \"\"\"\n    Applies two patches to the DataFrame and Series classes of both pandas and polars.\n    1) Patches arithmetic operators (e.g. `__add__`) such that operations between DataFrames/Series and `Expressionable`s\n        are not supported (i.e. `return NotImplemented`). This leads Python to try the reverse operation (e.g. `__radd__`)\n        which is supported by the `Expressionable` class.\n    2) Adds a `to_expr` method to DataFrame/Series that allows them to be converted to an `Expression` object.\n        Series become dataframes and dataframes become expressions where everything but the last column are treated as dimensions.\n    \"\"\"\n    _patch_class(pd.DataFrame)\n    _patch_class(pd.Series)\n    _patch_class(pl.DataFrame)\n    _patch_class(pl.Series)\n    pl.DataFrame.to_expr = _dataframe_to_expr\n    pl.Series.to_expr = lambda self: self.to_frame().to_expr()\n    pd.DataFrame.to_expr = lambda self: pl.from_pandas(self).to_expr()\n    pd.Series.to_expr = lambda self: self.to_frame().reset_index().to_expr()\n</code></pre>"},{"location":"reference/objective/","title":"objective","text":""},{"location":"reference/objective/#pyoframe.objective.Objective","title":"<code>Objective(expr, _constructive=False)</code>","text":"<p>               Bases: <code>Expression</code></p> <p>Examples:</p> <p>An <code>Objective</code> is automatically created when an <code>Expression</code> is assigned to <code>.minimize</code> or <code>.maximize</code></p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.A, m.B = pf.Variable(lb=0), pf.Variable(lb=0)\n&gt;&gt;&gt; m.con = m.A + m.B &lt;= 10\n&gt;&gt;&gt; m.maximize = 2 * m.B + 4\n&gt;&gt;&gt; m.maximize\n&lt;Objective size=1 dimensions={} terms=2&gt;\nobjective: 2 B +4\n</code></pre> <p>The objective value can be retrieved with from the solver once the model is solved using <code>.value</code>.</p> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n24.0\n</code></pre> <p>Objectives support <code>+=</code> and <code>-=</code> operators.</p> <pre><code>&gt;&gt;&gt; m.maximize += 3 * m.A\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.A.solution, m.B.solution\n(10.0, 0.0)\n&gt;&gt;&gt; m.maximize -= 2 * m.A\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.A.solution, m.B.solution\n(0.0, 10.0)\n</code></pre> <p>Objectives cannot be created from dimensioned expressions since an objective must be a single expression.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.dimensioned_variable = pf.Variable({\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]})\n&gt;&gt;&gt; m.maximize = m.dimensioned_variable\nTraceback (most recent call last):\n...\nValueError: Objective cannot be created from a dimensioned expression. Did you forget to use pf.sum()?\n</code></pre> <p>Objectives cannot be overwritten.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.A = pf.Variable(lb=0)\n&gt;&gt;&gt; m.maximize = 2 * m.A\n&gt;&gt;&gt; m.maximize = 3 * m.A\nTraceback (most recent call last):\n...\nValueError: An objective already exists. Use += or -= to modify it.\n</code></pre> Source code in <code>pyoframe/objective.py</code> <pre><code>def __init__(\n    self, expr: SupportsToExpr | int | float, _constructive: bool = False\n) -&gt; None:\n    self._constructive = _constructive\n    if isinstance(expr, (int, float)):\n        expr = Expression.constant(expr)\n    else:\n        expr = expr.to_expr()\n    super().__init__(expr.data)\n    self._model = expr._model\n    if self.dimensions is not None:\n        raise ValueError(\n            \"Objective cannot be created from a dimensioned expression. Did you forget to use pf.sum()?\"\n        )\n</code></pre>"},{"location":"reference/objective/#pyoframe.objective.Objective.value","title":"<code>value</code>  <code>property</code>","text":"<p>The value of the objective function (only available after solving the model).</p> <p>This value is obtained by directly querying the solver.</p>"},{"location":"reference/util/","title":"util","text":"<p>File containing utility functions and classes.</p>"},{"location":"reference/util/#pyoframe.util.Container","title":"<code>Container(setter, getter)</code>","text":"<p>A placeholder object that makes it easy to set and get attributes. Used in Model.attr and Model.params, for example.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = {}\n&gt;&gt;&gt; params = Container(setter=lambda n, v: x.__setitem__(n, v), getter=lambda n: x[n])\n&gt;&gt;&gt; params.a = 1\n&gt;&gt;&gt; params.b = 2\n&gt;&gt;&gt; params.a\n1\n&gt;&gt;&gt; params.b\n2\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def __init__(self, setter, getter):\n    self._setter = setter\n    self._getter = getter\n</code></pre>"},{"location":"reference/util/#pyoframe.util.NamedVariableMapper","title":"<code>NamedVariableMapper(cls)</code>","text":"<p>Maps variables to a string representation using the object's name and dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.foo = pf.Variable(pl.DataFrame({\"t\": range(4)}))\n&gt;&gt;&gt; pf.sum(m.foo)\n&lt;Expression size=1 dimensions={} terms=4&gt;\nfoo[0] + foo[1] + foo[2] + foo[3]\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def __init__(self, cls: Type[\"ModelElementWithId\"]) -&gt; None:\n    self._ID_COL = VAR_KEY\n    self.mapping_registry = pl.DataFrame(\n        {self._ID_COL: [], self.NAME_COL: []},\n        schema={self._ID_COL: pl.UInt32, self.NAME_COL: pl.String},\n    )\n    self._extend_registry(\n        pl.DataFrame(\n            {self._ID_COL: [CONST_TERM], self.NAME_COL: [self.CONST_TERM_NAME]},\n            schema={self._ID_COL: pl.UInt32, self.NAME_COL: pl.String},\n        )\n    )\n</code></pre>"},{"location":"reference/util/#pyoframe.util.cast_coef_to_string","title":"<code>cast_coef_to_string(df, column_name=COEF_KEY, drop_ones=True)</code>","text":"<p>Converts column <code>column_name</code> of the dataframe <code>df</code> to a string. Rounds to <code>Config.print_float_precision</code> decimal places if not None.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame.</p> required <code>column_name</code> <code>str</code> <p>The name of the column to be casted.</p> <code>COEF_KEY</code> <code>drop_ones</code> <code>bool</code> <p>If True, 1s are replaced with an empty string for non-constant terms.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1.0, -2.0, 1.0, 4.0], VAR_KEY: [1, 2, 0, 4]})\n&gt;&gt;&gt; cast_coef_to_string(df, \"x\")\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2506 __variable_id \u2502\n\u2502 --- \u2506 ---           \u2502\n\u2502 str \u2506 i64           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 +   \u2506 1             \u2502\n\u2502 -2  \u2506 2             \u2502\n\u2502 +1  \u2506 0             \u2502\n\u2502 +4  \u2506 4             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def cast_coef_to_string(\n    df: pl.DataFrame, column_name: str = COEF_KEY, drop_ones: bool = True\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Converts column `column_name` of the dataframe `df` to a string. Rounds to `Config.print_float_precision` decimal places if not None.\n\n    Parameters:\n        df:\n            The input DataFrame.\n        column_name:\n            The name of the column to be casted.\n        drop_ones:\n            If True, 1s are replaced with an empty string for non-constant terms.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1.0, -2.0, 1.0, 4.0], VAR_KEY: [1, 2, 0, 4]})\n        &gt;&gt;&gt; cast_coef_to_string(df, \"x\")\n        shape: (4, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x   \u2506 __variable_id \u2502\n        \u2502 --- \u2506 ---           \u2502\n        \u2502 str \u2506 i64           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 +   \u2506 1             \u2502\n        \u2502 -2  \u2506 2             \u2502\n        \u2502 +1  \u2506 0             \u2502\n        \u2502 +4  \u2506 4             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df = df.with_columns(\n        pl.col(column_name).abs(),\n        _sign=pl.when(pl.col(column_name) &lt; 0).then(pl.lit(\"-\")).otherwise(pl.lit(\"+\")),\n    )\n\n    if Config.float_to_str_precision is not None:\n        df = df.with_columns(pl.col(column_name).round(Config.float_to_str_precision))\n\n    df = df.with_columns(\n        pl.when(pl.col(column_name) == pl.col(column_name).floor())\n        .then(pl.col(column_name).cast(pl.Int64).cast(pl.String))\n        .otherwise(pl.col(column_name).cast(pl.String))\n        .alias(column_name)\n    )\n\n    if drop_ones:\n        condition = pl.col(column_name) == str(1)\n        if VAR_KEY in df.columns:\n            condition = condition &amp; (pl.col(VAR_KEY) != CONST_TERM)\n        df = df.with_columns(\n            pl.when(condition)\n            .then(pl.lit(\"\"))\n            .otherwise(pl.col(column_name))\n            .alias(column_name)\n        )\n    else:\n        df = df.with_columns(pl.col(column_name).cast(pl.Utf8))\n    return df.with_columns(pl.concat_str(\"_sign\", column_name).alias(column_name)).drop(\n        \"_sign\"\n    )\n</code></pre>"},{"location":"reference/util/#pyoframe.util.concat_dimensions","title":"<code>concat_dimensions(df, prefix=None, keep_dims=True, ignore_columns=RESERVED_COL_KEYS, replace_spaces=True, to_col='concated_dim')</code>","text":"<p>Returns a new DataFrame with the column 'concated_dim'. Reserved columns are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame.</p> required <code>prefix</code> <code>Optional[str]</code> <p>The prefix to be added to the concated dimension.</p> <code>None</code> <code>keep_dims</code> <code>bool</code> <p>If True, the original dimensions are kept in the new DataFrame.</p> <code>True</code> <code>replace_spaces</code> <p>bool, optional If True, replaces spaces with underscores.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"dim1\": [1, 2, 3, 1, 2, 3],\n...         \"dim2\": [\"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\"],\n...     }\n... )\n&gt;&gt;&gt; concat_dimensions(df)\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 str  \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 Y    \u2506 [1,Y]        \u2502\n\u2502 2    \u2506 Y    \u2506 [2,Y]        \u2502\n\u2502 3    \u2506 Y    \u2506 [3,Y]        \u2502\n\u2502 1    \u2506 N    \u2506 [1,N]        \u2502\n\u2502 2    \u2506 N    \u2506 [2,N]        \u2502\n\u2502 3    \u2506 N    \u2506 [3,N]        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 str  \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 Y    \u2506 x[1,Y]       \u2502\n\u2502 2    \u2506 Y    \u2506 x[2,Y]       \u2502\n\u2502 3    \u2506 Y    \u2506 x[3,Y]       \u2502\n\u2502 1    \u2506 N    \u2506 x[1,N]       \u2502\n\u2502 2    \u2506 N    \u2506 x[2,N]       \u2502\n\u2502 3    \u2506 N    \u2506 x[3,N]       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; concat_dimensions(df, keep_dims=False)\nshape: (6, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 concated_dim \u2502\n\u2502 ---          \u2502\n\u2502 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1,Y]        \u2502\n\u2502 [2,Y]        \u2502\n\u2502 [3,Y]        \u2502\n\u2502 [1,N]        \u2502\n\u2502 [2,N]        \u2502\n\u2502 [3,N]        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; # Properly handles cases with no dimensions and ignores reserved columns\n&gt;&gt;&gt; df = pl.DataFrame({VAR_KEY: [1, 2]})\n&gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 __variable_id \u2506 concated_dim \u2502\n\u2502 ---           \u2506 ---          \u2502\n\u2502 i64           \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1             \u2506 x            \u2502\n\u2502 2             \u2506 x            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def concat_dimensions(\n    df: pl.DataFrame,\n    prefix: Optional[str] = None,\n    keep_dims: bool = True,\n    ignore_columns: Sequence[str] = RESERVED_COL_KEYS,\n    replace_spaces: bool = True,\n    to_col: str = \"concated_dim\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Returns a new DataFrame with the column 'concated_dim'. Reserved columns are ignored.\n\n    Parameters:\n        df:\n            The input DataFrame.\n        prefix:\n            The prefix to be added to the concated dimension.\n        keep_dims:\n            If True, the original dimensions are kept in the new DataFrame.\n        replace_spaces : bool, optional\n            If True, replaces spaces with underscores.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; df = pl.DataFrame(\n        ...     {\n        ...         \"dim1\": [1, 2, 3, 1, 2, 3],\n        ...         \"dim2\": [\"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\"],\n        ...     }\n        ... )\n        &gt;&gt;&gt; concat_dimensions(df)\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n        \u2502 ---  \u2506 ---  \u2506 ---          \u2502\n        \u2502 i64  \u2506 str  \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 Y    \u2506 [1,Y]        \u2502\n        \u2502 2    \u2506 Y    \u2506 [2,Y]        \u2502\n        \u2502 3    \u2506 Y    \u2506 [3,Y]        \u2502\n        \u2502 1    \u2506 N    \u2506 [1,N]        \u2502\n        \u2502 2    \u2506 N    \u2506 [2,N]        \u2502\n        \u2502 3    \u2506 N    \u2506 [3,N]        \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n        \u2502 ---  \u2506 ---  \u2506 ---          \u2502\n        \u2502 i64  \u2506 str  \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 Y    \u2506 x[1,Y]       \u2502\n        \u2502 2    \u2506 Y    \u2506 x[2,Y]       \u2502\n        \u2502 3    \u2506 Y    \u2506 x[3,Y]       \u2502\n        \u2502 1    \u2506 N    \u2506 x[1,N]       \u2502\n        \u2502 2    \u2506 N    \u2506 x[2,N]       \u2502\n        \u2502 3    \u2506 N    \u2506 x[3,N]       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; concat_dimensions(df, keep_dims=False)\n        shape: (6, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 concated_dim \u2502\n        \u2502 ---          \u2502\n        \u2502 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 [1,Y]        \u2502\n        \u2502 [2,Y]        \u2502\n        \u2502 [3,Y]        \u2502\n        \u2502 [1,N]        \u2502\n        \u2502 [2,N]        \u2502\n        \u2502 [3,N]        \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; # Properly handles cases with no dimensions and ignores reserved columns\n        &gt;&gt;&gt; df = pl.DataFrame({VAR_KEY: [1, 2]})\n        &gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 __variable_id \u2506 concated_dim \u2502\n        \u2502 ---           \u2506 ---          \u2502\n        \u2502 i64           \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1             \u2506 x            \u2502\n        \u2502 2             \u2506 x            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if prefix is None:\n        prefix = \"\"\n    dimensions = [col for col in df.columns if col not in ignore_columns]\n    if dimensions:\n        query = pl.concat_str(\n            pl.lit(prefix + \"[\"),\n            pl.concat_str(*dimensions, separator=\",\"),\n            pl.lit(\"]\"),\n        )\n    else:\n        query = pl.lit(prefix)\n\n    df = df.with_columns(query.alias(to_col))\n\n    if replace_spaces:\n        df = df.with_columns(pl.col(to_col).str.replace_all(\" \", \"_\"))\n\n    if not keep_dims:\n        df = df.drop(*dimensions)\n\n    return df\n</code></pre>"},{"location":"reference/util/#pyoframe.util.dataframe_to_tupled_list","title":"<code>dataframe_to_tupled_list(df, num_max_elements=None)</code>","text":"<p>Converts a dataframe into a list of tuples. Used to print a Set to the console. See examples for behaviour.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; dataframe_to_tupled_list(df)\n'[1, 2, 3, 4, 5]'\n&gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n'[1, 2, 3, ...]'\n</code></pre> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5], \"y\": [2, 3, 4, 5, 6]})\n&gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n'[(1, 2), (2, 3), (3, 4), ...]'\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def dataframe_to_tupled_list(\n    df: pl.DataFrame, num_max_elements: Optional[int] = None\n) -&gt; str:\n    \"\"\"\n    Converts a dataframe into a list of tuples. Used to print a Set to the console. See examples for behaviour.\n\n    Examples:\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\n        &gt;&gt;&gt; dataframe_to_tupled_list(df)\n        '[1, 2, 3, 4, 5]'\n        &gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n        '[1, 2, 3, ...]'\n\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5], \"y\": [2, 3, 4, 5, 6]})\n        &gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n        '[(1, 2), (2, 3), (3, 4), ...]'\n    \"\"\"\n    elipse = False\n    if num_max_elements is not None:\n        if len(df) &gt; num_max_elements:\n            elipse = True\n            df = df.head(num_max_elements)\n\n    res = (row for row in df.iter_rows())\n    if len(df.columns) == 1:\n        res = (row[0] for row in res)\n\n    res = str(list(res))\n    if elipse:\n        res = res[:-1] + \", ...]\"\n    return res\n</code></pre>"},{"location":"reference/util/#pyoframe.util.for_solvers","title":"<code>for_solvers(*solvers)</code>","text":"<p>Decorator that limits the function to only be called when the solver is in the <code>only</code> list.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def for_solvers(*solvers: str):\n    \"\"\"\n    Decorator that limits the function to only be called when the solver is in the `only` list.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self.solver_name not in solvers:\n                raise NotImplementedError(\n                    f\"Method '{func.__name__}' is not implemented for solver '{self.solver_name}'.\"\n                )\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/util/#pyoframe.util.get_obj_repr","title":"<code>get_obj_repr(obj, _props=(), **kwargs)</code>","text":"<p>Helper function to generate repr strings for classes. See usage for examples.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def get_obj_repr(obj: object, _props: Iterable[str] = (), **kwargs):\n    \"\"\"\n    Helper function to generate __repr__ strings for classes. See usage for examples.\n    \"\"\"\n    props = {prop: getattr(obj, prop) for prop in _props}\n    props_str = \" \".join(f\"{k}={v}\" for k, v in props.items() if v is not None)\n    if props_str:\n        props_str += \" \"\n    kwargs_str = \" \".join(f\"{k}={v}\" for k, v in kwargs.items() if v is not None)\n    return f\"&lt;{obj.__class__.__name__} {props_str}{kwargs_str}&gt;\"\n</code></pre>"},{"location":"reference/util/#pyoframe.util.parse_inputs_as_iterable","title":"<code>parse_inputs_as_iterable(*inputs)</code>","text":"<p>Converts a parameter *x: Any | Iteraable[Any] to a single Iterable[Any] object. This is helpful to support these two ways of passing arguments:     - foo([1, 2, 3])     - foo(1, 2, 3)</p> <p>Inspired from the polars library.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def parse_inputs_as_iterable(\n    *inputs: Union[Any, Iterable[Any]],\n) -&gt; Iterable[Any]:\n    \"\"\"\n    Converts a parameter *x: Any | Iteraable[Any] to a single Iterable[Any] object.\n    This is helpful to support these two ways of passing arguments:\n        - foo([1, 2, 3])\n        - foo(1, 2, 3)\n\n    Inspired from the polars library.\n    \"\"\"\n    if not inputs:\n        return []\n\n    # Treat elements of a single iterable as separate inputs\n    if len(inputs) == 1 and _is_iterable(inputs[0]):\n        return inputs[0]\n\n    return inputs\n</code></pre>"},{"location":"reference/util/#pyoframe.util.unwrap_single_values","title":"<code>unwrap_single_values(func)</code>","text":"<p>Decorator for functions that return DataFrames. Returned dataframes with a single value will instead return the value.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def unwrap_single_values(func):\n    \"\"\"Decorator for functions that return DataFrames. Returned dataframes with a single value will instead return the value.\"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        if isinstance(result, pl.DataFrame) and result.shape == (1, 1):\n            return result.item()\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"why-pyoframe/","title":"Why Pyoframe?","text":"<p>Pyoframe is better than alternatives libraries due to speed,  memory and readability. See for yourself:</p> <p></p>"},{"location":"why-pyoframe/#why-not-pyoframe","title":"Why not Pyoframe?","text":"<p>Our library still has some limitations:</p> <ul> <li>No support for quadratic objectives (for now, help us out!)</li> <li>Only supports Gurobi (for now, help us out!)</li> </ul>"},{"location":"why-pyoframe/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Why Pyoframe?</li> <li>Speed benchmarks</li> <li>Memory benchmarks</li> <li>Pyoframe syntax's</li> <li>Why not Pyoframe?</li> </ul>"},{"location":"why-pyoframe/why-pyoframe/","title":"Why PyoFrame?","text":""}]}