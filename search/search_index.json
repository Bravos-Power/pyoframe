{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyoframe: Formulate huge optimization models","text":"<p>Tired of slow or archaic modelling frameworks like Pyomo and GAMS?  Here are some reasons we think you'd like Pyoframe:</p> <ul> <li>Python library for building LP and MILP models</li> <li>Open-source MIT License</li> <li>Works with Pandas dataframes</li> <li>Powered by Rust and Polars</li> </ul> <ul> <li> <p> Learn</p> <p>Install <code>pyoframe</code> and learn the library's basics.</p> <p> Get started</p> </li> </ul> <ul> <li> <p> API Reference</p> <p>Your go-to reference for understanding our API.</p> <p> Reference</p> </li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Learn</li> <li>Reference</li> <li>Contribute</li> </ul>"},{"location":"contribute/","title":"Contribute","text":"<p>Contributions are more than welcome! Submit a pull request, or open an issue and I (Martin) will gladly answer your questions on how to contribute.</p>"},{"location":"contribute/#setup-a-development-environment","title":"Setup a development environment","text":"<ol> <li> <p>Clone this repository. <code>git clone https://github.com/Bravos-Power/pyoframe</code></p> </li> <li> <p>Install the dependencies. <code>pip install --editable .[dev,docs]</code></p> </li> <li> <p>Run <code>pytest</code> to make sure everything is working. If not, open an issue!</p> </li> </ol>"},{"location":"contribute/#documentation","title":"Documentation","text":"<p>We use Material Docs for documentation with several plugins to enable features like automatically compiling the docstrings into the reference API. Please follow the Google style for docstrings.</p>"},{"location":"contribute/#helpful-commands","title":"Helpful commands","text":"<ul> <li><code>pytest</code>: Runs all the tests. Tests are found under <code>/tests</code> and also as doc tests. Include the flag <code>--cov</code> to get test coverage information.</li> <li><code>mkdocs serve</code>: Generates the documentation locally. Navigate to <code>http://127.0.0.1:8000/pyoframe/</code> to check it out.</li> </ul>"},{"location":"learn/","title":"Overview","text":"<ul> <li> <p> Get Started</p> <p>Install <code>pyoframe</code> and learn the library's basics.</p> <p> Getting started</p> </li> <li> <p> Tutorials</p> <p>Step-by-step tutorials to make sense of important features</p> <p> Tutorials</p> </li> <li> <p> Concepts</p> <p>Understand the how and why of Pyoframe. </p> <p> Concepts</p> </li> <li> <p> Reference</p> <p>Your go-to reference for understanding our API.</p> <p> API Reference</p> </li> <li> <p> Examples</p> <p>Show don't tell!</p> <p> Examples</p> </li> </ul>"},{"location":"learn/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Getting Started</li> <li>Advanced Concepts</li> <li>Examples</li> </ul>"},{"location":"learn/01_getting-started/01_installation/","title":"Installation","text":""},{"location":"learn/01_getting-started/01_installation/#install-pyoframe","title":"Install Pyoframe","text":"<pre><code>pip install pyoframe\n</code></pre>"},{"location":"learn/01_getting-started/01_installation/#install-your-solver","title":"Install your solver","text":"<p>Only Gurobi is supported</p> <p>We are working on supporting more solvers including HiGHS. Learn how you can contribute.</p> <p>Obtain a license from Gurobi and install it on your device. If you encounter issues, let us know!</p>"},{"location":"learn/01_getting-started/02_build-simple-model/","title":"A simple model","text":"<p>Here's a simple problem to show you Pyoframe's syntax. Click on the  buttons to learn what's happening!</p> <p>A block of tofu costs $4 and contains 10 g of protein. A can of chickpeas costs $2 and contains 8 g of protein. How should you spend your $10 budget to get the most protein?</p> <p>Run the code below to find the answer!</p> <pre><code>import pyoframe as pf\n\nm = pf.Model(\"max\") # (1)!\n\nm.tofu = pf.Variable(lb=0)  # (2)!\nm.chickpeas = pf.Variable(lb=0)\n\nm.objective = 10 * m.tofu + 8 * m.chickpeas # (3)!\nm.budget_constraint = 4 * m.tofu + 2 * m.chickpeas &lt;= 10 # (4)!\n\nm.solve()\n\nprint(f\"{m.tofu.solution} blocks of tofu\")\nprint(f\"{m.chickpeas.solution} cans of chickpeas\")\n</code></pre> <ol> <li>Creating your model is always the starting point!</li> <li><code>lb=0</code> sets the variable's lower bound to ensure you can't buy a negative quantity of tofu!</li> <li>Variables can be added and multiplied as you'd expect!</li> <li>Constraints are easily created with <code>&lt;=</code>, <code>&gt;=</code> or <code>==</code>.</li> </ol>"},{"location":"learn/01_getting-started/03_using_dataframes/","title":"Using Dataframes","text":"<p>Pyoframe's most powerful feature is its ability to work directly with your Dataframes! We support both Pandas and Polars dataframes although if you're looking for performance, Polars is a lot faster.</p> <p>Here we'll walk you through the classical diet problem using Pyoframe.</p>"},{"location":"learn/01_getting-started/03_using_dataframes/#1-import-your-data","title":"1. Import your data","text":"<p>Let's generalize our previous simple model to a dataset! Say you having the following three files.</p> <code>foods.csv</code><code>nutrients.csv</code><code>foods_to_nutrients.csv</code> food cost stock hamburger 2.49 40 salad 2.49 60 milk 0.89 6.8 category min max calories 1800 2200 protein 91 300 food category amount hamburger calories 410 hamburger protein 24 salad calories 320 salad protein 31 milk calories 100 milk protein 8 <p>You'd like to find how to meet your daily nutritional needs (see <code>nutrients.csv</code>) by spending as little as possible on a mix of options (see <code>foods.csv</code>). Let's first import our data!</p> Using PandasUsing Polars <pre><code>import pyoframe as pf\nimport pandas as pd\n\nfoods = pd.read_csv(\"foods.csv\")\nnutrients = pd.read_csv(\"nutrients.csv\")\nfoods_to_nutrients = pd.read_csv(\"foods_to_nutrients.csv\")\n</code></pre> <pre><code>import pyoframe as pf\nimport polars as pl\n\nfoods = pl.read_csv(\"foods.csv\")\nnutrients = pl.read_csv(\"nutrients.csv\")\nfoods_to_nutrients = pl.read_csv(\"foods_to_nutrients.csv\")\n</code></pre>"},{"location":"learn/01_getting-started/03_using_dataframes/#2-build-your-model","title":"2. Build your model","text":"<p>Ok, the code below has some new concepts but don't worry just yet. It will all make sense!</p> <pre><code>m = pf.Model(\"min\")\n\n# Define our variable: how much to buy of each food\nm.purchase_quantity = pf.Variable(\n    foods[[\"food\"]], # (1)!\n    lb=0, \n    ub=foods[[\"food\", \"stock\"]] # (2)!\n)\n\nm.nutrients = pf.sum( # (3)!\n    over=\"food\", \n    expr=m.purchase_quantity * foods_to_nutrients # (4)!\n) \n\nm.min_nutrients = m.nutrients &gt;= nutrients[[\"category\", \"min\"]]\nm.max_nutrients = m.nutrients &lt;= nutrients[[\"category\", \"max\"]]\n\nm.objective = pf.sum(m.purchase_quantity * foods[[\"food\", \"cost\"]]) # (5)!\n</code></pre> <ol> <li>This variable is actually 3 variables, one for each element in <code>foods[[\"food\"]]</code>!</li> <li>Dataframes can be used to set variable bounds. The last column is always used as the bound.</li> <li><code>pf.sum</code> sums the terms of <code>expr=</code> over the <code>food</code> dimension, returning a linear expression indexed only over <code>category</code></li> <li>Multiplication acts like matrix multiplication. Our <code>purchase_quantity</code> (indexed by <code>\"food\"</code>) is multiplied by a parameter that is indexed by <code>\"food\"</code> and <code>\"category\"</code>.</li> <li>Build a linear expression of that sums the cost of buying each food.</li> </ol>"},{"location":"learn/01_getting-started/03_using_dataframes/#3-solve-the-model","title":"3. Solve the model","text":"<p>This ones easy:</p> <pre><code>m.solve()\n</code></pre> <p>How does this work?</p> <p>Under the hood, Pyoframe is writing your model to an <code>.lp</code> file, asking Gurobi to read and solve it, and then loading Gurobi's results back into the <code>pf.Model()</code> object.</p>"},{"location":"learn/01_getting-started/03_using_dataframes/#4-read-the-results","title":"4. Read the results","text":"<p><pre><code>m.purchase_quantity.solution.write_csv(\"results.csv\")\n</code></pre> This will create the following <code>results.csv</code> file:</p> food solution hamburger 4.39024 salad 0 milk 0 <p>Turns out hamburgers are just the best bang for your buck </p>"},{"location":"learn/01_getting-started/04_building_blocks/","title":"Model Building Blocks","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>In any linear program there are three key building blocks Variables, Constraints, and an Objective. We walk you through these as well as two more: Expressions and Sets</p>"},{"location":"learn/01_getting-started/04_building_blocks/#variable","title":"<code>Variable</code>","text":""},{"location":"learn/01_getting-started/04_building_blocks/#constraint","title":"<code>Constraint</code>","text":""},{"location":"learn/01_getting-started/04_building_blocks/#objective","title":"<code>Objective</code>","text":""},{"location":"learn/01_getting-started/04_building_blocks/#expression","title":"<code>Expression</code>","text":""},{"location":"learn/01_getting-started/04_building_blocks/#set","title":"<code>Set</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/","title":"Special functions","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>Pyoframe has a few special functions that make working with dataframes easy and intuitive. Here they are:</p>"},{"location":"learn/01_getting-started/05_special_functions/#pfsumexpression","title":"<code>pf.sum(Expression)</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/#expressionmap","title":"<code>Expression.map()</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/#expressionadd_dim","title":"<code>Expression.add_dim()</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/#expressiondrop_unmatched","title":"<code>Expression.drop_unmatched()</code>","text":""},{"location":"learn/01_getting-started/05_special_functions/#expressionkeep_unmatched","title":"<code>Expression.keep_unmatched()</code>","text":""},{"location":"learn/01_getting-started/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Installation</li> <li>A simple model</li> <li>Using dataframes</li> <li>Model building blocks</li> <li>Special Functions</li> </ul>"},{"location":"learn/02_tutorials/","title":"Tutorials","text":"<p>Work in progress</p> <p>We haven't created tutorials yet! Learn how you can contribute.</p>"},{"location":"learn/03_concepts/01_pyoframe-datastructure/","title":"The Pyoframe datastructure","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>So how does Pyoframe really work? Pyoframe uses dataframe operations to build your model's linear expressions. Here's what's happening under the hood.</p>"},{"location":"learn/03_concepts/02_performance_tips/","title":"Performance","text":"<p>Pyoframe is already one of the fastest and lowest-memory-footprint libraries to build optimization models since we leverage <code>Polars</code> internally. Here are some additional tips to squeeze out every bit of performance:</p> <ol> <li> <p>Use polars not pandas. Internally, pyoframe uses polars for everything. If you're using Pandas we'll just convert your dataframes to Polars. So might as well use polars from the very beginning! You'll save time during your pre-processing and data loading.</p> </li> <li> <p>Use integers not strings for indexing. Pyoframe works fine with dataframes that contain string columns but you should know that strings take up a lot more space than just numbering your values. When possible, use integer indices.</p> </li> <li> <p>Tweak the <code>pf.Config</code> settings. Take a look at our API Reference and you might find some settings to adjust to squeeze out the last bit of performance.</p> </li> </ol>"},{"location":"learn/03_concepts/02_performance_tips/#expression-or-variable","title":"<code>Expression</code> or <code>Variable</code> ?","text":"<p>One common question when building large models is, if you have a very long linear expression, should you assign it to a variable or simply use the expression directly? In some cases, it is best to assign it to a variable since Pyoframe will then only need to pass around the variable rather than all the terms in the linear expression. If you're concerned that you'll be adding more variables to your model, know that most solvers will rapidly and easily get rid of these variables during the presolve stage without any noticeable performance cost.</p>"},{"location":"learn/03_concepts/03_troubleshooting/","title":"Troubleshooting","text":"<p>Here are some potential errors and how to resolve them.</p>"},{"location":"learn/03_concepts/03_troubleshooting/#datatypes-of-join-keys-dont-match","title":"<code>datatypes of join keys don't match</code>","text":"<p>Often, this error indicates that two columns in your input dataframes, although representing the same dimension, have different datatypes (e.g. 16bit integer and 64bit integer). This is not allowed and you should ensure that for the same dimensions, datatypes are identical.</p>"},{"location":"learn/03_concepts/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Pyoframe datastructure</li> <li>Performance</li> <li>Troubleshooting</li> </ul>"},{"location":"learn/04_examples/","title":"Examples","text":"<p>Beyond examples in this documentation, the following examples are available:</p> <ul> <li>Power grid example in Jupyter Notebooks (thanks Kjartan !)</li> <li>Diet problem example similar to the one present in Getting Started.</li> <li>A cutting stock problem example</li> <li>A facility location problem example</li> </ul>"},{"location":"reference/","title":"Index","text":"<p>Pyoframe's public API. Also applies the monkey patch to the DataFrame libraries.</p>"},{"location":"reference/#pyoframe.Config","title":"<code>Config</code>","text":""},{"location":"reference/#pyoframe.Config.reset_defaults","title":"<code>reset_defaults()</code>  <code>classmethod</code>","text":"<p>Resets all configuration options to their default values.</p> Source code in <code>pyoframe/constants.py</code> <pre><code>@classmethod\ndef reset_defaults(cls):\n    \"\"\"\n    Resets all configuration options to their default values.\n    \"\"\"\n    for key, value in cls._defaults.items():\n        setattr(cls, key, value)\n</code></pre>"},{"location":"reference/#pyoframe.Constraint","title":"<code>Constraint(lhs, sense)</code>","text":"<p>               Bases: <code>ModelElementWithId</code></p> <p>A linear programming constraint.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expression</code> <p>The left hand side of the constraint.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, lhs: Expression, sense: ConstraintSense):\n    \"\"\"Initialize a constraint.\n\n    Parameters:\n        lhs:\n            The left hand side of the constraint.\n        sense:\n            The sense of the constraint.\n    \"\"\"\n    self.lhs = lhs\n    self._model = lhs._model\n    self.sense = sense\n    self.to_relax: Optional[FuncArgs] = None\n\n    dims = self.lhs.dimensions\n    data = pl.DataFrame() if dims is None else self.lhs.data.select(dims).unique()\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/#pyoframe.Constraint.slack","title":"<code>slack</code>  <code>property</code> <code>writable</code>","text":"<p>The slack of the constraint. Will raise an error if the model has not already been solved. The first call to this property will load the slack values from the solver (lazy loading).</p>"},{"location":"reference/#pyoframe.Constraint.relax","title":"<code>relax(cost, max=None)</code>","text":"<p>Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>SupportsToExpr</code> <p>The cost of relaxing the constraint. Costs should be positives as they will automatically become negative for maximization problems.</p> required <code>max</code> <code>Optional[SupportsToExpr]</code> <p>The maximum value of the relaxation variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>The same constraint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyoframe as pf\n&gt;&gt;&gt; m = pf.Model(\"max\")\n&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n&gt;&gt;&gt; m.must_finish_project = m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n&gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n&gt;&gt;&gt; _ = m.must_finish_project.relax(homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]], max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]])\n&gt;&gt;&gt; _ = m.solve(log_to_console=False)\n\nWriting ...\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 8.0      \u2502\n\u2502 B       \u2506 7.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; # It can also be done all in one go!\n&gt;&gt;&gt; m = pf.Model(\"max\")\n&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n&gt;&gt;&gt; m.must_finish_project = (m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]).relax(5)\n&gt;&gt;&gt; m.only_one_day = (sum(\"project\", m.hours_spent) &lt;= 24).relax(1)\n&gt;&gt;&gt; _ = m.solve(log_to_console=False)\n\nWriting ...\n&gt;&gt;&gt; m.objective.value\n-3.0\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 9.0      \u2502\n\u2502 B       \u2506 9.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def relax(\n    self, cost: SupportsToExpr, max: Optional[SupportsToExpr] = None\n) -&gt; Constraint:\n    \"\"\"\n    Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.\n\n    Parameters:\n        cost:\n            The cost of relaxing the constraint. Costs should be positives as they will automatically\n            become negative for maximization problems.\n        max:\n            The maximum value of the relaxation variable.\n\n    Returns:\n        The same constraint\n\n    Examples:\n        &gt;&gt;&gt; import pyoframe as pf\n        &gt;&gt;&gt; m = pf.Model(\"max\")\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n        &gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n        &gt;&gt;&gt; _ = m.must_finish_project.relax(homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]], max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]])\n        &gt;&gt;&gt; _ = m.solve(log_to_console=False) # doctest: +ELLIPSIS\n        \\rWriting ...\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 8.0      \u2502\n        \u2502 B       \u2506 7.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n        &gt;&gt;&gt; # It can also be done all in one go!\n        &gt;&gt;&gt; m = pf.Model(\"max\")\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = (m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]).relax(5)\n        &gt;&gt;&gt; m.only_one_day = (sum(\"project\", m.hours_spent) &lt;= 24).relax(1)\n        &gt;&gt;&gt; _ = m.solve(log_to_console=False) # doctest: +ELLIPSIS\n        \\rWriting ...\n        &gt;&gt;&gt; m.objective.value\n        -3.0\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 9.0      \u2502\n        \u2502 B       \u2506 9.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    m = self._model\n    if m is None or self.name is None:\n        self.to_relax = FuncArgs(args=[cost, max])\n        return self\n\n    var_name = f\"{self.name}_relaxation\"\n    assert not hasattr(\n        m, var_name\n    ), \"Conflicting names, relaxation variable already exists on the model.\"\n    var = Variable(self, lb=0, ub=max)\n\n    if self.sense == ConstraintSense.LE:\n        self.lhs -= var\n    elif self.sense == ConstraintSense.GE:\n        self.lhs += var\n    else:  # pragma: no cover\n        # TODO\n        raise NotImplementedError(\n            \"Relaxation for equalities has not yet been implemented. Submit a pull request!\"\n        )\n\n    setattr(m, var_name, var)\n    penalty = var * cost\n    if self.dimensions:\n        penalty = sum(self.dimensions, penalty)\n    if m.sense == ObjSense.MAX:\n        penalty *= -1\n    if m.objective is None:\n        m.objective = penalty\n    else:\n        m.objective += penalty\n\n    return self\n</code></pre>"},{"location":"reference/#pyoframe.Expression","title":"<code>Expression(data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A linear expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable, Model\n&gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m = Model(\"min\")\n&gt;&gt;&gt; m.Time = Variable(df.index)\n&gt;&gt;&gt; m.Size = Variable(df.index)\n&gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n&gt;&gt;&gt; expr\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n[1,mon]: Time[1,mon] + Size[1,mon]\n[1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n[1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n[2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n[2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, data: pl.DataFrame):\n    \"\"\"\n    A linear expression.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyoframe import Variable, Model\n        &gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; m = Model(\"min\")\n        &gt;&gt;&gt; m.Time = Variable(df.index)\n        &gt;&gt;&gt; m.Size = Variable(df.index)\n        &gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n        &gt;&gt;&gt; expr\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n        [1,mon]: Time[1,mon] + Size[1,mon]\n        [1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n        [1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n        [2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n        [2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n    \"\"\"\n    # Sanity checks, VAR_KEY and COEF_KEY must be present\n    assert VAR_KEY in data.columns, \"Missing variable column.\"\n    assert COEF_KEY in data.columns, \"Missing coefficient column.\"\n\n    # Sanity check no duplicates indices\n    if Config.enable_is_duplicated_expression_safety_check:\n        duplicated_mask = data.drop(COEF_KEY).is_duplicated()\n        # In theory this should never happen unless there's a bug in the library\n        if duplicated_mask.any():  # pragma: no cover\n            duplicated_data = data.filter(duplicated_mask)\n            raise ValueError(\n                f\"Cannot create an expression with duplicate indices:\\n{duplicated_data}.\"\n            )\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/#pyoframe.Expression.value","title":"<code>value: pl.DataFrame</code>  <code>property</code>","text":"<p>The value of the expression. Only available after the model has been solved.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyoframe as pf\n&gt;&gt;&gt; m = pf.Model(\"max\")\n&gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, ub=10)\n&gt;&gt;&gt; m.expr_1 = 2 * m.X + 1\n&gt;&gt;&gt; m.expr_2 = pf.sum(m.expr_1)\n&gt;&gt;&gt; m.objective = m.expr_2 - 3\n&gt;&gt;&gt; result = m.solve(log_to_console=False)\n\n...\n&gt;&gt;&gt; m.expr_1.value\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 21.0     \u2502\n\u2502 2    \u2506 21.0     \u2502\n\u2502 3    \u2506 21.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.expr_2.value\n63.0\n</code></pre>"},{"location":"reference/#pyoframe.Expression.__add__","title":"<code>__add__(other)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1,2,3], \"add\": [10, 20, 30]}).to_expr()\n&gt;&gt;&gt; var = Variable(add)\n&gt;&gt;&gt; var + add\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: x1 +10\n[2]: x2 +20\n[3]: x3 +30\n&gt;&gt;&gt; var + add + 2\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: x1 +12\n[2]: x2 +22\n[3]: x3 +32\n&gt;&gt;&gt; var + pd.DataFrame({\"dim1\": [1,2], \"add\": [10, 20]})\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim1_right \u2502\n\u2502 ---  \u2506 ---        \u2502\n\u2502 i64  \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3    \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; 5 + 2 * Variable()\n&lt;Expression size=1 dimensions={} terms=2&gt;\n2 x4 +5\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyoframe import Variable\n        &gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1,2,3], \"add\": [10, 20, 30]}).to_expr()\n        &gt;&gt;&gt; var = Variable(add)\n        &gt;&gt;&gt; var + add\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: x1 +10\n        [2]: x2 +20\n        [3]: x3 +30\n        &gt;&gt;&gt; var + add + 2\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: x1 +12\n        [2]: x2 +22\n        [3]: x3 +32\n        &gt;&gt;&gt; var + pd.DataFrame({\"dim1\": [1,2], \"add\": [10, 20]})\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (1, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim1_right \u2502\n        \u2502 ---  \u2506 ---        \u2502\n        \u2502 i64  \u2506 i64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 3    \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; 5 + 2 * Variable()\n        &lt;Expression size=1 dimensions={} terms=2&gt;\n        2 x4 +5\n    \"\"\"\n    if isinstance(other, str):\n        raise ValueError(\n            \"Cannot add a string to an expression. Perhaps you meant to use pf.sum() instead of sum()?\"\n        )\n    if isinstance(other, (int, float)):\n        return self._add_const(other)\n    other = other.to_expr()\n    self._learn_from_other(other)\n    return _add_expressions(self, other)\n</code></pre>"},{"location":"reference/#pyoframe.Expression.map","title":"<code>map(mapping_set, drop_shared_dims=True)</code>","text":"<p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <p>This is particularly useful to go from one type of dimensions to another. For example, to convert data that is indexed by city to data indexed by country (see example).</p> <p>Parameters:</p> Name Type Description Default <code>mapping_set</code> <code>SetTypes</code> <p>The set to map the expression to. This can be a DataFrame, Index, or another Set.</p> required <code>drop_shared_dims</code> <code>bool</code> <p>If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and     repeated rows are summed. If False, the shared dimensions are kept in the resulting expression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression containing the result of the mapping operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pyoframe import Variable, Model\n&gt;&gt;&gt; pop_data = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"year\": [2024, 2024, 2024], \"population\": [10, 2, 8]}).to_expr()\n&gt;&gt;&gt; cities_and_countries = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"country\": [\"Canada\", \"Canada\", \"USA\"]})\n&gt;&gt;&gt; pop_data.map(cities_and_countries)\n&lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n[2024,Canada]: 12\n[2024,USA]: 8\n&gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n&lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n[Toronto,2024,Canada]: 10\n[Vancouver,2024,Canada]: 2\n[Boston,2024,USA]: 8\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def map(self, mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression:\n    \"\"\"\n    Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.\n\n    This is particularly useful to go from one type of dimensions to another. For example, to convert data that\n    is indexed by city to data indexed by country (see example).\n\n    Parameters:\n        mapping_set:\n            The set to map the expression to. This can be a DataFrame, Index, or another Set.\n        drop_shared_dims:\n            If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and\n                repeated rows are summed.\n            If False, the shared dimensions are kept in the resulting expression.\n\n    Returns:\n        A new Expression containing the result of the mapping operation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from pyoframe import Variable, Model\n        &gt;&gt;&gt; pop_data = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"year\": [2024, 2024, 2024], \"population\": [10, 2, 8]}).to_expr()\n        &gt;&gt;&gt; cities_and_countries = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"country\": [\"Canada\", \"Canada\", \"USA\"]})\n        &gt;&gt;&gt; pop_data.map(cities_and_countries)\n        &lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n        [2024,Canada]: 12\n        [2024,USA]: 8\n        &gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n        &lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n        [Toronto,2024,Canada]: 10\n        [Vancouver,2024,Canada]: 2\n        [Boston,2024,USA]: 8\n    \"\"\"\n    mapping_set = Set(mapping_set)\n\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot use .map() on an expression with no dimensions.\")\n\n    mapping_dims = mapping_set.dimensions\n    if mapping_dims is None:\n        raise ValueError(\n            \"Cannot use .map() with a mapping set containing no dimensions.\"\n        )\n\n    shared_dims = [dim for dim in dims if dim in mapping_dims]\n    if not shared_dims:\n        raise ValueError(\n            f\"Cannot apply .map() as there are no shared dimensions between the expression (dims={self.dimensions}) and the mapping set (dims={mapping_set.dimensions}).\"\n        )\n\n    mapped_expression = self * mapping_set\n\n    if drop_shared_dims:\n        return sum(shared_dims, mapped_expression)\n\n    return mapped_expression\n</code></pre>"},{"location":"reference/#pyoframe.Expression.rolling_sum","title":"<code>rolling_sum(over, window_size)</code>","text":"<p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <p>This method applies a rolling sum operation over the dimension specified by <code>over</code>, using a window defined by <code>window_size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>over</code> <p>The name of the dimension (column) over which the rolling sum is calculated. This dimension must exist within the Expression's dimensions.</p> required <code>window_size</code> <p>The size of the moving window in terms of number of records. The rolling sum is calculated over this many consecutive elements.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression instance containing the result of the rolling sum operation. This new Expression retains all dimensions (columns) of the original data, with the rolling sum applied over the specified dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pyoframe import Variable, Model\n&gt;&gt;&gt; cost = pl.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [1, 2, 3, 1, 2], \"cost\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; m = Model(\"min\")\n&gt;&gt;&gt; m.quantity = Variable(cost[[\"item\", \"time\"]])\n&gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n[1,1]: quantity[1,1]\n[1,2]: quantity[1,1] +2 quantity[1,2]\n[1,3]: 2 quantity[1,2] +3 quantity[1,3]\n[2,1]: 4 quantity[2,1]\n[2,2]: 4 quantity[2,1] +5 quantity[2,2]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def rolling_sum(self, over: str, window_size: int) -&gt; Expression:\n    \"\"\"\n    Calculates the rolling sum of the Expression over a specified window size for a given dimension.\n\n    This method applies a rolling sum operation over the dimension specified by `over`,\n    using a window defined by `window_size`.\n\n\n    Parameters:\n        over :\n            The name of the dimension (column) over which the rolling sum is calculated.\n            This dimension must exist within the Expression's dimensions.\n        window_size :\n            The size of the moving window in terms of number of records.\n            The rolling sum is calculated over this many consecutive elements.\n\n    Returns:\n        A new Expression instance containing the result of the rolling sum operation.\n            This new Expression retains all dimensions (columns) of the original data,\n            with the rolling sum applied over the specified dimension.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from pyoframe import Variable, Model\n        &gt;&gt;&gt; cost = pl.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [1, 2, 3, 1, 2], \"cost\": [1, 2, 3, 4, 5]})\n        &gt;&gt;&gt; m = Model(\"min\")\n        &gt;&gt;&gt; m.quantity = Variable(cost[[\"item\", \"time\"]])\n        &gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n        [1,1]: quantity[1,1]\n        [1,2]: quantity[1,1] +2 quantity[1,2]\n        [1,3]: 2 quantity[1,2] +3 quantity[1,3]\n        [2,1]: 4 quantity[2,1]\n        [2,2]: 4 quantity[2,1] +5 quantity[2,2]\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\n            \"Cannot use rolling_sum() with an expression with no dimensions.\"\n        )\n    assert over in dims, f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        pl.concat(\n            [\n                df.with_columns(pl.col(over).max())\n                for _, df in self.data.rolling(\n                    index_column=over,\n                    period=f\"{window_size}i\",\n                    group_by=remaining_dims,\n                )\n            ]\n        )\n    )\n</code></pre>"},{"location":"reference/#pyoframe.Expression.sum","title":"<code>sum(over)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n&gt;&gt;&gt; expr = (quantity * df[\"cost\"]).sum(\"time\")\n&gt;&gt;&gt; expr.data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0     \u2506 1             \u2502\n\u2502 2    \u2506 9.0     \u2506 2             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def sum(self, over: Union[str, Iterable[str]]):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyoframe import Variable\n        &gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n        &gt;&gt;&gt; expr = (quantity * df[\"cost\"]).sum(\"time\")\n        &gt;&gt;&gt; expr.data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 6.0     \u2506 1             \u2502\n        \u2502 2    \u2506 9.0     \u2506 2             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if isinstance(over, str):\n        over = [over]\n    dims = self.dimensions\n    if not dims:\n        raise ValueError(\n            f\"Cannot sum over dimensions {over} since the current expression has no dimensions.\"\n        )\n    assert set(over) &lt;= set(dims), f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        self.data.drop(over)\n        .group_by(remaining_dims + [VAR_KEY], maintain_order=True)\n        .sum()\n    )\n</code></pre>"},{"location":"reference/#pyoframe.Expression.within","title":"<code>within(set)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; general_expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n&gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n&gt;&gt;&gt; general_expr.within(filter_expr).data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0     \u2506 0             \u2502\n\u2502 3    \u2506 3.0     \u2506 0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def within(self, set: \"SetTypes\") -&gt; Expression:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; general_expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n        &gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n        &gt;&gt;&gt; general_expr.within(filter_expr).data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0     \u2506 0             \u2502\n        \u2502 3    \u2506 3.0     \u2506 0             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df: pl.DataFrame = Set(set).data\n    set_dims = _get_dimensions(df)\n    assert (\n        set_dims is not None\n    ), \"Cannot use .within() with a set with no dimensions.\"\n    dims = self.dimensions\n    assert (\n        dims is not None\n    ), \"Cannot use .within() with an expression with no dimensions.\"\n    dims_in_common = [dim for dim in dims if dim in set_dims]\n    by_dims = df.select(dims_in_common).unique(maintain_order=True)\n    return self._new(self.data.join(by_dims, on=dims_in_common))\n</code></pre>"},{"location":"reference/#pyoframe.Model","title":"<code>Model(min_or_max, name=None, **kwargs)</code>","text":"<p>               Bases: <code>AttrContainerMixin</code></p> <p>Represents a mathematical optimization model. Add variables, constraints, and an objective to the model by setting attributes.</p> Source code in <code>pyoframe/model.py</code> <pre><code>def __init__(self, min_or_max: Union[ObjSense, ObjSenseValue], name=None, **kwargs):\n    super().__init__(**kwargs)\n    self._variables: List[Variable] = []\n    self._constraints: List[Constraint] = []\n    self.sense = ObjSense(min_or_max)\n    self._objective: Optional[Objective] = None\n    self.var_map = (\n        NamedVariableMapper(Variable) if Config.print_uses_variable_names else None\n    )\n    self.io_mappers: Optional[IOMappers] = None\n    self.name = name\n    self.solver: Optional[Solver] = None\n    self.solver_model: Optional[Any] = None\n    self.params = Container()\n    self.result: Optional[Result] = None\n</code></pre>"},{"location":"reference/#pyoframe.Set","title":"<code>Set(*data, **named_data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A set which can then be used to index variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyoframe as pf\n&gt;&gt;&gt; pf.Set(x=range(2), y=range(3))\n&lt;Set size=6 dimensions={'x': 2, 'y': 3}&gt;\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, *data: SetTypes | Iterable[SetTypes], **named_data):\n    data_list = list(data)\n    for name, set in named_data.items():\n        data_list.append({name: set})\n    df = self._parse_acceptable_sets(*data_list)\n    if not df.is_empty() and df.is_duplicated().any():\n        raise ValueError(\"Duplicate rows found in input data.\")\n    super().__init__(df)\n</code></pre>"},{"location":"reference/#pyoframe.Variable","title":"<code>Variable(*indexing_sets, lb=None, ub=None, vtype=VType.CONTINUOUS, equals=None)</code>","text":"<p>               Bases: <code>ModelElementWithId</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>Represents one or many decision variable in an optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>*indexing_sets</code> <code>SetTypes | Iterable[SetTypes]</code> <p>If no indexing_sets are provided, a single variable with no dimensions is created. Otherwise, a variable is created for each element in the Cartesian product of the indexing_sets (see Set for details on behaviour).</p> <code>()</code> <code>lb</code> <code>float | int | SupportsToExpr | None</code> <p>The lower bound for all variables.</p> <code>None</code> <code>ub</code> <code>float | int | SupportsToExpr | None</code> <p>The upper bound for all variables.</p> <code>None</code> <code>vtype</code> <code>VType | VTypeValue</code> <p>The type of the variable. Can be either a VType enum or a string. Default is VType.CONTINUOUS.</p> <code>CONTINUOUS</code> <code>equals</code> <code>Optional[SupportsMath]</code> <p>When specified, a variable is created and a constraint is added to make the variable equal to the provided expression.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; df = pd.DataFrame({\"dim1\": [1, 1, 2, 2, 3, 3], \"dim2\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]})\n&gt;&gt;&gt; Variable(df)\n&lt;Variable lb=-inf ub=inf size=6 dimensions={'dim1': 3, 'dim2': 2}&gt;\n[1,a]: x1\n[1,b]: x2\n[2,a]: x3\n[2,b]: x4\n[3,a]: x5\n[3,b]: x6\n&gt;&gt;&gt; Variable(df[[\"dim1\"]])\nTraceback (most recent call last):\n...\nValueError: Duplicate rows found in input data.\n&gt;&gt;&gt; Variable(df[[\"dim1\"]].drop_duplicates())\n&lt;Variable lb=-inf ub=inf size=3 dimensions={'dim1': 3}&gt;\n[1]: x7\n[2]: x8\n[3]: x9\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(\n    self,\n    *indexing_sets: SetTypes | Iterable[SetTypes],\n    lb: float | int | SupportsToExpr | None = None,\n    ub: float | int | SupportsToExpr | None = None,\n    vtype: VType | VTypeValue = VType.CONTINUOUS,\n    equals: Optional[SupportsMath] = None,\n):\n    if lb is None:\n        lb = float(\"-inf\")\n    if ub is None:\n        ub = float(\"inf\")\n    if equals is not None:\n        assert (\n            len(indexing_sets) == 0\n        ), \"Cannot specify both 'equals' and 'indexing_sets'\"\n        indexing_sets = (equals,)\n\n    data = Set(*indexing_sets).data if len(indexing_sets) &gt; 0 else pl.DataFrame()\n    super().__init__(data)\n\n    self.vtype: VType = VType(vtype)\n    self._equals = equals\n\n    # Tightening the bounds is not strictly necessary, but it adds clarity\n    if self.vtype == VType.BINARY:\n        lb, ub = 0, 1\n\n    if isinstance(lb, (float, int)):\n        self.lb, self.lb_constraint = lb, None\n    else:\n        self.lb, self.lb_constraint = float(\"-inf\"), lb &lt;= self\n\n    if isinstance(ub, (float, int)):\n        self.ub, self.ub_constraint = ub, None\n    else:\n        self.ub, self.ub_constraint = float(\"inf\"), self &lt;= ub\n</code></pre>"},{"location":"reference/#pyoframe.Variable.RC","title":"<code>RC</code>  <code>property</code> <code>writable</code>","text":"<p>The reduced cost of the variable. Will raise an error if the model has not already been solved. The first call to this property will load the reduced costs from the solver (lazy loading).</p>"},{"location":"reference/#pyoframe.Variable.next","title":"<code>next(dim, wrap_around=False)</code>","text":"<p>Creates an expression where the variable at each index is the next variable in the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>str</code> <p>The dimension over which to shift the variable.</p> required <code>wrap_around</code> <code>bool</code> <p>If True, the last index in the dimension is connected to the first index.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable, Model\n&gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n&gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n&gt;&gt;&gt; m = Model(\"min\")\n&gt;&gt;&gt; m.bat_charge = Variable(time_dim, space_dim)\n&gt;&gt;&gt; m.bat_flow = Variable(time_dim, space_dim)\n&gt;&gt;&gt; # Fails because the dimensions are not the same\n&gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n\u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n\u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\"time\")\n&lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\"time\", wrap_around=True)\n&lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n[18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n[18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def next(self, dim: str, wrap_around: bool = False) -&gt; Expression:\n    \"\"\"\n    Creates an expression where the variable at each index is the next variable in the specified dimension.\n\n    Parameters:\n        dim:\n            The dimension over which to shift the variable.\n        wrap_around:\n            If True, the last index in the dimension is connected to the first index.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyoframe import Variable, Model\n        &gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n        &gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n        &gt;&gt;&gt; m = Model(\"min\")\n        &gt;&gt;&gt; m.bat_charge = Variable(time_dim, space_dim)\n        &gt;&gt;&gt; m.bat_flow = Variable(time_dim, space_dim)\n        &gt;&gt;&gt; # Fails because the dimensions are not the same\n        &gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (2, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n        \u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n        \u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\"time\")\n        &lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\"time\", wrap_around=True)\n        &lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n        [18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n        [18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n    \"\"\"\n\n    wrapped = self.data.select(dim).unique(maintain_order=True).sort(by=dim)\n    wrapped = wrapped.with_columns(pl.col(dim).shift(-1).alias(\"__next\"))\n    if wrap_around:\n        wrapped = wrapped.with_columns(pl.col(\"__next\").fill_null(pl.first(dim)))\n    else:\n        wrapped = wrapped.drop_nulls(dim)\n\n    expr = self.to_expr()\n    data = expr.data.rename({dim: \"__prev\"})\n\n    if POLARS_VERSION.major &lt; 1:\n        data = data.join(\n            wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n        ).drop([\"__prev\", \"__next\"])\n    else:\n        data = data.join(\n            wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n        ).drop([\"__prev\", \"__next\"], strict=False)\n    return expr._new(data)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pyoframe<ul> <li>constants</li> <li>core</li> <li>io</li> <li>io_mappers</li> <li>model</li> <li>model_element</li> <li>monkey_patch</li> <li>objective</li> <li>solvers</li> <li>user_defined</li> <li>util</li> </ul> </li> </ul>"},{"location":"reference/constants/","title":"constants","text":"<p>File containing shared constants used across the package.</p> <p>Code is heavily based on the <code>linopy</code> package by Fabian Hofmann.</p> <p>MIT License</p>"},{"location":"reference/constants/#pyoframe.constants.Config","title":"<code>Config</code>","text":""},{"location":"reference/constants/#pyoframe.constants.Config.reset_defaults","title":"<code>reset_defaults()</code>  <code>classmethod</code>","text":"<p>Resets all configuration options to their default values.</p> Source code in <code>pyoframe/constants.py</code> <pre><code>@classmethod\ndef reset_defaults(cls):\n    \"\"\"\n    Resets all configuration options to their default values.\n    \"\"\"\n    for key, value in cls._defaults.items():\n        setattr(cls, key, value)\n</code></pre>"},{"location":"reference/constants/#pyoframe.constants.ModelStatus","title":"<code>ModelStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Model status.</p> <p>The set of possible model status is a superset of the solver status set.</p>"},{"location":"reference/constants/#pyoframe.constants.Result","title":"<code>Result(status, solution=None)</code>  <code>dataclass</code>","text":"<p>Result of the optimization.</p>"},{"location":"reference/constants/#pyoframe.constants.Solution","title":"<code>Solution(primal, dual, objective)</code>  <code>dataclass</code>","text":"<p>Solution returned by the solver.</p>"},{"location":"reference/constants/#pyoframe.constants.SolverStatus","title":"<code>SolverStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Solver status.</p>"},{"location":"reference/constants/#pyoframe.constants.Status","title":"<code>Status(status, termination_condition)</code>  <code>dataclass</code>","text":"<p>Status and termination condition of the solver.</p>"},{"location":"reference/constants/#pyoframe.constants.TerminationCondition","title":"<code>TerminationCondition</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Termination condition of the solver.</p>"},{"location":"reference/core/","title":"core","text":""},{"location":"reference/core/#pyoframe.core.Constraint","title":"<code>Constraint(lhs, sense)</code>","text":"<p>               Bases: <code>ModelElementWithId</code></p> <p>A linear programming constraint.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expression</code> <p>The left hand side of the constraint.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, lhs: Expression, sense: ConstraintSense):\n    \"\"\"Initialize a constraint.\n\n    Parameters:\n        lhs:\n            The left hand side of the constraint.\n        sense:\n            The sense of the constraint.\n    \"\"\"\n    self.lhs = lhs\n    self._model = lhs._model\n    self.sense = sense\n    self.to_relax: Optional[FuncArgs] = None\n\n    dims = self.lhs.dimensions\n    data = pl.DataFrame() if dims is None else self.lhs.data.select(dims).unique()\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Constraint.slack","title":"<code>slack</code>  <code>property</code> <code>writable</code>","text":"<p>The slack of the constraint. Will raise an error if the model has not already been solved. The first call to this property will load the slack values from the solver (lazy loading).</p>"},{"location":"reference/core/#pyoframe.core.Constraint.relax","title":"<code>relax(cost, max=None)</code>","text":"<p>Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>SupportsToExpr</code> <p>The cost of relaxing the constraint. Costs should be positives as they will automatically become negative for maximization problems.</p> required <code>max</code> <code>Optional[SupportsToExpr]</code> <p>The maximum value of the relaxation variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>The same constraint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyoframe as pf\n&gt;&gt;&gt; m = pf.Model(\"max\")\n&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n&gt;&gt;&gt; m.must_finish_project = m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n&gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n&gt;&gt;&gt; _ = m.must_finish_project.relax(homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]], max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]])\n&gt;&gt;&gt; _ = m.solve(log_to_console=False)\n\nWriting ...\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 8.0      \u2502\n\u2502 B       \u2506 7.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; # It can also be done all in one go!\n&gt;&gt;&gt; m = pf.Model(\"max\")\n&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n&gt;&gt;&gt; m.must_finish_project = (m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]).relax(5)\n&gt;&gt;&gt; m.only_one_day = (sum(\"project\", m.hours_spent) &lt;= 24).relax(1)\n&gt;&gt;&gt; _ = m.solve(log_to_console=False)\n\nWriting ...\n&gt;&gt;&gt; m.objective.value\n-3.0\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 9.0      \u2502\n\u2502 B       \u2506 9.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def relax(\n    self, cost: SupportsToExpr, max: Optional[SupportsToExpr] = None\n) -&gt; Constraint:\n    \"\"\"\n    Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.\n\n    Parameters:\n        cost:\n            The cost of relaxing the constraint. Costs should be positives as they will automatically\n            become negative for maximization problems.\n        max:\n            The maximum value of the relaxation variable.\n\n    Returns:\n        The same constraint\n\n    Examples:\n        &gt;&gt;&gt; import pyoframe as pf\n        &gt;&gt;&gt; m = pf.Model(\"max\")\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n        &gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n        &gt;&gt;&gt; _ = m.must_finish_project.relax(homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]], max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]])\n        &gt;&gt;&gt; _ = m.solve(log_to_console=False) # doctest: +ELLIPSIS\n        \\rWriting ...\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 8.0      \u2502\n        \u2502 B       \u2506 7.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n        &gt;&gt;&gt; # It can also be done all in one go!\n        &gt;&gt;&gt; m = pf.Model(\"max\")\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame({\"project\": [\"A\", \"B\", \"C\"], \"cost_per_hour_underdelivered\": [10, 20, 30], \"hours_to_finish\": [9, 9, 9], \"max_underdelivered\": [1, 9, 9]})\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = (m.hours_spent &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]).relax(5)\n        &gt;&gt;&gt; m.only_one_day = (sum(\"project\", m.hours_spent) &lt;= 24).relax(1)\n        &gt;&gt;&gt; _ = m.solve(log_to_console=False) # doctest: +ELLIPSIS\n        \\rWriting ...\n        &gt;&gt;&gt; m.objective.value\n        -3.0\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 9.0      \u2502\n        \u2502 B       \u2506 9.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    m = self._model\n    if m is None or self.name is None:\n        self.to_relax = FuncArgs(args=[cost, max])\n        return self\n\n    var_name = f\"{self.name}_relaxation\"\n    assert not hasattr(\n        m, var_name\n    ), \"Conflicting names, relaxation variable already exists on the model.\"\n    var = Variable(self, lb=0, ub=max)\n\n    if self.sense == ConstraintSense.LE:\n        self.lhs -= var\n    elif self.sense == ConstraintSense.GE:\n        self.lhs += var\n    else:  # pragma: no cover\n        # TODO\n        raise NotImplementedError(\n            \"Relaxation for equalities has not yet been implemented. Submit a pull request!\"\n        )\n\n    setattr(m, var_name, var)\n    penalty = var * cost\n    if self.dimensions:\n        penalty = sum(self.dimensions, penalty)\n    if m.sense == ObjSense.MAX:\n        penalty *= -1\n    if m.objective is None:\n        m.objective = penalty\n    else:\n        m.objective += penalty\n\n    return self\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression","title":"<code>Expression(data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A linear expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable, Model\n&gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m = Model(\"min\")\n&gt;&gt;&gt; m.Time = Variable(df.index)\n&gt;&gt;&gt; m.Size = Variable(df.index)\n&gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n&gt;&gt;&gt; expr\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n[1,mon]: Time[1,mon] + Size[1,mon]\n[1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n[1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n[2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n[2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, data: pl.DataFrame):\n    \"\"\"\n    A linear expression.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyoframe import Variable, Model\n        &gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; m = Model(\"min\")\n        &gt;&gt;&gt; m.Time = Variable(df.index)\n        &gt;&gt;&gt; m.Size = Variable(df.index)\n        &gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n        &gt;&gt;&gt; expr\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n        [1,mon]: Time[1,mon] + Size[1,mon]\n        [1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n        [1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n        [2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n        [2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n    \"\"\"\n    # Sanity checks, VAR_KEY and COEF_KEY must be present\n    assert VAR_KEY in data.columns, \"Missing variable column.\"\n    assert COEF_KEY in data.columns, \"Missing coefficient column.\"\n\n    # Sanity check no duplicates indices\n    if Config.enable_is_duplicated_expression_safety_check:\n        duplicated_mask = data.drop(COEF_KEY).is_duplicated()\n        # In theory this should never happen unless there's a bug in the library\n        if duplicated_mask.any():  # pragma: no cover\n            duplicated_data = data.filter(duplicated_mask)\n            raise ValueError(\n                f\"Cannot create an expression with duplicate indices:\\n{duplicated_data}.\"\n            )\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.value","title":"<code>value: pl.DataFrame</code>  <code>property</code>","text":"<p>The value of the expression. Only available after the model has been solved.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyoframe as pf\n&gt;&gt;&gt; m = pf.Model(\"max\")\n&gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, ub=10)\n&gt;&gt;&gt; m.expr_1 = 2 * m.X + 1\n&gt;&gt;&gt; m.expr_2 = pf.sum(m.expr_1)\n&gt;&gt;&gt; m.objective = m.expr_2 - 3\n&gt;&gt;&gt; result = m.solve(log_to_console=False)\n\n...\n&gt;&gt;&gt; m.expr_1.value\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 21.0     \u2502\n\u2502 2    \u2506 21.0     \u2502\n\u2502 3    \u2506 21.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.expr_2.value\n63.0\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.__add__","title":"<code>__add__(other)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1,2,3], \"add\": [10, 20, 30]}).to_expr()\n&gt;&gt;&gt; var = Variable(add)\n&gt;&gt;&gt; var + add\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: x1 +10\n[2]: x2 +20\n[3]: x3 +30\n&gt;&gt;&gt; var + add + 2\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: x1 +12\n[2]: x2 +22\n[3]: x3 +32\n&gt;&gt;&gt; var + pd.DataFrame({\"dim1\": [1,2], \"add\": [10, 20]})\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim1_right \u2502\n\u2502 ---  \u2506 ---        \u2502\n\u2502 i64  \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3    \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; 5 + 2 * Variable()\n&lt;Expression size=1 dimensions={} terms=2&gt;\n2 x4 +5\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyoframe import Variable\n        &gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1,2,3], \"add\": [10, 20, 30]}).to_expr()\n        &gt;&gt;&gt; var = Variable(add)\n        &gt;&gt;&gt; var + add\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: x1 +10\n        [2]: x2 +20\n        [3]: x3 +30\n        &gt;&gt;&gt; var + add + 2\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: x1 +12\n        [2]: x2 +22\n        [3]: x3 +32\n        &gt;&gt;&gt; var + pd.DataFrame({\"dim1\": [1,2], \"add\": [10, 20]})\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (1, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim1_right \u2502\n        \u2502 ---  \u2506 ---        \u2502\n        \u2502 i64  \u2506 i64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 3    \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; 5 + 2 * Variable()\n        &lt;Expression size=1 dimensions={} terms=2&gt;\n        2 x4 +5\n    \"\"\"\n    if isinstance(other, str):\n        raise ValueError(\n            \"Cannot add a string to an expression. Perhaps you meant to use pf.sum() instead of sum()?\"\n        )\n    if isinstance(other, (int, float)):\n        return self._add_const(other)\n    other = other.to_expr()\n    self._learn_from_other(other)\n    return _add_expressions(self, other)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.map","title":"<code>map(mapping_set, drop_shared_dims=True)</code>","text":"<p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <p>This is particularly useful to go from one type of dimensions to another. For example, to convert data that is indexed by city to data indexed by country (see example).</p> <p>Parameters:</p> Name Type Description Default <code>mapping_set</code> <code>SetTypes</code> <p>The set to map the expression to. This can be a DataFrame, Index, or another Set.</p> required <code>drop_shared_dims</code> <code>bool</code> <p>If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and     repeated rows are summed. If False, the shared dimensions are kept in the resulting expression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression containing the result of the mapping operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pyoframe import Variable, Model\n&gt;&gt;&gt; pop_data = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"year\": [2024, 2024, 2024], \"population\": [10, 2, 8]}).to_expr()\n&gt;&gt;&gt; cities_and_countries = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"country\": [\"Canada\", \"Canada\", \"USA\"]})\n&gt;&gt;&gt; pop_data.map(cities_and_countries)\n&lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n[2024,Canada]: 12\n[2024,USA]: 8\n&gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n&lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n[Toronto,2024,Canada]: 10\n[Vancouver,2024,Canada]: 2\n[Boston,2024,USA]: 8\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def map(self, mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression:\n    \"\"\"\n    Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.\n\n    This is particularly useful to go from one type of dimensions to another. For example, to convert data that\n    is indexed by city to data indexed by country (see example).\n\n    Parameters:\n        mapping_set:\n            The set to map the expression to. This can be a DataFrame, Index, or another Set.\n        drop_shared_dims:\n            If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and\n                repeated rows are summed.\n            If False, the shared dimensions are kept in the resulting expression.\n\n    Returns:\n        A new Expression containing the result of the mapping operation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from pyoframe import Variable, Model\n        &gt;&gt;&gt; pop_data = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"year\": [2024, 2024, 2024], \"population\": [10, 2, 8]}).to_expr()\n        &gt;&gt;&gt; cities_and_countries = pl.DataFrame({\"city\": [\"Toronto\", \"Vancouver\", \"Boston\"], \"country\": [\"Canada\", \"Canada\", \"USA\"]})\n        &gt;&gt;&gt; pop_data.map(cities_and_countries)\n        &lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n        [2024,Canada]: 12\n        [2024,USA]: 8\n        &gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n        &lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n        [Toronto,2024,Canada]: 10\n        [Vancouver,2024,Canada]: 2\n        [Boston,2024,USA]: 8\n    \"\"\"\n    mapping_set = Set(mapping_set)\n\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot use .map() on an expression with no dimensions.\")\n\n    mapping_dims = mapping_set.dimensions\n    if mapping_dims is None:\n        raise ValueError(\n            \"Cannot use .map() with a mapping set containing no dimensions.\"\n        )\n\n    shared_dims = [dim for dim in dims if dim in mapping_dims]\n    if not shared_dims:\n        raise ValueError(\n            f\"Cannot apply .map() as there are no shared dimensions between the expression (dims={self.dimensions}) and the mapping set (dims={mapping_set.dimensions}).\"\n        )\n\n    mapped_expression = self * mapping_set\n\n    if drop_shared_dims:\n        return sum(shared_dims, mapped_expression)\n\n    return mapped_expression\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.rolling_sum","title":"<code>rolling_sum(over, window_size)</code>","text":"<p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <p>This method applies a rolling sum operation over the dimension specified by <code>over</code>, using a window defined by <code>window_size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>over</code> <p>The name of the dimension (column) over which the rolling sum is calculated. This dimension must exist within the Expression's dimensions.</p> required <code>window_size</code> <p>The size of the moving window in terms of number of records. The rolling sum is calculated over this many consecutive elements.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression instance containing the result of the rolling sum operation. This new Expression retains all dimensions (columns) of the original data, with the rolling sum applied over the specified dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pyoframe import Variable, Model\n&gt;&gt;&gt; cost = pl.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [1, 2, 3, 1, 2], \"cost\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; m = Model(\"min\")\n&gt;&gt;&gt; m.quantity = Variable(cost[[\"item\", \"time\"]])\n&gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n[1,1]: quantity[1,1]\n[1,2]: quantity[1,1] +2 quantity[1,2]\n[1,3]: 2 quantity[1,2] +3 quantity[1,3]\n[2,1]: 4 quantity[2,1]\n[2,2]: 4 quantity[2,1] +5 quantity[2,2]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def rolling_sum(self, over: str, window_size: int) -&gt; Expression:\n    \"\"\"\n    Calculates the rolling sum of the Expression over a specified window size for a given dimension.\n\n    This method applies a rolling sum operation over the dimension specified by `over`,\n    using a window defined by `window_size`.\n\n\n    Parameters:\n        over :\n            The name of the dimension (column) over which the rolling sum is calculated.\n            This dimension must exist within the Expression's dimensions.\n        window_size :\n            The size of the moving window in terms of number of records.\n            The rolling sum is calculated over this many consecutive elements.\n\n    Returns:\n        A new Expression instance containing the result of the rolling sum operation.\n            This new Expression retains all dimensions (columns) of the original data,\n            with the rolling sum applied over the specified dimension.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; from pyoframe import Variable, Model\n        &gt;&gt;&gt; cost = pl.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [1, 2, 3, 1, 2], \"cost\": [1, 2, 3, 4, 5]})\n        &gt;&gt;&gt; m = Model(\"min\")\n        &gt;&gt;&gt; m.quantity = Variable(cost[[\"item\", \"time\"]])\n        &gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n        [1,1]: quantity[1,1]\n        [1,2]: quantity[1,1] +2 quantity[1,2]\n        [1,3]: 2 quantity[1,2] +3 quantity[1,3]\n        [2,1]: 4 quantity[2,1]\n        [2,2]: 4 quantity[2,1] +5 quantity[2,2]\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\n            \"Cannot use rolling_sum() with an expression with no dimensions.\"\n        )\n    assert over in dims, f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        pl.concat(\n            [\n                df.with_columns(pl.col(over).max())\n                for _, df in self.data.rolling(\n                    index_column=over,\n                    period=f\"{window_size}i\",\n                    group_by=remaining_dims,\n                )\n            ]\n        )\n    )\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.sum","title":"<code>sum(over)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n&gt;&gt;&gt; expr = (quantity * df[\"cost\"]).sum(\"time\")\n&gt;&gt;&gt; expr.data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0     \u2506 1             \u2502\n\u2502 2    \u2506 9.0     \u2506 2             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def sum(self, over: Union[str, Iterable[str]]):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyoframe import Variable\n        &gt;&gt;&gt; df = pd.DataFrame({\"item\" : [1, 1, 1, 2, 2], \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"], \"cost\": [1, 2, 3, 4, 5]}).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n        &gt;&gt;&gt; expr = (quantity * df[\"cost\"]).sum(\"time\")\n        &gt;&gt;&gt; expr.data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 6.0     \u2506 1             \u2502\n        \u2502 2    \u2506 9.0     \u2506 2             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if isinstance(over, str):\n        over = [over]\n    dims = self.dimensions\n    if not dims:\n        raise ValueError(\n            f\"Cannot sum over dimensions {over} since the current expression has no dimensions.\"\n        )\n    assert set(over) &lt;= set(dims), f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        self.data.drop(over)\n        .group_by(remaining_dims + [VAR_KEY], maintain_order=True)\n        .sum()\n    )\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Expression.within","title":"<code>within(set)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; general_expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n&gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n&gt;&gt;&gt; general_expr.within(filter_expr).data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0     \u2506 0             \u2502\n\u2502 3    \u2506 3.0     \u2506 0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def within(self, set: \"SetTypes\") -&gt; Expression:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; general_expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n        &gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n        &gt;&gt;&gt; general_expr.within(filter_expr).data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0     \u2506 0             \u2502\n        \u2502 3    \u2506 3.0     \u2506 0             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df: pl.DataFrame = Set(set).data\n    set_dims = _get_dimensions(df)\n    assert (\n        set_dims is not None\n    ), \"Cannot use .within() with a set with no dimensions.\"\n    dims = self.dimensions\n    assert (\n        dims is not None\n    ), \"Cannot use .within() with an expression with no dimensions.\"\n    dims_in_common = [dim for dim in dims if dim in set_dims]\n    by_dims = df.select(dims_in_common).unique(maintain_order=True)\n    return self._new(self.data.join(by_dims, on=dims_in_common))\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Set","title":"<code>Set(*data, **named_data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A set which can then be used to index variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyoframe as pf\n&gt;&gt;&gt; pf.Set(x=range(2), y=range(3))\n&lt;Set size=6 dimensions={'x': 2, 'y': 3}&gt;\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, *data: SetTypes | Iterable[SetTypes], **named_data):\n    data_list = list(data)\n    for name, set in named_data.items():\n        data_list.append({name: set})\n    df = self._parse_acceptable_sets(*data_list)\n    if not df.is_empty() and df.is_duplicated().any():\n        raise ValueError(\"Duplicate rows found in input data.\")\n    super().__init__(df)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath","title":"<code>SupportsMath(**kwargs)</code>","text":"<p>               Bases: <code>ABC</code>, <code>SupportsToExpr</code></p> <p>Any object that can be converted into an expression.</p> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, **kwargs):\n    self.unmatched_strategy = UnmatchedStrategy.UNSET\n    self.allowed_new_dims: List[str] = []\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__eq__","title":"<code>__eq__(value)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; Variable() == 1\n&lt;Constraint sense='=' size=1 dimensions={} terms=2&gt;\nx1 = 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __eq__(self, value: object):\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; from pyoframe import Variable\n        &gt;&gt;&gt; Variable() == 1\n        &lt;Constraint sense='=' size=1 dimensions={} terms=2&gt;\n        x1 = 1\n    \"\"\"\n    return Constraint(self - value, ConstraintSense.EQ)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; Variable() &gt;= 1\n&lt;Constraint sense='&gt;=' size=1 dimensions={} terms=2&gt;\nx1 &gt;= 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __ge__(self, other):\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; from pyoframe import Variable\n        &gt;&gt;&gt; Variable() &gt;= 1\n        &lt;Constraint sense='&gt;=' size=1 dimensions={} terms=2&gt;\n        x1 &gt;= 1\n    \"\"\"\n    return Constraint(self - other, ConstraintSense.GE)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__le__","title":"<code>__le__(other)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; Variable() &lt;= 1\n&lt;Constraint sense='&lt;=' size=1 dimensions={} terms=2&gt;\nx1 &lt;= 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __le__(self, other):\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; from pyoframe import Variable\n        &gt;&gt;&gt; Variable() &lt;= 1\n        &lt;Constraint sense='&lt;=' size=1 dimensions={} terms=2&gt;\n        x1 &lt;= 1\n    \"\"\"\n    return Constraint(self - other, ConstraintSense.LE)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__rsub__","title":"<code>__rsub__(other)</code>","text":"<p>Support right subtraction.</p> <p>from pyoframe import Variable var = Variable({\"dim1\": [1,2,3]}) 1 - var  [1]: 1  - x1 [2]: 1  - x2 [3]: 1  - x3 Source code in <code>pyoframe/core.py</code> <pre><code>def __rsub__(self, other):\n    \"\"\"\n    Support right subtraction.\n    &gt;&gt;&gt; from pyoframe import Variable\n    &gt;&gt;&gt; var = Variable({\"dim1\": [1,2,3]})\n    &gt;&gt;&gt; 1 - var\n    &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n    [1]: 1  - x1\n    [2]: 1  - x2\n    [3]: 1  - x3\n    \"\"\"\n    return other + (-self.to_expr())\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__sub__","title":"<code>__sub__(other)</code>","text":"<p>import polars as pl from pyoframe import Variable df = pl.DataFrame({\"dim1\": [1,2,3], \"value\": [1,2,3]}) var = Variable(df[\"dim1\"]) var - df  [1]: x1 -1 [2]: x2 -2 [3]: x3 -3 Source code in <code>pyoframe/core.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"\n    &gt;&gt;&gt; import polars as pl\n    &gt;&gt;&gt; from pyoframe import Variable\n    &gt;&gt;&gt; df = pl.DataFrame({\"dim1\": [1,2,3], \"value\": [1,2,3]})\n    &gt;&gt;&gt; var = Variable(df[\"dim1\"])\n    &gt;&gt;&gt; var - df\n    &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n    [1]: x1 -1\n    [2]: x2 -2\n    [3]: x3 -3\n    \"\"\"\n    if not isinstance(other, (int, float)):\n        other = other.to_expr()\n    return self.to_expr() + (-other)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.SupportsMath.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Support division.</p> <p>from pyoframe import Variable var = Variable({\"dim1\": [1,2,3]}) var / 2  [1]: 0.5 x1 [2]: 0.5 x2 [3]: 0.5 x3 Source code in <code>pyoframe/core.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"\n    Support division.\n    &gt;&gt;&gt; from pyoframe import Variable\n    &gt;&gt;&gt; var = Variable({\"dim1\": [1,2,3]})\n    &gt;&gt;&gt; var / 2\n    &lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt;\n    [1]: 0.5 x1\n    [2]: 0.5 x2\n    [3]: 0.5 x3\n    \"\"\"\n    return self.to_expr() * (1 / other)\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Variable","title":"<code>Variable(*indexing_sets, lb=None, ub=None, vtype=VType.CONTINUOUS, equals=None)</code>","text":"<p>               Bases: <code>ModelElementWithId</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>Represents one or many decision variable in an optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>*indexing_sets</code> <code>SetTypes | Iterable[SetTypes]</code> <p>If no indexing_sets are provided, a single variable with no dimensions is created. Otherwise, a variable is created for each element in the Cartesian product of the indexing_sets (see Set for details on behaviour).</p> <code>()</code> <code>lb</code> <code>float | int | SupportsToExpr | None</code> <p>The lower bound for all variables.</p> <code>None</code> <code>ub</code> <code>float | int | SupportsToExpr | None</code> <p>The upper bound for all variables.</p> <code>None</code> <code>vtype</code> <code>VType | VTypeValue</code> <p>The type of the variable. Can be either a VType enum or a string. Default is VType.CONTINUOUS.</p> <code>CONTINUOUS</code> <code>equals</code> <code>Optional[SupportsMath]</code> <p>When specified, a variable is created and a constraint is added to make the variable equal to the provided expression.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable\n&gt;&gt;&gt; df = pd.DataFrame({\"dim1\": [1, 1, 2, 2, 3, 3], \"dim2\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]})\n&gt;&gt;&gt; Variable(df)\n&lt;Variable lb=-inf ub=inf size=6 dimensions={'dim1': 3, 'dim2': 2}&gt;\n[1,a]: x1\n[1,b]: x2\n[2,a]: x3\n[2,b]: x4\n[3,a]: x5\n[3,b]: x6\n&gt;&gt;&gt; Variable(df[[\"dim1\"]])\nTraceback (most recent call last):\n...\nValueError: Duplicate rows found in input data.\n&gt;&gt;&gt; Variable(df[[\"dim1\"]].drop_duplicates())\n&lt;Variable lb=-inf ub=inf size=3 dimensions={'dim1': 3}&gt;\n[1]: x7\n[2]: x8\n[3]: x9\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(\n    self,\n    *indexing_sets: SetTypes | Iterable[SetTypes],\n    lb: float | int | SupportsToExpr | None = None,\n    ub: float | int | SupportsToExpr | None = None,\n    vtype: VType | VTypeValue = VType.CONTINUOUS,\n    equals: Optional[SupportsMath] = None,\n):\n    if lb is None:\n        lb = float(\"-inf\")\n    if ub is None:\n        ub = float(\"inf\")\n    if equals is not None:\n        assert (\n            len(indexing_sets) == 0\n        ), \"Cannot specify both 'equals' and 'indexing_sets'\"\n        indexing_sets = (equals,)\n\n    data = Set(*indexing_sets).data if len(indexing_sets) &gt; 0 else pl.DataFrame()\n    super().__init__(data)\n\n    self.vtype: VType = VType(vtype)\n    self._equals = equals\n\n    # Tightening the bounds is not strictly necessary, but it adds clarity\n    if self.vtype == VType.BINARY:\n        lb, ub = 0, 1\n\n    if isinstance(lb, (float, int)):\n        self.lb, self.lb_constraint = lb, None\n    else:\n        self.lb, self.lb_constraint = float(\"-inf\"), lb &lt;= self\n\n    if isinstance(ub, (float, int)):\n        self.ub, self.ub_constraint = ub, None\n    else:\n        self.ub, self.ub_constraint = float(\"inf\"), self &lt;= ub\n</code></pre>"},{"location":"reference/core/#pyoframe.core.Variable.RC","title":"<code>RC</code>  <code>property</code> <code>writable</code>","text":"<p>The reduced cost of the variable. Will raise an error if the model has not already been solved. The first call to this property will load the reduced costs from the solver (lazy loading).</p>"},{"location":"reference/core/#pyoframe.core.Variable.next","title":"<code>next(dim, wrap_around=False)</code>","text":"<p>Creates an expression where the variable at each index is the next variable in the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>str</code> <p>The dimension over which to shift the variable.</p> required <code>wrap_around</code> <code>bool</code> <p>If True, the last index in the dimension is connected to the first index.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyoframe import Variable, Model\n&gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n&gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n&gt;&gt;&gt; m = Model(\"min\")\n&gt;&gt;&gt; m.bat_charge = Variable(time_dim, space_dim)\n&gt;&gt;&gt; m.bat_flow = Variable(time_dim, space_dim)\n&gt;&gt;&gt; # Fails because the dimensions are not the same\n&gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n\u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n\u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\"time\")\n&lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\"time\", wrap_around=True)\n&lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n[18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n[18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def next(self, dim: str, wrap_around: bool = False) -&gt; Expression:\n    \"\"\"\n    Creates an expression where the variable at each index is the next variable in the specified dimension.\n\n    Parameters:\n        dim:\n            The dimension over which to shift the variable.\n        wrap_around:\n            If True, the last index in the dimension is connected to the first index.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyoframe import Variable, Model\n        &gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n        &gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n        &gt;&gt;&gt; m = Model(\"min\")\n        &gt;&gt;&gt; m.bat_charge = Variable(time_dim, space_dim)\n        &gt;&gt;&gt; m.bat_flow = Variable(time_dim, space_dim)\n        &gt;&gt;&gt; # Fails because the dimensions are not the same\n        &gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (2, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n        \u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n        \u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\"time\")\n        &lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\"time\", wrap_around=True)\n        &lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n        [18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n        [18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n    \"\"\"\n\n    wrapped = self.data.select(dim).unique(maintain_order=True).sort(by=dim)\n    wrapped = wrapped.with_columns(pl.col(dim).shift(-1).alias(\"__next\"))\n    if wrap_around:\n        wrapped = wrapped.with_columns(pl.col(\"__next\").fill_null(pl.first(dim)))\n    else:\n        wrapped = wrapped.drop_nulls(dim)\n\n    expr = self.to_expr()\n    data = expr.data.rename({dim: \"__prev\"})\n\n    if POLARS_VERSION.major &lt; 1:\n        data = data.join(\n            wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n        ).drop([\"__prev\", \"__next\"])\n    else:\n        data = data.join(\n            wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n        ).drop([\"__prev\", \"__next\"], strict=False)\n    return expr._new(data)\n</code></pre>"},{"location":"reference/io/","title":"io","text":"<p>Module containing all import/export functionalities.</p>"},{"location":"reference/io/#pyoframe.io.binaries_to_file","title":"<code>binaries_to_file(m, f, var_map)</code>","text":"<p>Write out binaries of a model to a lp file.</p> Source code in <code>pyoframe/io.py</code> <pre><code>def binaries_to_file(m: \"Model\", f, var_map: Mapper):\n    \"\"\"\n    Write out binaries of a model to a lp file.\n    \"\"\"\n    for variable in create_section(\n        io_progress_bar(\n            m.binary_variables,\n            prefix=\"Writing binary variables to file\",\n            update_every=1,\n        ),\n        f,\n        \"binary\",\n    ):\n        lines = (\n            var_map.apply(variable.data, to_col=None)\n            .select(pl.col(VAR_KEY).str.concat(\"\\n\"))\n            .item()\n        )\n        f.write(lines + \"\\n\")\n</code></pre>"},{"location":"reference/io/#pyoframe.io.bounds_to_file","title":"<code>bounds_to_file(m, f, var_map)</code>","text":"<p>Write out variables of a model to a lp file.</p> Source code in <code>pyoframe/io.py</code> <pre><code>def bounds_to_file(m: \"Model\", f, var_map):\n    \"\"\"\n    Write out variables of a model to a lp file.\n    \"\"\"\n    if (m.objective is not None and m.objective.has_constant) or len(m.variables) != 0:\n        f.write(\"\\n\\nbounds\\n\\n\")\n    if m.objective is not None and m.objective.has_constant:\n        const_term_df = pl.DataFrame(\n            {VAR_KEY: [CONST_TERM]}, schema={VAR_KEY: pl.UInt32}\n        )\n        f.write(f\"{var_map.apply(const_term_df).item()} = 1\\n\")\n\n    for variable in io_progress_bar(\n        m.variables, prefix=\"Writing bounds to file\", update_every=1\n    ):\n        terms = []\n\n        if variable.lb != 0:\n            terms.append(pl.lit(f\"{variable.lb:.12g} &lt;= \"))\n\n        terms.append(VAR_KEY)\n\n        if variable.ub != float(\"inf\"):\n            terms.append(pl.lit(f\" &lt;= {variable.ub:.12g}\"))\n\n        terms.append(pl.lit(\"\\n\"))\n\n        if len(terms) &lt; 3:\n            continue\n\n        df = (\n            var_map.apply(variable.data, to_col=None)\n            .select(pl.concat_str(terms).str.concat(\"\"))\n            .item()\n        )\n\n        f.write(df)\n</code></pre>"},{"location":"reference/io/#pyoframe.io.integers_to_file","title":"<code>integers_to_file(m, f, var_map)</code>","text":"<p>Write out integers of a model to a lp file.</p> Source code in <code>pyoframe/io.py</code> <pre><code>def integers_to_file(m: \"Model\", f, var_map: Mapper):\n    \"\"\"\n    Write out integers of a model to a lp file.\n    \"\"\"\n    for variable in create_section(\n        io_progress_bar(\n            m.integer_variables,\n            prefix=\"Writing integer variables to file\",\n            update_every=5,\n        ),\n        f,\n        \"general\",\n    ):\n        lines = (\n            var_map.apply(variable.data, to_col=None)\n            .select(pl.col(VAR_KEY).str.concat(\"\\n\"))\n            .item()\n        )\n        f.write(lines + \"\\n\")\n</code></pre>"},{"location":"reference/io/#pyoframe.io.io_progress_bar","title":"<code>io_progress_bar(iterable, prefix='', suffix='', length=50, fill='\u2588', update_every=1)</code>","text":"<p>Display progress bar for I/O operations.</p> Source code in <code>pyoframe/io.py</code> <pre><code>def io_progress_bar(\n    iterable: Iterable[T],\n    prefix: str = \"\",\n    suffix: str = \"\",\n    length: int = 50,\n    fill: str = \"\u2588\",\n    update_every: int = 1,\n):\n    \"\"\"\n    Display progress bar for I/O operations.\n    \"\"\"\n    try:\n        total = len(iterable)\n    except TypeError:\n        total = None\n\n    start_time = time.time()\n\n    def print_progress(iteration: int):\n        if total is not None:\n            percent = f\"{100 * (iteration / float(total)):.1f}\"\n            filled_length = int(length * iteration // total)\n            bar = fill * filled_length + \"-\" * (length - filled_length)\n        else:\n            percent = \"N/A\"\n            bar = fill * (iteration % length) + \"-\" * (length - (iteration % length))\n        elapsed_time = time.time() - start_time\n        if iteration &gt; 0:\n            estimated_total_time = (\n                elapsed_time * (total / iteration) if total else elapsed_time\n            )\n            estimated_remaining_time = estimated_total_time - elapsed_time\n            eta = time.strftime(\"%H:%M:%S\", time.gmtime(estimated_remaining_time))\n        else:\n            eta = \"Estimating...\"  # pragma: no cover\n        sys.stdout.write(\n            f'\\r{prefix} |{bar}| {percent}% Complete ({iteration}/{total if total else \"?\"}) ETA: {eta} {suffix}'\n        )\n        sys.stdout.flush()\n\n    for i, item in enumerate(iterable):\n        yield item\n        if (i + 1) % update_every == 0 or total is None or i == total - 1:\n            print_progress(i + 1)\n\n    sys.stdout.write(\"\\n\")\n    sys.stdout.flush()\n</code></pre>"},{"location":"reference/io/#pyoframe.io.objective_to_file","title":"<code>objective_to_file(m, f, var_map)</code>","text":"<p>Write out the objective of a model to a lp file.</p> Source code in <code>pyoframe/io.py</code> <pre><code>def objective_to_file(m: \"Model\", f: TextIOWrapper, var_map):\n    \"\"\"\n    Write out the objective of a model to a lp file.\n    \"\"\"\n    if m.objective is None:\n        return\n    objective_sense = \"minimize\" if m.sense == ObjSense.MIN else \"maximize\"\n    f.write(f\"{objective_sense}\\n\\nobj:\\n\\n\")\n    result = m.objective.to_str(\n        var_map=var_map, include_prefix=False, include_const_variable=True\n    )\n    f.write(result)\n</code></pre>"},{"location":"reference/io/#pyoframe.io.to_file","title":"<code>to_file(m, file_path=None, use_var_names=False)</code>","text":"<p>Write out a model to a lp file.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Model</code> <p>The model to write out.</p> required <code>file_path</code> <code>Optional[Union[str, Path]]</code> <p>The path to write the model to. If None, a temporary file is created. The caller is responsible for deleting the file after use.</p> <code>None</code> <code>use_var_names</code> <code>bool</code> <p>If True, variable names are used in the lp file. Otherwise, variable indices are used.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the lp file.</p> Source code in <code>pyoframe/io.py</code> <pre><code>def to_file(\n    m: \"Model\",\n    file_path: Optional[Union[str, Path]] = None,\n    use_var_names: bool = False,\n) -&gt; Path:\n    \"\"\"\n    Write out a model to a lp file.\n\n    Args:\n        m: The model to write out.\n        file_path: The path to write the model to. If None, a temporary file is created. The caller is responsible for\n            deleting the file after use.\n        use_var_names: If True, variable names are used in the lp file. Otherwise, variable\n            indices are used.\n\n    Returns:\n        The path to the lp file.\n    \"\"\"\n    if file_path is None:\n        with NamedTemporaryFile(\n            prefix=\"pyoframe-problem-\", suffix=\".lp\", mode=\"w\", delete=False\n        ) as f:\n            file_path = f.name\n\n    file_path = Path(file_path)\n    assert file_path.suffix == \".lp\", f\"File format `{file_path.suffix}` not supported.\"\n\n    if file_path.exists():\n        file_path.unlink()\n\n    const_map = (\n        NamedMapper(Constraint) if use_var_names else Base36ConstMapper(Constraint)\n    )\n    for c in m.constraints:\n        const_map.add(c)\n    var_map = get_var_map(m, use_var_names)\n    m.io_mappers = IOMappers(var_map, const_map)\n\n    with open(file_path, mode=\"w\") as f:\n        objective_to_file(m, f, var_map)\n        constraints_to_file(m, f, var_map, const_map)\n        bounds_to_file(m, f, var_map)\n        binaries_to_file(m, f, var_map)\n        integers_to_file(m, f, var_map)\n        f.write(\"\\nend\\n\")\n\n    return file_path\n</code></pre>"},{"location":"reference/io_mappers/","title":"io_mappers","text":"<p>Defines various methods for mapping a variable or constraint to its string representation.</p>"},{"location":"reference/io_mappers/#pyoframe.io_mappers.Base36Mapper","title":"<code>Base36Mapper(cls)</code>","text":"<p>               Bases: <code>Mapper</code>, <code>ABC</code></p> Source code in <code>pyoframe/io_mappers.py</code> <pre><code>def __init__(self, cls: Type[\"ModelElementWithId\"]) -&gt; None:\n    self._ID_COL = cls.get_id_column_name()\n    self.mapping_registry = pl.DataFrame(\n        {self._ID_COL: [], Mapper.NAME_COL: []},\n        schema={self._ID_COL: pl.UInt32, Mapper.NAME_COL: pl.String},\n    )\n</code></pre>"},{"location":"reference/io_mappers/#pyoframe.io_mappers.Base36VarMapper","title":"<code>Base36VarMapper(*args, **kwargs)</code>","text":"<p>               Bases: <code>Base36Mapper</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pyoframe import Model, Variable\n&gt;&gt;&gt; from pyoframe.constants import VAR_KEY\n&gt;&gt;&gt; m = Model(\"min\")\n&gt;&gt;&gt; m.x = Variable(pl.DataFrame({\"t\": range(1,63)}))\n&gt;&gt;&gt; (m.x.filter(t=11)+1).to_str()\n'[11]: 1  + x[11]'\n&gt;&gt;&gt; (m.x.filter(t=11)+1).to_str(var_map=Base36VarMapper(Variable))\n'[11]: 1  + xb'\n&gt;&gt;&gt; Base36VarMapper(Variable).apply(pl.DataFrame({VAR_KEY: []}))\nshape: (0, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 __variable_id \u2502\n\u2502 ---           \u2502\n\u2502 null          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/io_mappers.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    super().__init__(*args, **kwargs)\n    df = pl.DataFrame(\n        {self._ID_COL: [CONST_TERM]},\n        schema={self._ID_COL: pl.UInt32},\n    )\n    df = self.apply(df, to_col=Mapper.NAME_COL)\n    self._extend_registry(df)\n</code></pre>"},{"location":"reference/io_mappers/#pyoframe.io_mappers.NamedMapper","title":"<code>NamedMapper(cls)</code>","text":"<p>               Bases: <code>Mapper</code></p> <p>Maps constraints or variables to a string representation using the object's name and dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyoframe as pf\n&gt;&gt;&gt; m = pf.Model(\"min\")\n&gt;&gt;&gt; m.foo = pf.Variable(pl.DataFrame({\"t\": range(4)}))\n&gt;&gt;&gt; pf.sum(m.foo)\n&lt;Expression size=1 dimensions={} terms=4&gt;\nfoo[0] + foo[1] + foo[2] + foo[3]\n</code></pre> Source code in <code>pyoframe/io_mappers.py</code> <pre><code>def __init__(self, cls: Type[\"ModelElementWithId\"]) -&gt; None:\n    self._ID_COL = cls.get_id_column_name()\n    self.mapping_registry = pl.DataFrame(\n        {self._ID_COL: [], Mapper.NAME_COL: []},\n        schema={self._ID_COL: pl.UInt32, Mapper.NAME_COL: pl.String},\n    )\n</code></pre>"},{"location":"reference/model/","title":"model","text":""},{"location":"reference/model/#pyoframe.model.Model","title":"<code>Model(min_or_max, name=None, **kwargs)</code>","text":"<p>               Bases: <code>AttrContainerMixin</code></p> <p>Represents a mathematical optimization model. Add variables, constraints, and an objective to the model by setting attributes.</p> Source code in <code>pyoframe/model.py</code> <pre><code>def __init__(self, min_or_max: Union[ObjSense, ObjSenseValue], name=None, **kwargs):\n    super().__init__(**kwargs)\n    self._variables: List[Variable] = []\n    self._constraints: List[Constraint] = []\n    self.sense = ObjSense(min_or_max)\n    self._objective: Optional[Objective] = None\n    self.var_map = (\n        NamedVariableMapper(Variable) if Config.print_uses_variable_names else None\n    )\n    self.io_mappers: Optional[IOMappers] = None\n    self.name = name\n    self.solver: Optional[Solver] = None\n    self.solver_model: Optional[Any] = None\n    self.params = Container()\n    self.result: Optional[Result] = None\n</code></pre>"},{"location":"reference/model_element/","title":"model_element","text":""},{"location":"reference/model_element/#pyoframe.model_element.ModelElement","title":"<code>ModelElement(data, **kwargs)</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>pyoframe/model_element.py</code> <pre><code>def __init__(self, data: pl.DataFrame, **kwargs) -&gt; None:\n    # Sanity checks, no duplicate column names\n    assert len(data.columns) == len(\n        set(data.columns)\n    ), \"Duplicate column names found.\"\n\n    cols = _get_dimensions(data)\n    if cols is None:\n        cols = []\n    cols += [col for col in RESERVED_COL_KEYS if col in data.columns]\n\n    # Reorder columns to keep things consistent\n    data = data.select(cols)\n\n    # Cast to proper dtype\n    if COEF_KEY in data.columns:\n        data = data.cast({COEF_KEY: pl.Float64})\n    if VAR_KEY in data.columns:\n        data = data.cast({VAR_KEY: pl.UInt32})\n\n    self._data = data\n    self._model: Optional[Model] = None\n    self.name = None\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElement.dimensions","title":"<code>dimensions: Optional[List[str]]</code>  <code>property</code>","text":"<p>The names of the data's dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyoframe.core import Variable\n&gt;&gt;&gt; # A variable with no dimensions\n&gt;&gt;&gt; Variable().dimensions\n</code></pre> <pre><code>&gt;&gt;&gt; # A variable with dimensions of \"hour\" and \"city\"\n&gt;&gt;&gt; Variable([{\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]}, {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}]).dimensions\n['hour', 'city']\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElement.dimensions_unsafe","title":"<code>dimensions_unsafe: List[str]</code>  <code>property</code>","text":"<p>Same as <code>dimensions</code> but returns an empty list if there are no dimensions instead of None. When unsure, use <code>dimensions</code> instead since the type checker forces users to handle the None case (no dimensions).</p>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElement.shape","title":"<code>shape: Dict[str, int]</code>  <code>property</code>","text":"<p>The number of indices in each dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyoframe.core import Variable\n&gt;&gt;&gt; # A variable with no dimensions\n&gt;&gt;&gt; Variable().shape\n{}\n&gt;&gt;&gt; # A variable with dimensions of \"hour\" and \"city\"\n&gt;&gt;&gt; Variable([{\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]}, {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}]).shape\n{'hour': 4, 'city': 3}\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElementWithId","title":"<code>ModelElementWithId(data, **kwargs)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>AttrContainerMixin</code></p> <p>Provides a method that assigns a unique ID to each row in a DataFrame. IDs start at 1 and go up consecutively. No zero ID is assigned since it is reserved for the constant variable term. IDs are only unique for the subclass since different subclasses have different counters.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>def __init__(self, data: pl.DataFrame, **kwargs) -&gt; None:\n    super().__init__(data, **kwargs)\n    self._data = self._assign_ids(self.data)\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElementWithId.get_id_column_name","title":"<code>get_id_column_name()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Returns the name of the column containing the IDs.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_id_column_name(cls) -&gt; str:\n    \"\"\"\n    Returns the name of the column containing the IDs.\n    \"\"\"\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.ModelElementWithId.reset_counters","title":"<code>reset_counters()</code>  <code>classmethod</code>","text":"<p>Resets all the ID counters. This function is called before every unit test to reset the code state.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>@classmethod\ndef reset_counters(cls):\n    \"\"\"\n    Resets all the ID counters.\n    This function is called before every unit test to reset the code state.\n    \"\"\"\n    cls._id_counters = defaultdict(lambda: 1)\n</code></pre>"},{"location":"reference/model_element/#pyoframe.model_element.SupportPolarsMethodMixin","title":"<code>SupportPolarsMethodMixin</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/monkey_patch/","title":"monkey_patch","text":""},{"location":"reference/monkey_patch/#pyoframe.monkey_patch.patch_dataframe_libraries","title":"<code>patch_dataframe_libraries()</code>","text":"<p>Applies two patches to the DataFrame and Series classes of both pandas and polars. 1) Patches arithmetic operators (e.g. <code>__add__</code>) such that operations between DataFrames/Series and <code>Expressionable</code>s     are not supported (i.e. <code>return NotImplemented</code>). This leads Python to try the reverse operation (e.g. <code>__radd__</code>)     which is supported by the <code>Expressionable</code> class. 2) Adds a <code>to_expr</code> method to DataFrame/Series that allows them to be converted to an <code>Expression</code> object.     Series become dataframes and dataframes become expressions where everything but the last column are treated as dimensions.</p> Source code in <code>pyoframe/monkey_patch.py</code> <pre><code>def patch_dataframe_libraries():\n    \"\"\"\n    Applies two patches to the DataFrame and Series classes of both pandas and polars.\n    1) Patches arithmetic operators (e.g. `__add__`) such that operations between DataFrames/Series and `Expressionable`s\n        are not supported (i.e. `return NotImplemented`). This leads Python to try the reverse operation (e.g. `__radd__`)\n        which is supported by the `Expressionable` class.\n    2) Adds a `to_expr` method to DataFrame/Series that allows them to be converted to an `Expression` object.\n        Series become dataframes and dataframes become expressions where everything but the last column are treated as dimensions.\n    \"\"\"\n    _patch_class(pd.DataFrame)\n    _patch_class(pd.Series)\n    _patch_class(pl.DataFrame)\n    _patch_class(pl.Series)\n    pl.DataFrame.to_expr = _dataframe_to_expr\n    pl.Series.to_expr = lambda self: self.to_frame().to_expr()\n    pd.DataFrame.to_expr = lambda self: pl.from_pandas(self).to_expr()\n    pd.Series.to_expr = lambda self: self.to_frame().reset_index().to_expr()\n</code></pre>"},{"location":"reference/objective/","title":"objective","text":""},{"location":"reference/objective/#pyoframe.objective.Objective","title":"<code>Objective(expr)</code>","text":"<p>               Bases: <code>Expression</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyoframe import Variable, Model, sum\n&gt;&gt;&gt; m = Model(\"max\")\n&gt;&gt;&gt; m.a = Variable()\n&gt;&gt;&gt; m.b = Variable({\"dim1\": [1, 2, 3]})\n&gt;&gt;&gt; m.objective = m.a + sum(\"dim1\", m.b)\n&gt;&gt;&gt; m.objective\n&lt;Objective size=1 dimensions={} terms=4&gt;\nobjective: a + b[1] + b[2] + b[3]\n</code></pre> Source code in <code>pyoframe/objective.py</code> <pre><code>def __init__(self, expr: SupportsMath) -&gt; None:\n    expr = expr.to_expr()\n    super().__init__(expr.data)\n    self._model = expr._model\n    assert (\n        self.dimensions is None\n    ), \"Objective cannot have dimensions as it must be a single expression\"\n    self._value: Optional[float] = None\n</code></pre>"},{"location":"reference/solvers/","title":"solvers","text":"<p>Code to interface with various solvers</p>"},{"location":"reference/solvers/#pyoframe.solvers.GurobiSolver","title":"<code>GurobiSolver(*args, **kwargs)</code>","text":"<p>               Bases: <code>FileBasedSolver</code></p> Source code in <code>pyoframe/solvers.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    if not self.log_to_console:\n        self.params[\"LogToConsole\"] = 0\n    self.env = None\n</code></pre>"},{"location":"reference/solvers/#pyoframe.solvers.GurobiSolver.create_solver_model_from_lp","title":"<code>create_solver_model_from_lp()</code>","text":"<p>Solve a linear problem using the gurobi solver.</p> <p>This function communicates with gurobi using the gurubipy package.</p> Source code in <code>pyoframe/solvers.py</code> <pre><code>def create_solver_model_from_lp(self) -&gt; Any:\n    \"\"\"\n    Solve a linear problem using the gurobi solver.\n\n    This function communicates with gurobi using the gurubipy package.\n    \"\"\"\n    assert self.problem_file is not None\n    self.env = gurobipy.Env(params=self.params)\n\n    m = gurobipy.read(_path_to_str(self.problem_file), env=self.env)\n    if not self.keep_files:\n        self.problem_file.unlink()\n\n    return m\n</code></pre>"},{"location":"reference/solvers/#pyoframe.solvers.Solver","title":"<code>Solver(model, log_to_console, params, directory)</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>pyoframe/solvers.py</code> <pre><code>def __init__(self, model: \"Model\", log_to_console, params, directory):\n    self._model = model\n    self.solver_model: Optional[Any] = None\n    self.log_to_console: bool = log_to_console\n    self.params = params\n    self.directory = directory\n</code></pre>"},{"location":"reference/solvers/#pyoframe.solvers.Solver.dispose","title":"<code>dispose()</code>","text":"<p>Clean up any resources that wouldn't be cleaned up by the garbage collector.</p> <p>For now, this is only used by the Gurobi solver to call .dispose() on the solver model and Gurobi environment which helps close a connection to the Gurobi Computer Server. Note that this effectively disables commands that need access to the solver model (like .slack and .RC)</p> Source code in <code>pyoframe/solvers.py</code> <pre><code>def dispose(self):\n    \"\"\"\n    Clean up any resources that wouldn't be cleaned up by the garbage collector.\n\n    For now, this is only used by the Gurobi solver to call .dispose() on the solver model and Gurobi environment\n    which helps close a connection to the Gurobi Computer Server. Note that this effectively disables commands that\n    need access to the solver model (like .slack and .RC)\n    \"\"\"\n</code></pre>"},{"location":"reference/user_defined/","title":"user_defined","text":"<p>Contains the base classes to support .params and .attr containers for user-defined parameters and attributes.</p>"},{"location":"reference/user_defined/#pyoframe.user_defined.AttrContainerMixin","title":"<code>AttrContainerMixin(*args, **kwargs)</code>","text":"Source code in <code>pyoframe/user_defined.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    super().__init__(*args, **kwargs)\n    self.attr = Container(preprocess=self._preprocess_attr)\n</code></pre>"},{"location":"reference/user_defined/#pyoframe.user_defined.Container","title":"<code>Container(preprocess=None)</code>","text":"<p>A container for user-defined attributes or parameters.</p> <p>Parameters:</p> Name Type Description Default <code>preprocess</code> <p>A function to preprocess user-defined values before adding them to the container.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; params = Container()\n&gt;&gt;&gt; params.a = 1\n&gt;&gt;&gt; params.b = 2\n&gt;&gt;&gt; params.a\n1\n&gt;&gt;&gt; params.b\n2\n&gt;&gt;&gt; for k, v in params:\n...     print(k, v)\na 1\nb 2\n</code></pre> Source code in <code>pyoframe/user_defined.py</code> <pre><code>def __init__(self, preprocess: Optional[Callable[[str, Any], None]] = None):\n    self._preprocess = preprocess\n    self._attributes = {}\n</code></pre>"},{"location":"reference/util/","title":"util","text":"<p>File containing utility functions and classes.</p>"},{"location":"reference/util/#pyoframe.util.cast_coef_to_string","title":"<code>cast_coef_to_string(df, column_name=COEF_KEY, drop_ones=True, float_precision=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame.</p> required <code>column_name</code> <code>str</code> <p>The name of the column to be casted.</p> <code>COEF_KEY</code> <code>drop_ones</code> <code>bool</code> <p>If True, 1s are replaced with an empty string for non-constant terms.</p> <code>True</code> <code>float_precision</code> <code>Optional[int]</code> <p>The number of decimal places to round the coefficients to. If None, no rounding is done (so Polars' default precision is used).</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1.0, -2.0, 1.0, 4.0], VAR_KEY: [1, 2, 0, 4]})\n&gt;&gt;&gt; cast_coef_to_string(df, \"x\")\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2506 __variable_id \u2502\n\u2502 --- \u2506 ---           \u2502\n\u2502 str \u2506 i64           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 +   \u2506 1             \u2502\n\u2502 -2  \u2506 2             \u2502\n\u2502 +1  \u2506 0             \u2502\n\u2502 +4  \u2506 4             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def cast_coef_to_string(\n    df: pl.DataFrame,\n    column_name: str = COEF_KEY,\n    drop_ones: bool = True,\n    float_precision: Optional[int] = None,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Parameters:\n        df:\n            The input DataFrame.\n        column_name:\n            The name of the column to be casted.\n        drop_ones:\n            If True, 1s are replaced with an empty string for non-constant terms.\n        float_precision:\n            The number of decimal places to round the coefficients to. If None, no rounding is done (so Polars' default precision is used).\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1.0, -2.0, 1.0, 4.0], VAR_KEY: [1, 2, 0, 4]})\n        &gt;&gt;&gt; cast_coef_to_string(df, \"x\")\n        shape: (4, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x   \u2506 __variable_id \u2502\n        \u2502 --- \u2506 ---           \u2502\n        \u2502 str \u2506 i64           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 +   \u2506 1             \u2502\n        \u2502 -2  \u2506 2             \u2502\n        \u2502 +1  \u2506 0             \u2502\n        \u2502 +4  \u2506 4             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df = df.with_columns(\n        pl.col(column_name).abs(),\n        _sign=pl.when(pl.col(column_name) &lt; 0).then(pl.lit(\"-\")).otherwise(pl.lit(\"+\")),\n    )\n\n    if float_precision is not None:\n        df = df.with_columns(pl.col(column_name).round(float_precision))\n\n    df = df.with_columns(\n        pl.when(pl.col(column_name) == pl.col(column_name).floor())\n        .then(pl.col(column_name).cast(pl.Int64).cast(pl.String))\n        .otherwise(pl.col(column_name).cast(pl.String))\n        .alias(column_name)\n    )\n\n    if drop_ones:\n        condition = pl.col(column_name) == str(1)\n        if VAR_KEY in df.columns:\n            condition = condition &amp; (pl.col(VAR_KEY) != CONST_TERM)\n        df = df.with_columns(\n            pl.when(condition)\n            .then(pl.lit(\"\"))\n            .otherwise(pl.col(column_name))\n            .alias(column_name)\n        )\n    else:\n        df = df.with_columns(pl.col(column_name).cast(pl.Utf8))\n    return df.with_columns(pl.concat_str(\"_sign\", column_name).alias(column_name)).drop(\n        \"_sign\"\n    )\n</code></pre>"},{"location":"reference/util/#pyoframe.util.concat_dimensions","title":"<code>concat_dimensions(df, prefix=None, keep_dims=True, ignore_columns=RESERVED_COL_KEYS, replace_spaces=True, to_col='concated_dim')</code>","text":"<p>Returns a new DataFrame with the column 'concated_dim'. Reserved columns are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame.</p> required <code>prefix</code> <code>Optional[str]</code> <p>The prefix to be added to the concated dimension.</p> <code>None</code> <code>keep_dims</code> <code>bool</code> <p>If True, the original dimensions are kept in the new DataFrame.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"dim1\": [1, 2, 3, 1, 2, 3],\n...         \"dim2\": [\"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\"],\n...     }\n... )\n&gt;&gt;&gt; concat_dimensions(df)\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 str  \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 Y    \u2506 [1,Y]        \u2502\n\u2502 2    \u2506 Y    \u2506 [2,Y]        \u2502\n\u2502 3    \u2506 Y    \u2506 [3,Y]        \u2502\n\u2502 1    \u2506 N    \u2506 [1,N]        \u2502\n\u2502 2    \u2506 N    \u2506 [2,N]        \u2502\n\u2502 3    \u2506 N    \u2506 [3,N]        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 str  \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 Y    \u2506 x[1,Y]       \u2502\n\u2502 2    \u2506 Y    \u2506 x[2,Y]       \u2502\n\u2502 3    \u2506 Y    \u2506 x[3,Y]       \u2502\n\u2502 1    \u2506 N    \u2506 x[1,N]       \u2502\n\u2502 2    \u2506 N    \u2506 x[2,N]       \u2502\n\u2502 3    \u2506 N    \u2506 x[3,N]       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; concat_dimensions(df, keep_dims=False)\nshape: (6, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 concated_dim \u2502\n\u2502 ---          \u2502\n\u2502 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1,Y]        \u2502\n\u2502 [2,Y]        \u2502\n\u2502 [3,Y]        \u2502\n\u2502 [1,N]        \u2502\n\u2502 [2,N]        \u2502\n\u2502 [3,N]        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; # Properly handles cases with no dimensions and ignores reserved columns\n&gt;&gt;&gt; df = pl.DataFrame({VAR_KEY: [1, 2]})\n&gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 __variable_id \u2506 concated_dim \u2502\n\u2502 ---           \u2506 ---          \u2502\n\u2502 i64           \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1             \u2506 x            \u2502\n\u2502 2             \u2506 x            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def concat_dimensions(\n    df: pl.DataFrame,\n    prefix: Optional[str] = None,\n    keep_dims: bool = True,\n    ignore_columns: Sequence[str] = RESERVED_COL_KEYS,\n    replace_spaces: bool = True,\n    to_col: str = \"concated_dim\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Returns a new DataFrame with the column 'concated_dim'. Reserved columns are ignored.\n\n    Parameters:\n        df:\n            The input DataFrame.\n        prefix:\n            The prefix to be added to the concated dimension.\n        keep_dims:\n            If True, the original dimensions are kept in the new DataFrame.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; df = pl.DataFrame(\n        ...     {\n        ...         \"dim1\": [1, 2, 3, 1, 2, 3],\n        ...         \"dim2\": [\"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\"],\n        ...     }\n        ... )\n        &gt;&gt;&gt; concat_dimensions(df)\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n        \u2502 ---  \u2506 ---  \u2506 ---          \u2502\n        \u2502 i64  \u2506 str  \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 Y    \u2506 [1,Y]        \u2502\n        \u2502 2    \u2506 Y    \u2506 [2,Y]        \u2502\n        \u2502 3    \u2506 Y    \u2506 [3,Y]        \u2502\n        \u2502 1    \u2506 N    \u2506 [1,N]        \u2502\n        \u2502 2    \u2506 N    \u2506 [2,N]        \u2502\n        \u2502 3    \u2506 N    \u2506 [3,N]        \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n        \u2502 ---  \u2506 ---  \u2506 ---          \u2502\n        \u2502 i64  \u2506 str  \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 Y    \u2506 x[1,Y]       \u2502\n        \u2502 2    \u2506 Y    \u2506 x[2,Y]       \u2502\n        \u2502 3    \u2506 Y    \u2506 x[3,Y]       \u2502\n        \u2502 1    \u2506 N    \u2506 x[1,N]       \u2502\n        \u2502 2    \u2506 N    \u2506 x[2,N]       \u2502\n        \u2502 3    \u2506 N    \u2506 x[3,N]       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; concat_dimensions(df, keep_dims=False)\n        shape: (6, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 concated_dim \u2502\n        \u2502 ---          \u2502\n        \u2502 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 [1,Y]        \u2502\n        \u2502 [2,Y]        \u2502\n        \u2502 [3,Y]        \u2502\n        \u2502 [1,N]        \u2502\n        \u2502 [2,N]        \u2502\n        \u2502 [3,N]        \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; # Properly handles cases with no dimensions and ignores reserved columns\n        &gt;&gt;&gt; df = pl.DataFrame({VAR_KEY: [1, 2]})\n        &gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 __variable_id \u2506 concated_dim \u2502\n        \u2502 ---           \u2506 ---          \u2502\n        \u2502 i64           \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1             \u2506 x            \u2502\n        \u2502 2             \u2506 x            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if prefix is None:\n        prefix = \"\"\n    dimensions = [col for col in df.columns if col not in ignore_columns]\n    if dimensions:\n        query = pl.concat_str(\n            pl.lit(prefix + \"[\"),\n            pl.concat_str(*dimensions, separator=\",\"),\n            pl.lit(\"]\"),\n        )\n    else:\n        query = pl.lit(prefix)\n\n    df = df.with_columns(query.alias(to_col))\n\n    if replace_spaces:\n        df = df.with_columns(pl.col(to_col).str.replace_all(\" \", \"_\"))\n\n    if not keep_dims:\n        df = df.drop(*dimensions)\n\n    return df\n</code></pre>"},{"location":"reference/util/#pyoframe.util.dataframe_to_tupled_list","title":"<code>dataframe_to_tupled_list(df, num_max_elements=None)</code>","text":"<p>Converts a dataframe into a list of tuples. Used to print a Set to the console. See examples for behaviour.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; dataframe_to_tupled_list(df)\n'[1, 2, 3, 4, 5]'\n&gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n'[1, 2, 3, ...]'\n</code></pre> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5], \"y\": [2, 3, 4, 5, 6]})\n&gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n'[(1, 2), (2, 3), (3, 4), ...]'\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def dataframe_to_tupled_list(\n    df: pl.DataFrame, num_max_elements: Optional[int] = None\n) -&gt; str:\n    \"\"\"\n    Converts a dataframe into a list of tuples. Used to print a Set to the console. See examples for behaviour.\n\n    Examples:\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\n        &gt;&gt;&gt; dataframe_to_tupled_list(df)\n        '[1, 2, 3, 4, 5]'\n        &gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n        '[1, 2, 3, ...]'\n\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5], \"y\": [2, 3, 4, 5, 6]})\n        &gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n        '[(1, 2), (2, 3), (3, 4), ...]'\n    \"\"\"\n    elipse = False\n    if num_max_elements is not None:\n        if len(df) &gt; num_max_elements:\n            elipse = True\n            df = df.head(num_max_elements)\n\n    res = (row for row in df.iter_rows())\n    if len(df.columns) == 1:\n        res = (row[0] for row in res)\n\n    res = str(list(res))\n    if elipse:\n        res = res[:-1] + \", ...]\"\n    return res\n</code></pre>"},{"location":"reference/util/#pyoframe.util.get_obj_repr","title":"<code>get_obj_repr(obj, _props=(), **kwargs)</code>","text":"<p>Helper function to generate repr strings for classes. See usage for examples.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def get_obj_repr(obj: object, _props: Iterable[str] = (), **kwargs):\n    \"\"\"\n    Helper function to generate __repr__ strings for classes. See usage for examples.\n    \"\"\"\n    props = {prop: getattr(obj, prop) for prop in _props}\n    props_str = \" \".join(f\"{k}={v}\" for k, v in props.items() if v is not None)\n    if props_str:\n        props_str += \" \"\n    kwargs_str = \" \".join(f\"{k}={v}\" for k, v in kwargs.items() if v is not None)\n    return f\"&lt;{obj.__class__.__name__} {props_str}{kwargs_str}&gt;\"\n</code></pre>"},{"location":"reference/util/#pyoframe.util.parse_inputs_as_iterable","title":"<code>parse_inputs_as_iterable(*inputs)</code>","text":"<p>Converts a parameter *x: Any | Iteraable[Any] to a single Iterable[Any] object. This is helpful to support these two ways of passing arguments:     - foo([1, 2, 3])     - foo(1, 2, 3)</p> <p>Inspired from the polars library.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def parse_inputs_as_iterable(\n    *inputs: Union[Any, Iterable[Any]],\n) -&gt; Iterable[Any]:\n    \"\"\"\n    Converts a parameter *x: Any | Iteraable[Any] to a single Iterable[Any] object.\n    This is helpful to support these two ways of passing arguments:\n        - foo([1, 2, 3])\n        - foo(1, 2, 3)\n\n    Inspired from the polars library.\n    \"\"\"\n    if not inputs:\n        return []\n\n    # Treat elements of a single iterable as separate inputs\n    if len(inputs) == 1 and _is_iterable(inputs[0]):\n        return inputs[0]\n\n    return inputs\n</code></pre>"},{"location":"reference/util/#pyoframe.util.unwrap_single_values","title":"<code>unwrap_single_values(func)</code>","text":"<p>Decorator for functions that return DataFrames. Returned dataframes with a single value will instead return the value.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def unwrap_single_values(func):\n    \"\"\"Decorator for functions that return DataFrames. Returned dataframes with a single value will instead return the value.\"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        if isinstance(result, pl.DataFrame) and result.shape == (1, 1):\n            return result.item()\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"why-pyoframe/","title":"Why Pyoframe?","text":"<p>Pyoframe is better than alternatives libraries due to speed,  memory and readability. See for yourself:</p> <p></p>"},{"location":"why-pyoframe/#why-not-pyoframe","title":"Why not Pyoframe?","text":"<p>Our library still has some limitations:</p> <ul> <li>No support for quadratic objectives (for now, help us out!)</li> <li>Only supports Gurobi (for now, help us out!)</li> </ul>"},{"location":"why-pyoframe/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Why Pyoframe?</li> <li>Speed benchmarks</li> <li>Memory benchmarks</li> <li>Pyoframe syntax's</li> <li>Why not Pyoframe?</li> </ul>"},{"location":"why-pyoframe/why-pyoframe/","title":"Why PyoFrame?","text":""}]}