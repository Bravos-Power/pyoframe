{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyoframe: A loved alternative to GAMS, Pyomo, and Linopy","text":"<ul> <li>Builds linear, non-linear, quadratic, continuous and mixed-integer optimization problems.</li> <li>Seamlessly integrates with pandas thanks to its dataframe-centric design.</li> <li>Extremely fast and memory efficient (even for sparse problems) thanks to Polars, Rust, and Pyoptinterface.</li> <li>Clear Pythonic syntax for writing mathematical models.</li> <li>Supports Gurobi, HiGHS, and Ipopt solvers.</li> <li>Continuously used in high-stakes production environments.</li> <li>100% open-source (MIT License).</li> </ul> <ul> <li> <p> Learn</p> <p>Install <code>pyoframe</code> and learn the library's basics.</p> <p> Get started</p> </li> <li> <p> Examples</p> <p>Jump right in with our annotated examples.</p> <p> Examples</p> </li> </ul> <ul> <li> <p> API Reference</p> <p>Your go-to reference for understanding our API.</p> <p> Reference</p> </li> </ul>"},{"location":"contribute/","title":"Contribute","text":"<p>Contributions are more than welcome! Submit a pull request, or open an issue and I (Martin) will gladly answer your questions on how to contribute.</p>"},{"location":"contribute/#setup-a-development-environment","title":"Setup a development environment","text":"<ol> <li> <p>Clone this repository. <code>git clone https://github.com/Bravos-Power/pyoframe</code></p> </li> <li> <p>Install the dependencies. <code>pip install --editable .[dev,docs]</code></p> </li> <li> <p>Install the pre-commit hooks. <code>pre-commit install</code></p> </li> <li> <p>Run <code>pytest</code> to make sure everything is working. If not, open an issue!</p> </li> </ol>"},{"location":"contribute/#documentation","title":"Documentation","text":"<p>We use Material Docs for documentation with several plugins to enable features like automatically compiling the docstrings into the reference API. Please follow the Google style for docstrings. Additionally, all Python code blocks in Markdown files are tested using Sybil. To properly setup the tests refer to this Sybil documentation.</p>"},{"location":"contribute/#helpful-commands","title":"Helpful commands","text":"<ul> <li><code>pytest</code>: Runs all the tests. If you'd like to generate coverage information just add the flag <code>--cov</code>.</li> <li><code>mkdocs serve</code>: Generates the documentation locally. Navigate to <code>http://127.0.0.1:8000/pyoframe/</code> to check it out.</li> <li><code>coverage html</code>: Generate a webpage to view the coverage information generated after having run <code>pytest --cov</code>.</li> <li><code>python -m tests/test_examples.py</code>: Regenerate the files in the <code>results</code> folder of an example (e.g. <code>tests/examples/sudoku/results/**</code>). You should only run this if the result files need to be regenerated, for example, if model variable names have changed.</li> <li><code>ruff check</code>: Ensures all the linter tests pass</li> <li><code>ruff format</code>: Ensures the code is properly formatted (this is run upon commit if you've installed the pre-commit hooks)</li> <li><code>doccmd --language=python --no-pad-file --command=\"ruff format\" docs/</code>: to format the code in the documentation.</li> </ul>"},{"location":"contribute/#details-for-repository-maintainers","title":"Details for repository maintainers","text":""},{"location":"contribute/#expired-gurobi-license","title":"Expired Gurobi License","text":"<p>We use a Gurobi license to run our tests. If the tests fail an give a license expired error, generate a new one and copy the contents of the <code>guorbi.lic</code> file into the <code>GUROBI_WLS</code> Github secret (Settings -&gt; Secrets and variables -&gt; actions).</p>"},{"location":"examples/","title":"List of Examples","text":"Example Description Problem type Diet problem The canonical linear problem. Sweet and simple! (Or is it salty and simple?) LP Production planning Which products should the manufacturer make? LP"},{"location":"examples/diet/","title":"Diet Problem","text":"<p>Given a dataset of food options, each with different nutritional contents, how do you satisfy your dietary requirements while minimizing cost?</p>"},{"location":"examples/diet/#input-data","title":"Input Data","text":"<ul> <li>foods.csv</li> <li>foods_to_nutrients.csv</li> <li>nutrients.csv</li> </ul>"},{"location":"examples/diet/#model","title":"Model","text":"<pre><code>import polars as pl\n\nfrom pyoframe import Model, Variable, sum, sum_by\n\n\ndef solve_model():\n    # Import data\n    food = pl.read_csv(\"foods.csv\")\n    nutrients = pl.read_csv(\"nutrients.csv\")\n    min_nutrient = nutrients.select([\"category\", \"min\"]).to_expr()\n    max_nutrient = nutrients.select([\"category\", \"max\"]).to_expr()\n    food_nutrients = pl.read_csv(\"foods_to_nutrients.csv\").to_expr()\n\n    # Construct model\n    m = Model()\n    m.Buy = Variable(food[[\"food\"]], lb=0, ub=food[[\"food\", \"stock\"]])\n\n    nutrient_intake = sum_by(\"category\", m.Buy * food_nutrients)\n    m.min_nutrients = min_nutrient &lt;= nutrient_intake.drop_unmatched()  # (1)!\n    m.max_nutrients = nutrient_intake.drop_unmatched() &lt;= max_nutrient\n\n    m.minimize = sum(m.Buy * food[[\"food\", \"cost\"]])\n\n    m.optimize()\n\n    return m\n\n\nm = solve_model()\n</code></pre> <ol> <li><code>.drop_unmatched()</code> ensures that if <code>min_nutrient</code> is <code>null</code> for certain foods, no constraint will be created for those foods. Learn more</li> </ol> <p>So what should you eat...</p> <pre><code>&gt;&gt;&gt; m.Buy.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food      \u2506 solution \u2502\n\u2502 ---       \u2506 ---      \u2502\n\u2502 str       \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 hamburger \u2506 0.555263 \u2502\n\u2502 chicken   \u2506 0.0      \u2502\n\u2502 hot_dog   \u2506 0.0      \u2502\n\u2502 fries     \u2506 0.0      \u2502\n\u2502 macaroni  \u2506 0.0      \u2502\n\u2502 pizza     \u2506 0.0      \u2502\n\u2502 salad     \u2506 0.0      \u2502\n\u2502 milk      \u2506 6.8      \u2502\n\u2502 ice_cream \u2506 2.909211 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Not a very balanced diet .</p>"},{"location":"examples/production/","title":"Production planning","text":"<p>This classical problem seeks to determine which products should be manufactured (and in what quantities) given that a) each product must go through a sequence of machines, b) every machine takes a different amount of time to process every product, and c) machines have a maximal lifetime before needing maintenance. (See Eiselt and Sandblom, p. 20, for details.)</p>"},{"location":"examples/production/#input-data","title":"Input Data","text":"<ul> <li>machines_availability.csv</li> <li>processing_times.csv</li> <li>products_profit.csv</li> </ul>"},{"location":"examples/production/#model","title":"Model","text":"<pre><code>import polars as pl\n\nimport pyoframe as pf\n\n\ndef solve_model():\n    processing_times = pl.read_csv(\"processing_times.csv\")\n    machines_availability = pl.read_csv(\"machines_availability.csv\")\n    products_profit = pl.read_csv(\"products_profit.csv\")\n\n    m = pf.Model()\n    m.Production = pf.Variable(products_profit[[\"products\"]], lb=0)\n\n    machine_usage = m.Production * processing_times\n    m.machine_capacity = pf.sum_by(\"machines\", machine_usage) &lt;= machines_availability\n\n    m.maximize = pf.sum(products_profit * m.Production)\n\n    m.optimize()\n\n    return m\n\n\nm = solve_model()\n</code></pre> <pre><code>&gt;&gt;&gt; m.Production.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 products \u2506 solution \u2502\n\u2502 ---      \u2506 ---      \u2502\n\u2502 i64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1        \u2506 20.0     \u2502\n\u2502 2        \u2506 0.0      \u2502\n\u2502 3        \u2506 120.0    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"learn/advanced-concepts/datastructure/","title":"The Pyoframe datastructure","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>So how does Pyoframe really work? Pyoframe uses dataframe operations to build your model's linear expressions. Here's what's happening under the hood.</p>"},{"location":"learn/advanced-concepts/internals/","title":"Internal details","text":"<p>Pyoframe's inner workings involve a few tricks that one should be aware of if they wish to modify Pyoframe's internal code.</p>"},{"location":"learn/advanced-concepts/internals/#the-zero-variable","title":"The zero variable","text":"<p>Whenever a Model is instantiated, Pyoframe immediately creates a variable whose value is fixed to <code>1</code> and has a variable id of <code>0</code> \u2014 the Zero Variable. This allows Pyoframe to represent constant terms in mathematical expressions as  multiples of the Zero Variable. For example, the expression <code>3 * var_8 + 5</code> is represented as <code>3 * var_8 + 5 * var_0</code>. This eliminates the need to separately track constant terms and also simplifies the handling of quadratics.</p>"},{"location":"learn/advanced-concepts/internals/#quadratics","title":"Quadratics","text":"<p>Internally, Expression is used to represent both linear and quadratic mathematical expressions. When a quadratic expression is formed, column <code>__quadratic_variable_id</code> is added to Expression.data. If an expression's quadratic terms happen to cancel out (e.g. <code>(ab + c) - ab</code>), this column is automatically removed.</p> <p>Column <code>__quadratic_variable_id</code> records the ID of the second variable in a quadratic term (the <code>b</code> in <code>3ab</code>). For linear terms, which have no second variable, this column contains the Zero Variable. Quadratic terms are always stored such that the first term's variable ID (in column <code>__variable_id</code>) is greater or equal to the second term's variable id (in column <code>__quadratic_variable_id</code>). For example, <code>var_7 * var_8</code> would be rearranged and stored as <code>var_8 * var_7</code>. This helps simplify expressions and provides a useful guarantee: If the variable in the first column (<code>__variable_id</code>) is the Zero Variable (<code>var_0</code>) we know the variable in the second column must also be the Zero Variable and, thus, the term must be a constant.</p>"},{"location":"learn/advanced-concepts/performance/","title":"Performance","text":"<p>Pyoframe is already one of the fastest and lowest-memory-footprint libraries to build optimization models since we leverage <code>Polars</code> internally. Here are some additional tips to squeeze out every bit of performance:</p> <ol> <li> <p>Use polars not pandas. Internally, pyoframe uses polars for everything. If you're using Pandas we'll just convert your dataframes to Polars. So might as well use polars from the very beginning! You'll save time during your pre-processing and data loading.</p> </li> <li> <p>Use integers not strings for indexing. Pyoframe works fine with dataframes that contain string columns but you should know that strings take up a lot more space than just numbering your values. When possible, use integer indices.</p> </li> <li> <p>Tweak the <code>pf.Config</code> settings. Take a look at our API Reference and you might find some settings to adjust to squeeze out the last bit of performance.</p> </li> </ol>"},{"location":"learn/advanced-concepts/performance/#expression-or-variable","title":"<code>Expression</code> or <code>Variable</code> ?","text":"<p>One common question when building large models is, if you have a very long linear expression, should you assign it to a variable or simply use the expression directly? In some cases, it is best to assign it to a variable since Pyoframe will then only need to pass around the variable rather than all the terms in the linear expression. If you're concerned that you'll be adding more variables to your model, know that most solvers will rapidly and easily get rid of these variables during the presolve stage without any noticeable performance cost.</p>"},{"location":"learn/advanced-concepts/quadratics/","title":"Quadratic expressions","text":"<p>Quadratic expressions work as you'd expect. Simply multiply two linear expression together (or square an expression with <code>**2</code>) and you'll get a quadratic. The quadratic can then be used in constraints or the objective.</p>"},{"location":"learn/advanced-concepts/quadratics/#example","title":"Example","text":""},{"location":"learn/advanced-concepts/quadratics/#maximize-area-of-box","title":"Maximize area of box","text":"<p>Here's a short example that shows that a square maximizes the area of any box with a fixed perimeter.</p> <pre><code>import pyoframe as pf\n\nmodel = pf.Model(sense=\"max\")\nmodel.w = pf.Variable(lb=0)\nmodel.h = pf.Variable(lb=0)\nmodel.limit_perimter = 2 * (model.w + model.h) &lt;= 20\nmodel.objective = model.w * model.h\nmodel.optimize()\nprint(f\"It's a square: {model.w.solution == model.h.solution}\")\nprint(f\"With area: {model.objective.evaluate()}\")\n\n# Outputs:\n# It's a square: True\n# With area: 25.0\n</code></pre>"},{"location":"learn/advanced-concepts/quadratics/#facility-location-problem","title":"Facility Location Problem","text":"<p>See examples/facility_location.</p>"},{"location":"learn/advanced-concepts/troubleshooting/","title":"Troubleshooting","text":"<p>Here are some potential errors and how to resolve them.</p>"},{"location":"learn/advanced-concepts/troubleshooting/#datatypes-of-join-keys-dont-match","title":"<code>datatypes of join keys don't match</code>","text":"<p>Often, this error indicates that two columns in your input dataframes, although representing the same dimension, have different datatypes (e.g. 16bit integer and 64bit integer). This is not allowed and you should ensure that for the same dimensions, datatypes are identical.</p>"},{"location":"learn/getting-started/building-blocks/","title":"Model components","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>In any linear program there are three key components Variables, Constraints, and an Objective. We walk you through these as well as two more: Expressions and Sets</p>"},{"location":"learn/getting-started/building-blocks/#variable","title":"<code>Variable</code>","text":""},{"location":"learn/getting-started/building-blocks/#constraint","title":"<code>Constraint</code>","text":""},{"location":"learn/getting-started/building-blocks/#objective","title":"<code>Objective</code>","text":""},{"location":"learn/getting-started/building-blocks/#expression","title":"<code>Expression</code>","text":""},{"location":"learn/getting-started/building-blocks/#set","title":"<code>Set</code>","text":""},{"location":"learn/getting-started/installation/","title":"Installation","text":""},{"location":"learn/getting-started/installation/#step-1-install-pyoframe","title":"Step 1: Install Pyoframe","text":"<p>Install using your preferred package manager:</p> pipuv <pre><code>pip install pyoframe\n</code></pre> <pre><code>uv add pyoframe\n</code></pre>"},{"location":"learn/getting-started/installation/#step-2-install-a-solver","title":"Step 2: Install a solver","text":"<p>Pyoframe makes it easy to build models but the actual solving of your model is done by a separate solver.  You'll need to install one of the following:</p> HiGHS (open-source)Gurobi (commercial)Ipopt (open-source, nonlinear)Other solvers <p>To install HiGHS run:</p> <pre><code>pip install pyoframe[highs]\n</code></pre> <p>Quadratics are unsupported in HiGHS</p> <p>Pyoframe does not support quadratic constraints when using HiGHS due to limitations in pyoptinterface, the library we use to communicate with HiGHS.</p> <p>To install Gurobi:</p> <ol> <li>Download Gurobi from their website (login required) and follow the installation instructions.</li> <li>Ensure you have a valid Gurobi license installed on your machine.</li> </ol> <p>pip installation not possible</p> <p>Installing Gurobi via <code>pip</code> will not work. We use Gurobi's C API which is not available in the Python version of Gurobi.</p> <p>To install ipopt:</p> <ol> <li>Run: <code>pip install pyoframe[ipopt]</code></li> <li>Download the Ipopt binaries from GitHub. Version 3.14.x is recommended since it is the latest version that we've tested.</li> <li>On Windows, unpack the zip and add the <code>bin</code> folder to your Path variable. If not on Windows, you may have to build the solver from source, see further details here.</li> </ol> <p>Continuous variables only</p> <p>Ipopt is a nonlinear solver for continuous variables only. Use another solver if you need to use binary or integer variables. </p> <p>We would gladly consider supporting other solvers. Create a new issue or up-vote an existing one to show interest:</p> <ul> <li>Issue tracking interest in COPT solver</li> <li>Issue tracking interest in Mosek solver</li> </ul>"},{"location":"learn/getting-started/solver-access/","title":"Accessing the solver","text":""},{"location":"learn/getting-started/solver-access/#model-attributes","title":"Model attributes","text":"<p>Pyoframe lets you read and set solver attributes using <code>model.attr.&lt;your-attribute&gt;</code>. For example, if you'd like to prevent the solver from printing to the console you can do:</p> <pre><code>m = pf.Model()\nm.attr.Silent = True\n</code></pre> <p>Pyoframe support all PyOptInterface attributes and, when using Gurobi, all Gurobi attributes.</p> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus  # PyOptInterface attribute (always available)\n&lt;TerminationStatusCode.OPTIMAL: 2&gt;\n&gt;&gt;&gt; m.attr.Status  # Gurobi attribute (only available with Gurobi)\n2\n</code></pre>"},{"location":"learn/getting-started/solver-access/#model-parameters-gurobi-only","title":"Model parameters (Gurobi only)","text":"<p>Gurobi supports model attributes (see above) and model parameters (full list here). You can read or set model parameters with <code>model.params.&lt;your-parameter&gt;</code>. For example:</p> <pre><code>m.params.method = 2  # Use a barrier method to solve\n</code></pre>"},{"location":"learn/getting-started/solver-access/#variable-and-constraint-attributes","title":"Variable and constraint attributes","text":"<p>Similar to above, Pyoframe allows directly accessing the PyOptInterface or the solver's variable and constraint attributes.</p> <pre><code>m = pf.Model()\nm.X = pf.Variable()\nm.X.attr.PrimalStart = 5\n</code></pre> <p>If the variable or constraint is dimensioned, the attribute can accept/return a dataframe instead of a constant.</p>"},{"location":"learn/getting-started/special-functions/","title":"Special functions","text":"<p>Work in progress</p> <p>This documentation could use some help. Learn how you can contribute.</p> <p>Pyoframe has a few special functions that make working with dataframes easy and intuitive. Here they are:</p>"},{"location":"learn/getting-started/special-functions/#pfsumexpression","title":"<code>pf.sum(Expression)</code>","text":""},{"location":"learn/getting-started/special-functions/#expressionmap","title":"<code>Expression.map()</code>","text":""},{"location":"learn/getting-started/special-functions/#expressionadd_dim","title":"<code>Expression.add_dim()</code>","text":""},{"location":"learn/getting-started/special-functions/#expressiondrop_unmatched","title":"<code>Expression.drop_unmatched()</code>","text":""},{"location":"learn/getting-started/special-functions/#expressionkeep_unmatched","title":"<code>Expression.keep_unmatched()</code>","text":""},{"location":"learn/getting-started/basic-example/example-with-dimensions/","title":"Basic example with dataframes","text":"<p>The previous example would quickly become unworkable if we had more than just tofu and chickpeas. I'll walk you through how we can make a <code>food</code> dimension to make this scalable. You can also skip to the end to see the complete example.</p> <p>Note that instead of hardcoding values, we'll be reading from the following csv file.</p> <p><code>food_data.csv</code></p> food protein cost tofu_block 18 4 chickpea_can 15 3"},{"location":"learn/getting-started/basic-example/example-with-dimensions/#load-your-data","title":"Load your data","text":"<p>Nothing special here. Load your data using your favourite dataframe library. We like Polars because it's fast but Pandas works too.</p> PolarsPandas <pre><code>import polars as pl\n\ndata = pl.read_csv(\"food_data.csv\")\n</code></pre> <pre><code>import pandas as pd\n\ndata = pd.read_csv(\"food_data.csv\")\n</code></pre>"},{"location":"learn/getting-started/basic-example/example-with-dimensions/#create-the-model","title":"Create the model","text":"<pre><code>import pyoframe as pf\n\nm = pf.Model()\n</code></pre>"},{"location":"learn/getting-started/basic-example/example-with-dimensions/#create-an-dimensioned-variable","title":"Create an dimensioned variable","text":"<p>Previously, we created two variables: <code>m.tofu_blocks</code> and <code>m.chickpea_cans</code>. Instead, we now create a single variable dimensioned over <code>food</code>.</p> <pre><code>m.Buy = pf.Variable(data[[\"food\"]], lb=0, vtype=\"integer\")\n</code></pre> <p>Printing the variable shows that it contains a <code>food</code> dimension with indices <code>tofu</code> and <code>chickpeas</code>!</p> <pre><code>&gt;&gt;&gt; m.Buy\n&lt;Variable name=Buy lb=0 size=2 dimensions={'food': 2}&gt;\n[tofu_block]: Buy[tofu_block]\n[chickpea_can]: Buy[chickpea_can]\n</code></pre> <p>Variable naming</p> <p>We suggest capitalizing model variables (i.e. <code>m.Buy</code> not <code>m.buy</code>) to make it easy to distinguish what is and isn't a variable.</p>"},{"location":"learn/getting-started/basic-example/example-with-dimensions/#create-the-objective","title":"Create the objective","text":"<p>Previously we had:</p> <pre><code>m.minimize = 4 * m.tofu_blocks + 3 * m.chickpea_cans\n</code></pre> <p>How do we make use of our dimensioned variable <code>m.Buy</code> instead?</p> <p>First, we multiply the variable by the protein amount.</p> <pre><code>&gt;&gt;&gt; data[[\"food\", \"cost\"]] * m.Buy\n&lt;Expression size=2 dimensions={'food': 2} terms=2&gt;\n[tofu_block]: 4 Buy[tofu_block]\n[chickpea_can]: 3 Buy[chickpea_can]\n</code></pre> <p>As you can see, Pyoframe with a bit of magic converted our <code>Variable</code> into an <code>Expression</code> where the coefficients are the protein amounts.</p> <p>Second, notice that our <code>Expression</code> still has a <code>food</code> dimension\u2014it really contains two separate expressions, one for tofu and one for chickpeas. All objective functions must be a single expression (without dimensions) so let's sum over the <code>food</code> dimensions using <code>pf.sum()</code>.</p> <pre><code>&gt;&gt;&gt; pf.sum(\"food\", data[[\"food\", \"cost\"]] * m.Buy)\n&lt;Expression size=1 dimensions={} terms=2&gt;\n4 Buy[tofu_block] +3 Buy[chickpea_can]\n</code></pre> <p>This works and since <code>food</code> is the only dimensions we don't even need to specify it. Putting it all together:</p> <pre><code>m.minimize = pf.sum(data[[\"food\", \"cost\"]] * m.Buy)\n</code></pre>"},{"location":"learn/getting-started/basic-example/example-with-dimensions/#adding-the-constraint","title":"Adding the constraint","text":"<p>This is similar to how we created the objective, except now we're using <code>protein</code> and we turn our <code>Expression</code> into a <code>Constraint</code> by with the <code>&gt;=</code> operation.</p> <pre><code>m.protein_constraint = pf.sum(data[[\"food\", \"protein\"]] * m.Buy) &gt;= 50\n</code></pre>"},{"location":"learn/getting-started/basic-example/example-with-dimensions/#putting-it-all-together","title":"Putting it all together","text":"<pre><code>import pandas as pd\nimport pyoframe as pf\n\ndata = pd.read_csv(\"food_data.csv\")\n\nm = pf.Model()\nm.Buy = pf.Variable(data[[\"food\"]], lb=0, vtype=\"integer\")\nm.minimize = pf.sum(data[[\"food\", \"cost\"]] * m.Buy)\nm.protein_constraint = pf.sum(data[[\"food\", \"protein\"]] * m.Buy) &gt;= 50\n\nm.optimize()\n</code></pre> <p>So you should buy:</p> <pre><code>&gt;&gt;&gt; m.Buy.solution\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 food         \u2506 solution \u2502\n\u2502 ---          \u2506 ---      \u2502\n\u2502 str          \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 tofu_block   \u2506 2        \u2502\n\u2502 chickpea_can \u2506 1        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Notice that since <code>m.Buy</code> is dimensioned, <code>m.Buy.solution</code> returned a dataframe with the solution for each of indices.</p> <p>Returning Pandas dataframes</p> <p>Pyoframe currently always returns Polars dataframes but you can easily convert them to Pandas using <code>.to_pandas()</code>. In the future, we plan to add support for automatically returning Pandas dataframes. Upvote the issue if you'd like this feature.</p>"},{"location":"learn/getting-started/basic-example/example/","title":"Basic example","text":"<p>Let's solve the following problem using Pyoframe!</p> <p>Imagine you're a vegetarian hesitating between tofu and chickpeas as a source of protein for tomorrow's dinner. You'd like to spend as little as possible while still consuming at least 50 grams of protein. How many blocks of tofu ($4, 18g of protein) and cans of chickpeas ($3, 15g of protein) should you buy?</p> <p>Click on the  buttons below to understand the Pyoframe solution.</p> <pre><code>import pyoframe as pf\n\nm = pf.Model()\n\n# You can buy tofu or chickpeas\nm.tofu_blocks = pf.Variable(lb=0, vtype=\"integer\")  # (1)!\nm.chickpea_cans = pf.Variable(lb=0, vtype=\"integer\")\n\n# You want to minimize your cost (4$ per tofu block, $2 per chickpea can)\nm.minimize = 4 * m.tofu_blocks + 3 * m.chickpea_cans  # (2)!\n\n# But still consume 10 grams of protein (tofu = 8g, chickpea cans = 6g)\nm.protein_constraint = 18 * m.tofu_blocks + 15 * m.chickpea_cans &gt;= 50  # (3)!\n\nm.optimize()  # (4)!\n</code></pre> <ol> <li>Notice how we set a lower bound (<code>lb=0</code>) so that you can't buy negative amounts. We also specify </li> <li><code>.minimize</code> and <code>.maximize</code> are reserved variables that let you define your objective function.</li> <li>Constraints are easily created with <code>&lt;=</code>, <code>&gt;=</code>, or <code>==</code>.</li> <li>Pyoframe automatically detects your installed solver!</li> </ol> <p>So how much should you buy...</p> <pre><code>&gt;&gt;&gt; m.tofu_blocks.solution\n2\n&gt;&gt;&gt; m.chickpea_cans.solution\n1\n</code></pre>"},{"location":"reference/internal/constants/","title":"constants","text":"<p>File containing shared constants used across the package.</p> <p>Classes:</p> Name Description <code>Config</code> <p>Configuration options that apply to the entire library.</p> <code>ConstraintSense</code> <code>ObjSense</code> <code>PyoframeError</code> <code>Solver</code> <code>UnmatchedStrategy</code> <code>VType</code> <p>Attributes:</p> Name Type Description <code>COEF_KEY</code> <code>CONSTRAINT_KEY</code> <code>CONST_TERM</code> <code>DUAL_KEY</code> <code>KEY_TYPE</code> <code>ObjSenseValue</code> <code>QUAD_VAR_KEY</code> <code>RESERVED_COL_KEYS</code> <code>SOLUTION_KEY</code> <code>SUPPORTED_SOLVERS</code> <code>SUPPORTED_SOLVER_TYPES</code> <code>VAR_KEY</code> <code>VTypeValue</code>"},{"location":"reference/internal/constants/#pyoframe.constants.COEF_KEY","title":"<code>COEF_KEY = '__coeff'</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.CONSTRAINT_KEY","title":"<code>CONSTRAINT_KEY = '__constraint_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.CONST_TERM","title":"<code>CONST_TERM = 0</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.DUAL_KEY","title":"<code>DUAL_KEY = 'dual'</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.KEY_TYPE","title":"<code>KEY_TYPE = pl.UInt32</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.ObjSenseValue","title":"<code>ObjSenseValue = Literal['min', 'max']</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.QUAD_VAR_KEY","title":"<code>QUAD_VAR_KEY = '__quadratic_variable_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.RESERVED_COL_KEYS","title":"<code>RESERVED_COL_KEYS = (COEF_KEY, VAR_KEY, QUAD_VAR_KEY, CONSTRAINT_KEY, SOLUTION_KEY, DUAL_KEY)</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.SOLUTION_KEY","title":"<code>SOLUTION_KEY = 'solution'</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.SUPPORTED_SOLVERS","title":"<code>SUPPORTED_SOLVERS = [Solver('gurobi'), Solver('highs', supports_quadratics=False, supports_duals=False), Solver('ipopt', supports_integer_variables=False, supports_objective_sense=False, supports_write=False)]</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.SUPPORTED_SOLVER_TYPES","title":"<code>SUPPORTED_SOLVER_TYPES = Literal['gurobi', 'highs', 'ipopt']</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.VAR_KEY","title":"<code>VAR_KEY = '__variable_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.VTypeValue","title":"<code>VTypeValue = Literal['continuous', 'binary', 'integer']</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Config","title":"<code>Config</code>","text":"<p>Configuration options that apply to the entire library.</p> <p>Methods:</p> Name Description <code>reset_defaults</code> <p>Resets all configuration options to their default values.</p> <p>Attributes:</p> Name Type Description <code>default_solver</code> <code>SUPPORTED_SOLVER_TYPES | Solver | None</code> <p>The solver to use when <code>pf.Model()</code> is called without specifying a solver.</p> <code>disable_unmatched_checks</code> <code>bool</code> <code>enable_is_duplicated_expression_safety_check</code> <code>bool</code> <code>float_to_str_precision</code> <code>Optional[int]</code> <code>integer_tolerance</code> <code>float</code> <p>For convenience, Pyoframe returns the solution of integer and binary variables as integers not floating point values.</p> <code>print_max_line_length</code> <code>int</code> <code>print_max_lines</code> <code>int</code> <code>print_max_set_elements</code> <code>int</code> <p>Number of elements to show when printing a set to the console (additional elements are replaced with ...)</p> <code>print_uses_variable_names</code> <code>bool</code>"},{"location":"reference/internal/constants/#pyoframe.constants.Config.default_solver","title":"<code>default_solver = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The solver to use when <code>pf.Model()</code> is called without specifying a solver. If default_solver is not set (<code>None</code>), Pyoframe will choose the first solver in SUPPORTED_SOLVERS that doesn't produce an error.</p> <p>There is no reason why you set the solver here instead of passing it to the Model constructor. This is mainly used for testing purposes.</p>"},{"location":"reference/internal/constants/#pyoframe.constants.Config.disable_unmatched_checks","title":"<code>disable_unmatched_checks = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Config.enable_is_duplicated_expression_safety_check","title":"<code>enable_is_duplicated_expression_safety_check = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Config.float_to_str_precision","title":"<code>float_to_str_precision = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Config.integer_tolerance","title":"<code>integer_tolerance = 1e-08</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>For convenience, Pyoframe returns the solution of integer and binary variables as integers not floating point values. To do so, Pyoframe must convert the solver-provided floating point values to integers. To avoid unexpected rounding errors, Pyoframe uses this tolerance to check that the floating point result is an integer as expected. Overly tight tolerances can trigger unexpected errors. Setting the tolerance to zero disables the check.</p>"},{"location":"reference/internal/constants/#pyoframe.constants.Config.print_max_line_length","title":"<code>print_max_line_length = 80</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Config.print_max_lines","title":"<code>print_max_lines = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Config.print_max_set_elements","title":"<code>print_max_set_elements = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of elements to show when printing a set to the console (additional elements are replaced with ...)</p>"},{"location":"reference/internal/constants/#pyoframe.constants.Config.print_uses_variable_names","title":"<code>print_uses_variable_names = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Config.reset_defaults","title":"<code>reset_defaults()</code>  <code>classmethod</code>","text":"<p>Resets all configuration options to their default values.</p> Source code in <code>pyoframe/constants.py</code> <pre><code>@classmethod\ndef reset_defaults(cls):\n    \"\"\"\n    Resets all configuration options to their default values.\n    \"\"\"\n    for key, value in cls._defaults.items():\n        setattr(cls, key, value)\n</code></pre>"},{"location":"reference/internal/constants/#pyoframe.constants.ConstraintSense","title":"<code>ConstraintSense</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Methods:</p> Name Description <code>to_poi</code> <p>Attributes:</p> Name Type Description <code>EQ</code> <code>GE</code> <code>LE</code>"},{"location":"reference/internal/constants/#pyoframe.constants.ConstraintSense.EQ","title":"<code>EQ = '='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.ConstraintSense.GE","title":"<code>GE = '&gt;='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.ConstraintSense.LE","title":"<code>LE = '&lt;='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.ConstraintSense.to_poi","title":"<code>to_poi()</code>","text":"Source code in <code>pyoframe/constants.py</code> <pre><code>def to_poi(self):\n    if self == ConstraintSense.LE:\n        return poi.ConstraintSense.LessEqual\n    elif self == ConstraintSense.EQ:\n        return poi.ConstraintSense.Equal\n    elif self == ConstraintSense.GE:\n        return poi.ConstraintSense.GreaterEqual\n    else:\n        raise ValueError(f\"Invalid constraint type: {self}\")  # pragma: no cover\n</code></pre>"},{"location":"reference/internal/constants/#pyoframe.constants.ObjSense","title":"<code>ObjSense</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Methods:</p> Name Description <code>to_poi</code> <p>Attributes:</p> Name Type Description <code>MAX</code> <code>MIN</code>"},{"location":"reference/internal/constants/#pyoframe.constants.ObjSense.MAX","title":"<code>MAX = 'max'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.ObjSense.MIN","title":"<code>MIN = 'min'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.ObjSense.to_poi","title":"<code>to_poi()</code>","text":"Source code in <code>pyoframe/constants.py</code> <pre><code>def to_poi(self):\n    if self == ObjSense.MIN:\n        return poi.ObjectiveSense.Minimize\n    elif self == ObjSense.MAX:\n        return poi.ObjectiveSense.Maximize\n    else:\n        raise ValueError(f\"Invalid objective sense: {self}\")  # pragma: no cover\n</code></pre>"},{"location":"reference/internal/constants/#pyoframe.constants.PyoframeError","title":"<code>PyoframeError</code>","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/internal/constants/#pyoframe.constants.Solver","title":"<code>Solver(name, supports_integer_variables=True, supports_quadratics=True, supports_duals=True, supports_objective_sense=True, supports_write=True)</code>  <code>dataclass</code>","text":"<p>Methods:</p> Name Description <code>__repr__</code> <code>check_supports_integer_variables</code> <code>check_supports_write</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>SUPPORTED_SOLVER_TYPES</code> <code>supports_duals</code> <code>bool</code> <code>supports_integer_variables</code> <code>bool</code> <code>supports_objective_sense</code> <code>bool</code> <code>supports_quadratics</code> <code>bool</code> <code>supports_write</code> <code>bool</code>"},{"location":"reference/internal/constants/#pyoframe.constants.Solver.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Solver.supports_duals","title":"<code>supports_duals = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Solver.supports_integer_variables","title":"<code>supports_integer_variables = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Solver.supports_objective_sense","title":"<code>supports_objective_sense = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Solver.supports_quadratics","title":"<code>supports_quadratics = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Solver.supports_write","title":"<code>supports_write = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.Solver.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pyoframe/constants.py</code> <pre><code>def __repr__(self):\n    return self.name\n</code></pre>"},{"location":"reference/internal/constants/#pyoframe.constants.Solver.check_supports_integer_variables","title":"<code>check_supports_integer_variables()</code>","text":"Source code in <code>pyoframe/constants.py</code> <pre><code>def check_supports_integer_variables(self):\n    if not self.supports_integer_variables:\n        raise ValueError(\n            f\"Solver {self.name} does not support integer or binary variables.\"\n        )\n</code></pre>"},{"location":"reference/internal/constants/#pyoframe.constants.Solver.check_supports_write","title":"<code>check_supports_write()</code>","text":"Source code in <code>pyoframe/constants.py</code> <pre><code>def check_supports_write(self):\n    if not self.supports_write:\n        raise ValueError(f\"Solver {self.name} does not support .write()\")\n</code></pre>"},{"location":"reference/internal/constants/#pyoframe.constants.UnmatchedStrategy","title":"<code>UnmatchedStrategy</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Attributes:</p> Name Type Description <code>DROP</code> <code>KEEP</code> <code>UNSET</code>"},{"location":"reference/internal/constants/#pyoframe.constants.UnmatchedStrategy.DROP","title":"<code>DROP = 'drop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.UnmatchedStrategy.KEEP","title":"<code>KEEP = 'keep'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.UnmatchedStrategy.UNSET","title":"<code>UNSET = 'not_set'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.VType","title":"<code>VType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Methods:</p> Name Description <code>to_poi</code> <p>Attributes:</p> Name Type Description <code>BINARY</code> <code>CONTINUOUS</code> <code>INTEGER</code>"},{"location":"reference/internal/constants/#pyoframe.constants.VType.BINARY","title":"<code>BINARY = 'binary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.VType.CONTINUOUS","title":"<code>CONTINUOUS = 'continuous'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.VType.INTEGER","title":"<code>INTEGER = 'integer'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/constants/#pyoframe.constants.VType.to_poi","title":"<code>to_poi()</code>","text":"Source code in <code>pyoframe/constants.py</code> <pre><code>def to_poi(self):\n    if self == VType.CONTINUOUS:\n        return poi.VariableDomain.Continuous\n    elif self == VType.BINARY:\n        return poi.VariableDomain.Binary\n    elif self == VType.INTEGER:\n        return poi.VariableDomain.Integer\n    else:\n        raise ValueError(f\"Invalid variable type: {self}\")  # pragma: no cover\n</code></pre>"},{"location":"reference/internal/core/","title":"core","text":"<p>Classes:</p> Name Description <code>Constraint</code> <p>A linear programming constraint.</p> <code>Expression</code> <p>A linear or quadratic expression.</p> <code>Set</code> <p>A set which can then be used to index variables.</p> <code>SupportsMath</code> <p>Any object that can be converted into an expression.</p> <code>SupportsToExpr</code> <code>Variable</code> <p>Represents one or many decision variable in an optimization model.</p> <p>Functions:</p> Name Description <code>sum</code> <p>Sum an expression over specified dimensions.</p> <code>sum_by</code> <p>Like <code>pf.sum()</code>, but the sum is taken over all dimensions except those specified in <code>by</code> (just like a <code>group_by</code> operation).</p> <p>Attributes:</p> Name Type Description <code>SetTypes</code>"},{"location":"reference/internal/core/#pyoframe.core.SetTypes","title":"<code>SetTypes = Union[pl.DataFrame, pd.Index, pd.DataFrame, SupportsMath, Mapping[str, Sequence[object]], 'Set', 'Constraint']</code>  <code>module-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.Constraint","title":"<code>Constraint(lhs, sense)</code>","text":"<p>               Bases: <code>ModelElementWithId</code></p> <p>A linear programming constraint.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>Expression</code> <p>The left hand side of the constraint.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required <p>Methods:</p> Name Description <code>__repr__</code> <code>filter</code> <code>get_id_column_name</code> <code>on_add_to_model</code> <code>relax</code> <p>Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.</p> <code>to_str</code> <p>Attributes:</p> Name Type Description <code>attr</code> <code>Container</code> <p>Allows reading and writing constraint attributes similarly to Model.attr.</p> <code>dual</code> <code>Union[DataFrame, float]</code> <code>lhs</code> <code>sense</code> <code>to_relax</code> <code>Optional[FuncArgs]</code> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, lhs: Expression, sense: ConstraintSense):\n    \"\"\"Initialize a constraint.\n\n    Parameters:\n        lhs:\n            The left hand side of the constraint.\n        sense:\n            The sense of the constraint.\n    \"\"\"\n    self.lhs = lhs\n    self._model = lhs._model\n    self.sense = sense\n    self.to_relax: Optional[FuncArgs] = None\n    self._attr = Container(self._set_attribute, self._get_attribute)\n\n    dims = self.lhs.dimensions\n    data = pl.DataFrame() if dims is None else self.lhs.data.select(dims).unique()\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Constraint.attr","title":"<code>attr</code>  <code>property</code>","text":"<p>Allows reading and writing constraint attributes similarly to Model.attr.</p>"},{"location":"reference/internal/core/#pyoframe.core.Constraint.dual","title":"<code>dual</code>  <code>property</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.Constraint.lhs","title":"<code>lhs = lhs</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.Constraint.sense","title":"<code>sense = sense</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.Constraint.to_relax","title":"<code>to_relax = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.Constraint.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return (\n        get_obj_repr(\n            self,\n            (\"name\",),\n            sense=f\"'{self.sense.value}'\",\n            size=len(self),\n            dimensions=self.shape,\n            terms=len(self.lhs.data),\n        )\n        + \"\\n\"\n        + self.to_str()\n    )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Constraint.filter","title":"<code>filter(*args, **kwargs)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def filter(self, *args, **kwargs) -&gt; pl.DataFrame:\n    return self.lhs.data.filter(*args, **kwargs)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Constraint.get_id_column_name","title":"<code>get_id_column_name()</code>  <code>classmethod</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>@classmethod\ndef get_id_column_name(cls):\n    return CONSTRAINT_KEY\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Constraint.on_add_to_model","title":"<code>on_add_to_model(model, name)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def on_add_to_model(self, model: \"Model\", name: str):\n    super().on_add_to_model(model, name)\n    if self.to_relax is not None:\n        self.relax(*self.to_relax.args, **self.to_relax.kwargs)\n    self._assign_ids()\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Constraint.relax","title":"<code>relax(cost, max=None)</code>","text":"<p>Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>SupportsToExpr</code> <p>The cost of relaxing the constraint. Costs should be positives as they will automatically become negative for maximization problems.</p> required <code>max</code> <code>Optional[SupportsToExpr]</code> <p>The maximum value of the relaxation variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>The same constraint</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.maximize = m.hours_day\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n16.0\n&gt;&gt;&gt; m.maximize += 2 * m.hours_day\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.hours_day.solution\n19.0\n</code></pre> <p><code>relax</code> can only be called after the sense of the model has been defined.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\nTraceback (most recent call last):\n...\nValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n</code></pre> <p>One way to solve this is by setting the sense directly on the model. See how this works fine:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(sense=\"max\")\n&gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n&gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n&gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n</code></pre> <p>And now an example with dimensions:</p> <pre><code>&gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame(\n...     {\n...         \"project\": [\"A\", \"B\", \"C\"],\n...         \"cost_per_hour_underdelivered\": [10, 20, 30],\n...         \"hours_to_finish\": [9, 9, 9],\n...         \"max_underdelivered\": [1, 9, 9],\n...     }\n... )\n&gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n&gt;&gt;&gt; m.must_finish_project = (\n...     m.hours_spent\n...     &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n... ).relax(\n...     homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]],\n...     max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]],\n... )\n&gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n&gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n&gt;&gt;&gt; m.only_one_day.relax(1)\nTraceback (most recent call last):\n...\nValueError: .relax() must be called before the Constraint is added to the model\n&gt;&gt;&gt; m.attr.Silent = True\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n-50.0\n&gt;&gt;&gt; m.hours_spent.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 project \u2506 solution \u2502\n\u2502 ---     \u2506 ---      \u2502\n\u2502 str     \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 A       \u2506 8.0      \u2502\n\u2502 B       \u2506 7.0      \u2502\n\u2502 C       \u2506 9.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def relax(\n    self, cost: SupportsToExpr, max: Optional[SupportsToExpr] = None\n) -&gt; Constraint:\n    \"\"\"\n    Relaxes the constraint by adding a variable to the constraint that can be non-zero at a cost.\n\n    Parameters:\n        cost:\n            The cost of relaxing the constraint. Costs should be positives as they will automatically\n            become negative for maximization problems.\n        max:\n            The maximum value of the relaxation variable.\n\n    Returns:\n        The same constraint\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.maximize = m.hours_day\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        16.0\n        &gt;&gt;&gt; m.maximize += 2 * m.hours_day\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.hours_day.solution\n        19.0\n\n        `relax` can only be called after the sense of the model has been defined.\n\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n        Traceback (most recent call last):\n        ...\n        ValueError: Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\n\n        One way to solve this is by setting the sense directly on the model. See how this works fine:\n\n        &gt;&gt;&gt; m = pf.Model(sense=\"max\")\n        &gt;&gt;&gt; m.hours_sleep = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_day = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.hours_in_day = m.hours_sleep + m.hours_day == 24\n        &gt;&gt;&gt; m.must_sleep = (m.hours_sleep &gt;= 8).relax(cost=2, max=3)\n\n        And now an example with dimensions:\n\n        &gt;&gt;&gt; homework_due_tomorrow = pl.DataFrame(\n        ...     {\n        ...         \"project\": [\"A\", \"B\", \"C\"],\n        ...         \"cost_per_hour_underdelivered\": [10, 20, 30],\n        ...         \"hours_to_finish\": [9, 9, 9],\n        ...         \"max_underdelivered\": [1, 9, 9],\n        ...     }\n        ... )\n        &gt;&gt;&gt; m.hours_spent = pf.Variable(homework_due_tomorrow[[\"project\"]], lb=0)\n        &gt;&gt;&gt; m.must_finish_project = (\n        ...     m.hours_spent\n        ...     &gt;= homework_due_tomorrow[[\"project\", \"hours_to_finish\"]]\n        ... ).relax(\n        ...     homework_due_tomorrow[[\"project\", \"cost_per_hour_underdelivered\"]],\n        ...     max=homework_due_tomorrow[[\"project\", \"max_underdelivered\"]],\n        ... )\n        &gt;&gt;&gt; m.only_one_day = sum(\"project\", m.hours_spent) &lt;= 24\n        &gt;&gt;&gt; # Relaxing a constraint after it has already been assigned will give an error\n        &gt;&gt;&gt; m.only_one_day.relax(1)\n        Traceback (most recent call last):\n        ...\n        ValueError: .relax() must be called before the Constraint is added to the model\n        &gt;&gt;&gt; m.attr.Silent = True\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.maximize.value\n        -50.0\n        &gt;&gt;&gt; m.hours_spent.solution\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 project \u2506 solution \u2502\n        \u2502 ---     \u2506 ---      \u2502\n        \u2502 str     \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 A       \u2506 8.0      \u2502\n        \u2502 B       \u2506 7.0      \u2502\n        \u2502 C       \u2506 9.0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if self._has_ids:\n        raise ValueError(\n            \".relax() must be called before the Constraint is added to the model\"\n        )\n\n    m = self._model\n    if m is None or self.name is None:\n        self.to_relax = FuncArgs(args=[cost, max])\n        return self\n\n    var_name = f\"{self.name}_relaxation\"\n    assert not hasattr(m, var_name), (\n        \"Conflicting names, relaxation variable already exists on the model.\"\n    )\n    var = Variable(self, lb=0, ub=max)\n    setattr(m, var_name, var)\n\n    if self.sense == ConstraintSense.LE:\n        self.lhs -= var\n    elif self.sense == ConstraintSense.GE:\n        self.lhs += var\n    else:  # pragma: no cover\n        # TODO\n        raise NotImplementedError(\n            \"Relaxation for equalities has not yet been implemented. Submit a pull request!\"\n        )\n\n    penalty = var * cost\n    if self.dimensions:\n        penalty = sum(self.dimensions, penalty)\n    if m.sense is None:\n        raise ValueError(\n            \"Cannot relax a constraint before the objective sense has been set. Try setting the objective first or using Model(sense=...).\"\n        )\n    elif m.sense == ObjSense.MAX:\n        penalty *= -1\n    if m.objective is None:\n        m.objective = penalty\n    else:\n        m.objective += penalty\n\n    return self\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Constraint.to_str","title":"<code>to_str()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_str(self) -&gt; str:\n    dims = self.dimensions\n    str_table = self.lhs.to_str_table(include_const_term=False)\n    str_table = self.lhs.to_str_create_prefix(str_table)\n    rhs = self.lhs.constant_terms.with_columns(pl.col(COEF_KEY) * -1)\n    rhs = cast_coef_to_string(rhs, drop_ones=False)\n    # Remove leading +\n    rhs = rhs.with_columns(pl.col(COEF_KEY).str.strip_chars(characters=\" +\"))\n    rhs = rhs.rename({COEF_KEY: \"rhs\"})\n    constr_str = pl.concat(\n        [str_table, rhs], how=(\"align\" if dims else \"horizontal\")\n    )\n    constr_str = constr_str.select(\n        pl.concat_str(\"expr\", pl.lit(f\" {self.sense.value} \"), \"rhs\").str.join(\n            delimiter=\"\\n\"\n        )\n    ).item()\n    return constr_str\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression","title":"<code>Expression(data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A linear or quadratic expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame(\n...     {\n...         \"item\": [1, 1, 1, 2, 2],\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"cost\": [1, 2, 3, 4, 5],\n...     }\n... ).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.Time = pf.Variable(df.index)\n&gt;&gt;&gt; m.Size = pf.Variable(df.index)\n&gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n&gt;&gt;&gt; expr\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n[1,mon]: Time[1,mon] + Size[1,mon]\n[1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n[1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n[2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n[2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n</code></pre> <p>Methods:</p> Name Description <code>__add__</code> <p>Examples:</p> <code>__mul__</code> <code>__repr__</code> <code>__str__</code> <code>constant</code> <p>Examples:</p> <code>degree</code> <p>Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).</p> <code>evaluate</code> <p>The value of the expression. Only available after the model has been solved.</p> <code>map</code> <p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <code>rolling_sum</code> <p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <code>sum</code> <p>Examples:</p> <code>to_expr</code> <code>to_poi</code> <code>to_str</code> <code>to_str_create_prefix</code> <code>to_str_table</code> <code>within</code> <p>Examples:</p> <p>Attributes:</p> Name Type Description <code>constant_terms</code> <code>is_quadratic</code> <code>bool</code> <p>Returns True if the expression is quadratic, False otherwise.</p> <code>terms</code> <code>int</code> <p>Number of terms across all subexpressions.</p> <code>variable_terms</code> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, data: pl.DataFrame):\n    \"\"\"\n    A linear expression.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; df = pd.DataFrame(\n        ...     {\n        ...         \"item\": [1, 1, 1, 2, 2],\n        ...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n        ...         \"cost\": [1, 2, 3, 4, 5],\n        ...     }\n        ... ).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.Time = pf.Variable(df.index)\n        &gt;&gt;&gt; m.Size = pf.Variable(df.index)\n        &gt;&gt;&gt; expr = df[\"cost\"] * m.Time + df[\"cost\"] * m.Size\n        &gt;&gt;&gt; expr\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=10&gt;\n        [1,mon]: Time[1,mon] + Size[1,mon]\n        [1,tue]: 2 Time[1,tue] +2 Size[1,tue]\n        [1,wed]: 3 Time[1,wed] +3 Size[1,wed]\n        [2,mon]: 4 Time[2,mon] +4 Size[2,mon]\n        [2,tue]: 5 Time[2,tue] +5 Size[2,tue]\n    \"\"\"\n    # Sanity checks, VAR_KEY and COEF_KEY must be present\n    assert VAR_KEY in data.columns, \"Missing variable column.\"\n    assert COEF_KEY in data.columns, \"Missing coefficient column.\"\n\n    # Sanity check no duplicates indices\n    if Config.enable_is_duplicated_expression_safety_check:\n        duplicated_mask = data.drop(COEF_KEY).is_duplicated()\n        # In theory this should never happen unless there's a bug in the library\n        if duplicated_mask.any():  # pragma: no cover\n            duplicated_data = data.filter(duplicated_mask)\n            raise ValueError(\n                f\"Cannot create an expression with duplicate indices:\\n{duplicated_data}.\"\n            )\n\n    data = _simplify_expr_df(data)\n\n    super().__init__(data)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.constant_terms","title":"<code>constant_terms</code>  <code>property</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.Expression.is_quadratic","title":"<code>is_quadratic</code>  <code>property</code>","text":"<p>Returns True if the expression is quadratic, False otherwise.</p> <p>Computes in O(1) since expressions are quadratic if and only if self.data contain the QUAD_VAR_KEY column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}) * m.v\n&gt;&gt;&gt; expr *= m.v\n&gt;&gt;&gt; expr.is_quadratic\nTrue\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.terms","title":"<code>terms</code>  <code>property</code>","text":"<p>Number of terms across all subexpressions.</p> <p>Expressions equal to zero count as one term.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable({\"t\": [1, 2]})\n&gt;&gt;&gt; coef = pl.DataFrame({\"t\": [1, 2], \"coef\": [0, 1]})\n&gt;&gt;&gt; coef * (m.v + 4)\n&lt;Expression size=2 dimensions={'t': 2} terms=3&gt;\n[1]: 0\n[2]: 4  + v[2]\n&gt;&gt;&gt; (coef * (m.v + 4)).terms\n3\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.variable_terms","title":"<code>variable_terms</code>  <code>property</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.Expression.__add__","title":"<code>__add__(other)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1, 2, 3], \"add\": [10, 20, 30]}).to_expr()\n&gt;&gt;&gt; m.v = Variable(add)\n&gt;&gt;&gt; m.v + add\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: v[1] +10\n[2]: v[2] +20\n[3]: v[3] +30\n&gt;&gt;&gt; m.v + add + 2\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: v[1] +12\n[2]: v[2] +22\n[3]: v[3] +32\n&gt;&gt;&gt; m.v + pd.DataFrame({\"dim1\": [1, 2], \"add\": [10, 20]})\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim1_right \u2502\n\u2502 ---  \u2506 ---        \u2502\n\u2502 i64  \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3    \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.v2 = Variable()\n&gt;&gt;&gt; 5 + 2 * m.v2\n&lt;Expression size=1 dimensions={} terms=2&gt;\n2 v2 +5\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; add = pd.DataFrame({\"dim1\": [1, 2, 3], \"add\": [10, 20, 30]}).to_expr()\n        &gt;&gt;&gt; m.v = Variable(add)\n        &gt;&gt;&gt; m.v + add\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: v[1] +10\n        [2]: v[2] +20\n        [3]: v[3] +30\n        &gt;&gt;&gt; m.v + add + 2\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: v[1] +12\n        [2]: v[2] +22\n        [3]: v[3] +32\n        &gt;&gt;&gt; m.v + pd.DataFrame({\"dim1\": [1, 2], \"add\": [10, 20]})\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt; + &lt;Expression size=2 dimensions={'dim1': 2} terms=2&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (1, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim1_right \u2502\n        \u2502 ---  \u2506 ---        \u2502\n        \u2502 i64  \u2506 i64        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 3    \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; m.v2 = Variable()\n        &gt;&gt;&gt; 5 + 2 * m.v2\n        &lt;Expression size=1 dimensions={} terms=2&gt;\n        2 v2 +5\n    \"\"\"\n    if isinstance(other, str):\n        raise ValueError(\n            \"Cannot add a string to an expression. Perhaps you meant to use pf.sum() instead of sum()?\"\n        )\n    if isinstance(other, (int, float)):\n        return self._add_const(other)\n    other = other.to_expr()\n    self._learn_from_other(other)\n    return _add_expressions(self, other)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.__mul__","title":"<code>__mul__(other)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __mul__(\n    self: \"Expression\", other: int | float | SupportsToExpr\n) -&gt; \"Expression\":\n    if isinstance(other, (int, float)):\n        return self.with_columns(pl.col(COEF_KEY) * other)\n\n    other = other.to_expr()\n    self._learn_from_other(other)\n    return _multiply_expressions(self, other)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.to_str(include_header=True)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.__str__","title":"<code>__str__()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.to_str()\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.constant","title":"<code>constant(constant)</code>  <code>classmethod</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Expression.constant(5)\n&lt;Expression size=1 dimensions={} terms=1&gt;\n5\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>@classmethod\ndef constant(cls, constant: int | float) -&gt; \"Expression\":\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; pf.Expression.constant(5)\n        &lt;Expression size=1 dimensions={} terms=1&gt;\n        5\n    \"\"\"\n    return cls(\n        pl.DataFrame(\n            {\n                COEF_KEY: [constant],\n                VAR_KEY: [CONST_TERM],\n            },\n            schema={COEF_KEY: pl.Float64, VAR_KEY: KEY_TYPE},\n        )\n    )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.degree","title":"<code>degree()</code>","text":"<p>Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v1 = pf.Variable()\n&gt;&gt;&gt; m.v2 = pf.Variable()\n&gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n&gt;&gt;&gt; expr.degree()\n0\n&gt;&gt;&gt; expr *= m.v1\n&gt;&gt;&gt; expr.degree()\n1\n&gt;&gt;&gt; expr += (m.v2**2).add_dim(\"dim1\")\n&gt;&gt;&gt; expr.degree()\n2\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def degree(self) -&gt; int:\n    \"\"\"\n    Returns the degree of the expression (0=constant, 1=linear, 2=quadratic).\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v1 = pf.Variable()\n        &gt;&gt;&gt; m.v2 = pf.Variable()\n        &gt;&gt;&gt; expr = pd.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}).to_expr()\n        &gt;&gt;&gt; expr.degree()\n        0\n        &gt;&gt;&gt; expr *= m.v1\n        &gt;&gt;&gt; expr.degree()\n        1\n        &gt;&gt;&gt; expr += (m.v2**2).add_dim(\"dim1\")\n        &gt;&gt;&gt; expr.degree()\n        2\n    \"\"\"\n    if self.is_quadratic:\n        return 2\n    elif (self.data.get_column(VAR_KEY) != CONST_TERM).any():\n        return 1\n    else:\n        return 0\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.evaluate","title":"<code>evaluate()</code>","text":"<p>The value of the expression. Only available after the model has been solved.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, ub=10)\n&gt;&gt;&gt; m.expr_1 = 2 * m.X + 1\n&gt;&gt;&gt; m.expr_2 = pf.sum(m.expr_1)\n&gt;&gt;&gt; m.maximize = m.expr_2 - 3\n&gt;&gt;&gt; m.attr.Silent = True\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.expr_1.evaluate()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 21.0     \u2502\n\u2502 2    \u2506 21.0     \u2502\n\u2502 3    \u2506 21.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.expr_2.evaluate()\n63.0\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>@unwrap_single_values\ndef evaluate(self) -&gt; pl.DataFrame:\n    \"\"\"\n    The value of the expression. Only available after the model has been solved.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable({\"dim1\": [1, 2, 3]}, ub=10)\n        &gt;&gt;&gt; m.expr_1 = 2 * m.X + 1\n        &gt;&gt;&gt; m.expr_2 = pf.sum(m.expr_1)\n        &gt;&gt;&gt; m.maximize = m.expr_2 - 3\n        &gt;&gt;&gt; m.attr.Silent = True\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.expr_1.evaluate()\n        shape: (3, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 solution \u2502\n        \u2502 ---  \u2506 ---      \u2502\n        \u2502 i64  \u2506 f64      \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 21.0     \u2502\n        \u2502 2    \u2506 21.0     \u2502\n        \u2502 3    \u2506 21.0     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; m.expr_2.evaluate()\n        63.0\n    \"\"\"\n    assert self._model is not None, (\n        \"Expression must be added to the model to use .value\"\n    )\n\n    df = self.data\n    sm = self._model.poi\n    attr = poi.VariableAttribute.Value\n    for var_col in self._variable_columns:\n        df = df.with_columns(\n            (\n                pl.col(COEF_KEY)\n                * pl.col(var_col).map_elements(\n                    lambda v_id: (\n                        sm.get_variable_attribute(poi.VariableIndex(v_id), attr)\n                        if v_id != CONST_TERM\n                        else 1\n                    ),\n                    return_dtype=pl.Float64,\n                )\n            ).alias(COEF_KEY)\n        ).drop(var_col)\n\n    df = df.rename({COEF_KEY: SOLUTION_KEY})\n\n    dims = self.dimensions\n    if dims is not None:\n        df = df.group_by(dims, maintain_order=True)\n    return df.sum()\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.map","title":"<code>map(mapping_set, drop_shared_dims=True)</code>","text":"<p>Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.</p> <p>This is particularly useful to go from one type of dimensions to another. For example, to convert data that is indexed by city to data indexed by country (see example).</p> <p>Parameters:</p> Name Type Description Default <code>mapping_set</code> <code>SetTypes</code> <p>The set to map the expression to. This can be a DataFrame, Index, or another Set.</p> required <code>drop_shared_dims</code> <code>bool</code> <p>If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and     repeated rows are summed. If False, the shared dimensions are kept in the resulting expression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression containing the result of the mapping operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; pop_data = pl.DataFrame(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n...         \"year\": [2024, 2024, 2024],\n...         \"population\": [10, 2, 8],\n...     }\n... ).to_expr()\n&gt;&gt;&gt; cities_and_countries = pl.DataFrame(\n...     {\n...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n...         \"country\": [\"Canada\", \"Canada\", \"USA\"],\n...     }\n... )\n&gt;&gt;&gt; pop_data.map(cities_and_countries)\n&lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n[2024,Canada]: 12\n[2024,USA]: 8\n&gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n&lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n[Toronto,2024,Canada]: 10\n[Vancouver,2024,Canada]: 2\n[Boston,2024,USA]: 8\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def map(self, mapping_set: SetTypes, drop_shared_dims: bool = True) -&gt; Expression:\n    \"\"\"\n    Replaces the dimensions that are shared with mapping_set with the other dimensions found in mapping_set.\n\n    This is particularly useful to go from one type of dimensions to another. For example, to convert data that\n    is indexed by city to data indexed by country (see example).\n\n    Parameters:\n        mapping_set:\n            The set to map the expression to. This can be a DataFrame, Index, or another Set.\n        drop_shared_dims:\n            If True, the dimensions shared between the expression and the mapping set are dropped from the resulting expression and\n                repeated rows are summed.\n            If False, the shared dimensions are kept in the resulting expression.\n\n    Returns:\n        A new Expression containing the result of the mapping operation.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; pop_data = pl.DataFrame(\n        ...     {\n        ...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n        ...         \"year\": [2024, 2024, 2024],\n        ...         \"population\": [10, 2, 8],\n        ...     }\n        ... ).to_expr()\n        &gt;&gt;&gt; cities_and_countries = pl.DataFrame(\n        ...     {\n        ...         \"city\": [\"Toronto\", \"Vancouver\", \"Boston\"],\n        ...         \"country\": [\"Canada\", \"Canada\", \"USA\"],\n        ...     }\n        ... )\n        &gt;&gt;&gt; pop_data.map(cities_and_countries)\n        &lt;Expression size=2 dimensions={'year': 1, 'country': 2} terms=2&gt;\n        [2024,Canada]: 12\n        [2024,USA]: 8\n        &gt;&gt;&gt; pop_data.map(cities_and_countries, drop_shared_dims=False)\n        &lt;Expression size=3 dimensions={'city': 3, 'year': 1, 'country': 2} terms=3&gt;\n        [Toronto,2024,Canada]: 10\n        [Vancouver,2024,Canada]: 2\n        [Boston,2024,USA]: 8\n    \"\"\"\n    mapping_set = Set(mapping_set)\n\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\"Cannot use .map() on an expression with no dimensions.\")\n\n    mapping_dims = mapping_set.dimensions\n    if mapping_dims is None:\n        raise ValueError(\n            \"Cannot use .map() with a mapping set containing no dimensions.\"\n        )\n\n    shared_dims = [dim for dim in dims if dim in mapping_dims]\n    if not shared_dims:\n        raise ValueError(\n            f\"Cannot apply .map() as there are no shared dimensions between the expression (dims={self.dimensions}) and the mapping set (dims={mapping_set.dimensions}).\"\n        )\n\n    mapped_expression = self * mapping_set\n\n    if drop_shared_dims:\n        return sum(shared_dims, mapped_expression)\n\n    return mapped_expression\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.rolling_sum","title":"<code>rolling_sum(over, window_size)</code>","text":"<p>Calculates the rolling sum of the Expression over a specified window size for a given dimension.</p> <p>This method applies a rolling sum operation over the dimension specified by <code>over</code>, using a window defined by <code>window_size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>over</code> <p>The name of the dimension (column) over which the rolling sum is calculated. This dimension must exist within the Expression's dimensions.</p> required <code>window_size</code> <p>The size of the moving window in terms of number of records. The rolling sum is calculated over this many consecutive elements.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>A new Expression instance containing the result of the rolling sum operation. This new Expression retains all dimensions (columns) of the original data, with the rolling sum applied over the specified dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; cost = pl.DataFrame(\n...     {\n...         \"item\": [1, 1, 1, 2, 2],\n...         \"time\": [1, 2, 3, 1, 2],\n...         \"cost\": [1, 2, 3, 4, 5],\n...     }\n... )\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n&gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n&lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n[1,1]: quantity[1,1]\n[1,2]: quantity[1,1] +2 quantity[1,2]\n[1,3]: 2 quantity[1,2] +3 quantity[1,3]\n[2,1]: 4 quantity[2,1]\n[2,2]: 4 quantity[2,1] +5 quantity[2,2]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def rolling_sum(self, over: str, window_size: int) -&gt; Expression:\n    \"\"\"\n    Calculates the rolling sum of the Expression over a specified window size for a given dimension.\n\n    This method applies a rolling sum operation over the dimension specified by `over`,\n    using a window defined by `window_size`.\n\n\n    Parameters:\n        over :\n            The name of the dimension (column) over which the rolling sum is calculated.\n            This dimension must exist within the Expression's dimensions.\n        window_size :\n            The size of the moving window in terms of number of records.\n            The rolling sum is calculated over this many consecutive elements.\n\n    Returns:\n        A new Expression instance containing the result of the rolling sum operation.\n            This new Expression retains all dimensions (columns) of the original data,\n            with the rolling sum applied over the specified dimension.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; cost = pl.DataFrame(\n        ...     {\n        ...         \"item\": [1, 1, 1, 2, 2],\n        ...         \"time\": [1, 2, 3, 1, 2],\n        ...         \"cost\": [1, 2, 3, 4, 5],\n        ...     }\n        ... )\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.quantity = pf.Variable(cost[[\"item\", \"time\"]])\n        &gt;&gt;&gt; (m.quantity * cost).rolling_sum(over=\"time\", window_size=2)\n        &lt;Expression size=5 dimensions={'item': 2, 'time': 3} terms=8&gt;\n        [1,1]: quantity[1,1]\n        [1,2]: quantity[1,1] +2 quantity[1,2]\n        [1,3]: 2 quantity[1,2] +3 quantity[1,3]\n        [2,1]: 4 quantity[2,1]\n        [2,2]: 4 quantity[2,1] +5 quantity[2,2]\n    \"\"\"\n    dims = self.dimensions\n    if dims is None:\n        raise ValueError(\n            \"Cannot use rolling_sum() with an expression with no dimensions.\"\n        )\n    assert over in dims, f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        pl.concat(\n            [\n                df.with_columns(pl.col(over).max())\n                for _, df in self.data.rolling(\n                    index_column=over,\n                    period=f\"{window_size}i\",\n                    group_by=remaining_dims,\n                )\n            ]\n        )\n    )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.sum","title":"<code>sum(over)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; df = pd.DataFrame(\n...     {\n...         \"item\": [1, 1, 1, 2, 2],\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"cost\": [1, 2, 3, 4, 5],\n...     }\n... ).set_index([\"item\", \"time\"])\n&gt;&gt;&gt; m.quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n&gt;&gt;&gt; expr = (m.quantity * df[\"cost\"]).sum(\"time\")\n&gt;&gt;&gt; expr.data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0     \u2506 1             \u2502\n\u2502 2    \u2506 9.0     \u2506 2             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def sum(self, over: Union[str, Iterable[str]]):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; df = pd.DataFrame(\n        ...     {\n        ...         \"item\": [1, 1, 1, 2, 2],\n        ...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n        ...         \"cost\": [1, 2, 3, 4, 5],\n        ...     }\n        ... ).set_index([\"item\", \"time\"])\n        &gt;&gt;&gt; m.quantity = Variable(df.reset_index()[[\"item\"]].drop_duplicates())\n        &gt;&gt;&gt; expr = (m.quantity * df[\"cost\"]).sum(\"time\")\n        &gt;&gt;&gt; expr.data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 item \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 6.0     \u2506 1             \u2502\n        \u2502 2    \u2506 9.0     \u2506 2             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if isinstance(over, str):\n        over = [over]\n    dims = self.dimensions\n    if not dims:\n        raise ValueError(\n            f\"Cannot sum over dimensions {over} since the current expression has no dimensions.\"\n        )\n    assert set(over) &lt;= set(dims), f\"Cannot sum over {over} as it is not in {dims}\"\n    remaining_dims = [dim for dim in dims if dim not in over]\n\n    return self._new(\n        self.data.drop(over)\n        .group_by(remaining_dims + self._variable_columns, maintain_order=True)\n        .sum()\n    )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.to_expr","title":"<code>to_expr()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    return self\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.to_poi","title":"<code>to_poi()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_poi(self) -&gt; poi.ScalarAffineFunction | poi.ScalarQuadraticFunction:\n    if self.dimensions is not None:\n        raise ValueError(\n            \"Only non-dimensioned expressions can be converted to PyOptInterface.\"\n        )  # pragma: no cover\n\n    if self.is_quadratic:\n        return poi.ScalarQuadraticFunction(\n            coefficients=self.data.get_column(COEF_KEY).to_numpy(),\n            var1s=self.data.get_column(VAR_KEY).to_numpy(),\n            var2s=self.data.get_column(QUAD_VAR_KEY).to_numpy(),\n        )\n    else:\n        return poi.ScalarAffineFunction(\n            coefficients=self.data.get_column(COEF_KEY).to_numpy(),\n            variables=self.data.get_column(VAR_KEY).to_numpy(),\n        )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.to_str","title":"<code>to_str(include_const_term=True, include_header=False, include_data=True)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_str(\n    self,\n    include_const_term=True,\n    include_header=False,\n    include_data=True,\n):\n    result = \"\"\n    if include_header:\n        result += get_obj_repr(\n            self,\n            size=len(self),\n            dimensions=self.shape,\n            terms=self.terms,\n            degree=2 if self.degree() == 2 else None,\n        )\n    if include_header and include_data:\n        result += \"\\n\"\n    if include_data:\n        str_table = self.to_str_table(\n            include_const_term=include_const_term,\n        )\n        str_table = self.to_str_create_prefix(str_table)\n        result += str_table.select(pl.col(\"expr\").str.join(delimiter=\"\\n\")).item()\n\n    return result\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.to_str_create_prefix","title":"<code>to_str_create_prefix(data)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_str_create_prefix(self, data):\n    if self.name is None and self.dimensions is None:\n        return data\n\n    return (\n        concat_dimensions(data, prefix=self.name, ignore_columns=[\"expr\"])\n        .with_columns(\n            pl.concat_str(\"concated_dim\", pl.lit(\": \"), \"expr\").alias(\"expr\")\n        )\n        .drop(\"concated_dim\")\n    )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.to_str_table","title":"<code>to_str_table(include_const_term=True)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_str_table(self, include_const_term=True):\n    data = self.data if include_const_term else self.variable_terms\n    data = cast_coef_to_string(data)\n\n    for var_col in self._variable_columns:\n        temp_var_column = f\"{var_col}_temp\"\n        if self._model is not None and self._model.var_map is not None:\n            data = self._model.var_map.apply(\n                data, to_col=temp_var_column, id_col=var_col\n            )\n        else:\n            data = data.with_columns(\n                pl.concat_str(pl.lit(\"x\"), var_col).alias(temp_var_column)\n            )\n        data = data.with_columns(\n            pl.when(pl.col(var_col) == CONST_TERM)\n            .then(pl.lit(\"\"))\n            .otherwise(temp_var_column)\n            .alias(var_col)\n        ).drop(temp_var_column)\n    if self.is_quadratic:\n        data = data.with_columns(\n            pl.when(pl.col(QUAD_VAR_KEY) == \"\")\n            .then(pl.col(VAR_KEY))\n            .otherwise(pl.concat_str(VAR_KEY, pl.lit(\" * \"), pl.col(QUAD_VAR_KEY)))\n            .alias(VAR_KEY)\n        ).drop(QUAD_VAR_KEY)\n\n    dimensions = self.dimensions\n\n    # Create a string for each term\n    data = data.with_columns(\n        expr=pl.concat_str(\n            COEF_KEY,\n            pl.lit(\" \"),\n            VAR_KEY,\n        )\n    ).drop(COEF_KEY, VAR_KEY)\n\n    if dimensions is not None:\n        data = data.group_by(dimensions, maintain_order=True).agg(\n            pl.col(\"expr\").str.join(delimiter=\" \")\n        )\n    else:\n        data = data.select(pl.col(\"expr\").str.join(delimiter=\" \"))\n\n    # Remove leading +\n    data = data.with_columns(pl.col(\"expr\").str.strip_chars(characters=\" +\"))\n\n    # TODO add vertical ... if too many rows, in the middle of the table\n    if Config.print_max_lines:\n        data = data.head(Config.print_max_lines)\n\n    if Config.print_max_line_length:\n        data = data.with_columns(\n            pl.when(pl.col(\"expr\").str.len_chars() &gt; Config.print_max_line_length)\n            .then(\n                pl.concat_str(\n                    pl.col(\"expr\").str.slice(0, Config.print_max_line_length),\n                    pl.lit(\"...\"),\n                )\n            )\n            .otherwise(pl.col(\"expr\"))\n        )\n    return data\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Expression.within","title":"<code>within(set)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; general_expr = pd.DataFrame(\n...     {\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}\n... ).to_expr()\n&gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n&gt;&gt;&gt; general_expr.within(filter_expr).data\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n\u2502 ---  \u2506 ---     \u2506 ---           \u2502\n\u2502 i64  \u2506 f64     \u2506 u32           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0     \u2506 0             \u2502\n\u2502 3    \u2506 3.0     \u2506 0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def within(self, set: \"SetTypes\") -&gt; Expression:\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; general_expr = pd.DataFrame(\n        ...     {\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}\n        ... ).to_expr()\n        &gt;&gt;&gt; filter_expr = pd.DataFrame({\"dim1\": [1, 3], \"value\": [5, 6]}).to_expr()\n        &gt;&gt;&gt; general_expr.within(filter_expr).data\n        shape: (2, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 __coeff \u2506 __variable_id \u2502\n        \u2502 ---  \u2506 ---     \u2506 ---           \u2502\n        \u2502 i64  \u2506 f64     \u2506 u32           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 1.0     \u2506 0             \u2502\n        \u2502 3    \u2506 3.0     \u2506 0             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df: pl.DataFrame = Set(set).data\n    set_dims = _get_dimensions(df)\n    assert set_dims is not None, (\n        \"Cannot use .within() with a set with no dimensions.\"\n    )\n    dims = self.dimensions\n    assert dims is not None, (\n        \"Cannot use .within() with an expression with no dimensions.\"\n    )\n    dims_in_common = [dim for dim in dims if dim in set_dims]\n    by_dims = df.select(dims_in_common).unique(maintain_order=True)\n    return self._new(self.data.join(by_dims, on=dims_in_common))\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Set","title":"<code>Set(*data, **named_data)</code>","text":"<p>               Bases: <code>ModelElement</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>A set which can then be used to index variables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pf.Set(x=range(2), y=range(3))\n&lt;Set size=6 dimensions={'x': 2, 'y': 3}&gt;\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]\n</code></pre> <p>Methods:</p> Name Description <code>__add__</code> <code>__mul__</code> <code>__repr__</code> <code>to_expr</code> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, *data: SetTypes | Iterable[SetTypes], **named_data):\n    data_list = list(data)\n    for name, set in named_data.items():\n        data_list.append({name: set})\n    df = self._parse_acceptable_sets(*data_list)\n    if not df.is_empty() and df.is_duplicated().any():\n        raise ValueError(\"Duplicate rows found in input data.\")\n    super().__init__(df)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Set.__add__","title":"<code>__add__(other)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, Set):\n        try:\n            return self._new(\n                pl.concat([self.data, other.data]).unique(maintain_order=True)\n            )\n        except pl.exceptions.ShapeError as e:\n            if \"unable to vstack, column names don't match\" in str(e):\n                raise PyoframeError(\n                    f\"Failed to add sets '{self.friendly_name}' and '{other.friendly_name}' because dimensions do not match ({self.dimensions} != {other.dimensions}) \"\n                ) from e\n            raise e\n\n    return super().__add__(other)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Set.__mul__","title":"<code>__mul__(other)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, Set):\n        assert set(self.data.columns) &amp; set(other.data.columns) == set(), (\n            \"Cannot multiply two sets with columns in common.\"\n        )\n        return Set(self.data, other.data)\n    return super().__mul__(other)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Set.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __repr__(self):\n    return (\n        get_obj_repr(self, (\"name\",), size=self.data.height, dimensions=self.shape)\n        + \"\\n\"\n        + dataframe_to_tupled_list(\n            self.data, num_max_elements=Config.print_max_set_elements\n        )\n    )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Set.to_expr","title":"<code>to_expr()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    return Expression(\n        self.data.with_columns(\n            pl.lit(1).alias(COEF_KEY), pl.lit(CONST_TERM).alias(VAR_KEY)\n        )\n    )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath","title":"<code>SupportsMath(**kwargs)</code>","text":"<p>               Bases: <code>ABC</code>, <code>SupportsToExpr</code></p> <p>Any object that can be converted into an expression.</p> <p>Methods:</p> Name Description <code>__eq__</code> <p>Equality constraint.</p> <code>__ge__</code> <p>Equality constraint.</p> <code>__le__</code> <p>Equality constraint.</p> <code>__neg__</code> <code>__pow__</code> <p>Support squaring expressions:</p> <code>__radd__</code> <code>__rmul__</code> <code>__rsub__</code> <p>Support right subtraction.</p> <code>__sub__</code> <p>import polars as pl</p> <code>__truediv__</code> <p>Examples:</p> <code>add_dim</code> <code>drop_unmatched</code> <code>keep_unmatched</code> <code>to_expr</code> <p>Attributes:</p> Name Type Description <code>__add__</code> <code>__mul__</code> <code>allowed_new_dims</code> <code>List[str]</code> <code>map</code> <code>sum</code> <code>unmatched_strategy</code> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(self, **kwargs):\n    self.unmatched_strategy = UnmatchedStrategy.UNSET\n    self.allowed_new_dims: List[str] = []\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__add__","title":"<code>__add__ = _forward_to_expression('__add__')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__mul__","title":"<code>__mul__ = _forward_to_expression('__mul__')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.allowed_new_dims","title":"<code>allowed_new_dims = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.map","title":"<code>map = _forward_to_expression('map')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.sum","title":"<code>sum = _forward_to_expression('sum')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.unmatched_strategy","title":"<code>unmatched_strategy = UnmatchedStrategy.UNSET</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__eq__","title":"<code>__eq__(value)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable()\n&gt;&gt;&gt; m.v == 1\n&lt;Constraint sense='=' size=1 dimensions={} terms=2&gt;\nv = 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __eq__(self, value: object):  # type: ignore\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable()\n        &gt;&gt;&gt; m.v == 1\n        &lt;Constraint sense='=' size=1 dimensions={} terms=2&gt;\n        v = 1\n    \"\"\"\n    return Constraint(self - value, ConstraintSense.EQ)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable()\n&gt;&gt;&gt; m.v &gt;= 1\n&lt;Constraint sense='&gt;=' size=1 dimensions={} terms=2&gt;\nv &gt;= 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __ge__(self, other):\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable()\n        &gt;&gt;&gt; m.v &gt;= 1\n        &lt;Constraint sense='&gt;=' size=1 dimensions={} terms=2&gt;\n        v &gt;= 1\n    \"\"\"\n    return Constraint(self - other, ConstraintSense.GE)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__le__","title":"<code>__le__(other)</code>","text":"<p>Equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable()\n&gt;&gt;&gt; m.v &lt;= 1\n&lt;Constraint sense='&lt;=' size=1 dimensions={} terms=2&gt;\nv &lt;= 1\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __le__(self, other):\n    \"\"\"Equality constraint.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable()\n        &gt;&gt;&gt; m.v &lt;= 1\n        &lt;Constraint sense='&lt;=' size=1 dimensions={} terms=2&gt;\n        v &lt;= 1\n    \"\"\"\n    return Constraint(self - other, ConstraintSense.LE)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__neg__","title":"<code>__neg__()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __neg__(self):\n    res = self.to_expr() * -1\n    # Negating a constant term should keep the unmatched strategy\n    res.unmatched_strategy = self.unmatched_strategy\n    return res\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__pow__","title":"<code>__pow__(power)</code>","text":"<p>Support squaring expressions:</p> <p>m = pf.Model() m.v = pf.Variable() m.v2  v * v m.v3 Traceback (most recent call last): ... ValueError: Raising an expressions to 3 is not supported. Expressions can only be squared (2). Source code in <code>pyoframe/core.py</code> <pre><code>def __pow__(self, power: int):\n    \"\"\"\n    Support squaring expressions:\n    &gt;&gt;&gt; m = pf.Model()\n    &gt;&gt;&gt; m.v = pf.Variable()\n    &gt;&gt;&gt; m.v**2\n    &lt;Expression size=1 dimensions={} terms=1 degree=2&gt;\n    v * v\n    &gt;&gt;&gt; m.v**3\n    Traceback (most recent call last):\n    ...\n    ValueError: Raising an expressions to **3 is not supported. Expressions can only be squared (**2).\n    \"\"\"\n    if power == 2:\n        return self * self\n    raise ValueError(\n        f\"Raising an expressions to **{power} is not supported. Expressions can only be squared (**2).\"\n    )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__radd__","title":"<code>__radd__(other)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __radd__(self, other):\n    return self.to_expr() + other\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__rmul__","title":"<code>__rmul__(other)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __rmul__(self, other):\n    return self.to_expr() * other\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__rsub__","title":"<code>__rsub__(other)</code>","text":"<p>Support right subtraction.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable({\"dim1\": [1, 2, 3]})\n&gt;&gt;&gt; 1 - m.v\n&lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n[1]: 1  - v[1]\n[2]: 1  - v[2]\n[3]: 1  - v[3]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __rsub__(self, other):\n    \"\"\"\n    Support right subtraction.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = Variable({\"dim1\": [1, 2, 3]})\n        &gt;&gt;&gt; 1 - m.v\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n        [1]: 1  - v[1]\n        [2]: 1  - v[2]\n        [3]: 1  - v[3]\n    \"\"\"\n    return other + (-self.to_expr())\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__sub__","title":"<code>__sub__(other)</code>","text":"<p>import polars as pl m = pf.Model() df = pl.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]}) m.v = pf.Variable(df[\"dim1\"]) m.v - df  [1]: v[1] -1 [2]: v[2] -2 [3]: v[3] -3 Source code in <code>pyoframe/core.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"\n    &gt;&gt;&gt; import polars as pl\n    &gt;&gt;&gt; m = pf.Model()\n    &gt;&gt;&gt; df = pl.DataFrame({\"dim1\": [1, 2, 3], \"value\": [1, 2, 3]})\n    &gt;&gt;&gt; m.v = pf.Variable(df[\"dim1\"])\n    &gt;&gt;&gt; m.v - df\n    &lt;Expression size=3 dimensions={'dim1': 3} terms=6&gt;\n    [1]: v[1] -1\n    [2]: v[2] -2\n    [3]: v[3] -3\n    \"\"\"\n    if not isinstance(other, (int, float)):\n        other = other.to_expr()\n    return self.to_expr() + (-other)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Examples:</p> <p>Support division.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = Variable({\"dim1\": [1, 2, 3]})\n&gt;&gt;&gt; m.v / 2\n&lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt;\n[1]: 0.5 v[1]\n[2]: 0.5 v[2]\n[3]: 0.5 v[3]\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"\n\n    Examples:\n        Support division.\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = Variable({\"dim1\": [1, 2, 3]})\n        &gt;&gt;&gt; m.v / 2\n        &lt;Expression size=3 dimensions={'dim1': 3} terms=3&gt;\n        [1]: 0.5 v[1]\n        [2]: 0.5 v[2]\n        [3]: 0.5 v[3]\n    \"\"\"\n    return self.to_expr() * (1 / other)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.add_dim","title":"<code>add_dim(*dims)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def add_dim(self, *dims: str):\n    self.allowed_new_dims.extend(dims)\n    return self\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.drop_unmatched","title":"<code>drop_unmatched()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def drop_unmatched(self):\n    self.unmatched_strategy = UnmatchedStrategy.DROP\n    return self\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.keep_unmatched","title":"<code>keep_unmatched()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def keep_unmatched(self):\n    self.unmatched_strategy = UnmatchedStrategy.KEEP\n    return self\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsMath.to_expr","title":"<code>to_expr()</code>  <code>abstractmethod</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>@abstractmethod\ndef to_expr(self) -&gt; \"Expression\": ...\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.SupportsToExpr","title":"<code>SupportsToExpr</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> Name Description <code>to_expr</code>"},{"location":"reference/internal/core/#pyoframe.core.SupportsToExpr.to_expr","title":"<code>to_expr()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_expr(self) -&gt; \"Expression\": ...\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Variable","title":"<code>Variable(*indexing_sets, lb=None, ub=None, vtype=VType.CONTINUOUS, equals=None)</code>","text":"<p>               Bases: <code>ModelElementWithId</code>, <code>SupportsMath</code>, <code>SupportPolarsMethodMixin</code></p> <p>Represents one or many decision variable in an optimization model.</p> <p>Parameters:</p> Name Type Description Default <code>*indexing_sets</code> <code>SetTypes | Iterable[SetTypes]</code> <p>If no indexing_sets are provided, a single variable with no dimensions is created. Otherwise, a variable is created for each element in the Cartesian product of the indexing_sets (see Set for details on behaviour).</p> <code>()</code> <code>lb</code> <code>float | int | SupportsToExpr | None</code> <p>The lower bound for all variables.</p> <code>None</code> <code>ub</code> <code>float | int | SupportsToExpr | None</code> <p>The upper bound for all variables.</p> <code>None</code> <code>vtype</code> <code>VType | VTypeValue</code> <p>The type of the variable. Can be either a VType enum or a string. Default is VType.CONTINUOUS.</p> <code>CONTINUOUS</code> <code>equals</code> <code>Optional[SupportsMath]</code> <p>When specified, a variable is created and a constraint is added to make the variable equal to the provided expression.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; df = pd.DataFrame(\n...     {\"dim1\": [1, 1, 2, 2, 3, 3], \"dim2\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]}\n... )\n&gt;&gt;&gt; v = Variable(df)\n&gt;&gt;&gt; v\n&lt;Variable size=6 dimensions={'dim1': 3, 'dim2': 2} added_to_model=False&gt;\n</code></pre> <p>Variables cannot be used until they're added to the model.</p> <pre><code>&gt;&gt;&gt; m.constraint = v &lt;= 3\nTraceback (most recent call last):\n...\nValueError: Cannot use 'Variable' before it has beed added to a model.\n&gt;&gt;&gt; m.v = v\n&gt;&gt;&gt; m.constraint = m.v &lt;= 3\n</code></pre> <pre><code>&gt;&gt;&gt; m.v\n&lt;Variable name=v size=6 dimensions={'dim1': 3, 'dim2': 2}&gt;\n[1,a]: v[1,a]\n[1,b]: v[1,b]\n[2,a]: v[2,a]\n[2,b]: v[2,b]\n[3,a]: v[3,a]\n[3,b]: v[3,b]\n&gt;&gt;&gt; m.v2 = Variable(df[[\"dim1\"]])\nTraceback (most recent call last):\n...\nValueError: Duplicate rows found in input data.\n&gt;&gt;&gt; m.v3 = Variable(df[[\"dim1\"]].drop_duplicates())\n&gt;&gt;&gt; m.v3\n&lt;Variable name=v3 size=3 dimensions={'dim1': 3}&gt;\n[1]: v3[1]\n[2]: v3[2]\n[3]: v3[3]\n</code></pre> <p>Methods:</p> Name Description <code>__repr__</code> <code>get_id_column_name</code> <code>next</code> <p>Creates an expression where the variable at each index is the next variable in the specified dimension.</p> <code>on_add_to_model</code> <code>to_expr</code> <p>Attributes:</p> Name Type Description <code>attr</code> <code>Container</code> <p>Allows reading and writing variable attributes similarly to Model.attr.</p> <code>solution</code> <p>Retrieve a variable's optimal value after the model has been solved.</p> <code>vtype</code> <code>VType</code> Source code in <code>pyoframe/core.py</code> <pre><code>def __init__(\n    self,\n    *indexing_sets: SetTypes | Iterable[SetTypes],\n    lb: float | int | SupportsToExpr | None = None,\n    ub: float | int | SupportsToExpr | None = None,\n    vtype: VType | VTypeValue = VType.CONTINUOUS,\n    equals: Optional[SupportsMath] = None,\n):\n    if equals is not None:\n        assert len(indexing_sets) == 0, (\n            \"Cannot specify both 'equals' and 'indexing_sets'\"\n        )\n        indexing_sets = (equals,)\n\n    data = Set(*indexing_sets).data if len(indexing_sets) &gt; 0 else pl.DataFrame()\n    super().__init__(data)\n\n    self.vtype: VType = VType(vtype)\n    self._attr = Container(self._set_attribute, self._get_attribute)\n    self._equals = equals\n\n    if lb is not None and not isinstance(lb, (float, int)):\n        self._lb_expr, self.lb = lb, None\n    else:\n        self._lb_expr, self.lb = None, lb\n    if ub is not None and not isinstance(ub, (float, int)):\n        self._ub_expr, self.ub = ub, None\n    else:\n        self._ub_expr, self.ub = None, ub\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Variable.attr","title":"<code>attr</code>  <code>property</code>","text":"<p>Allows reading and writing variable attributes similarly to Model.attr.</p>"},{"location":"reference/internal/core/#pyoframe.core.Variable.solution","title":"<code>solution</code>  <code>property</code>","text":"<p>Retrieve a variable's optimal value after the model has been solved. Returned as a DataFrame if the variable has dimensions, otherwise as a single value. Binary and integer variables are returned as integers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.var_continuous = pf.Variable({\"dim1\": [1, 2, 3]}, lb=5, ub=5)\n&gt;&gt;&gt; m.var_integer = pf.Variable(\n...     {\"dim1\": [1, 2, 3]}, lb=4.5, ub=5.5, vtype=VType.INTEGER\n... )\n&gt;&gt;&gt; m.var_dimensionless = pf.Variable(lb=4.5, ub=5.5, vtype=VType.INTEGER)\n&gt;&gt;&gt; m.var_continuous.solution\nTraceback (most recent call last):\n...\nRuntimeError: Failed to retrieve solution for variable. Are you sure the model has been solved?\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.var_continuous.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5.0      \u2502\n\u2502 2    \u2506 5.0      \u2502\n\u2502 3    \u2506 5.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.var_integer.solution\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 solution \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5        \u2502\n\u2502 2    \u2506 5        \u2502\n\u2502 3    \u2506 5        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; m.var_dimensionless.solution\n5\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Variable.vtype","title":"<code>vtype = VType(vtype)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/core/#pyoframe.core.Variable.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def __repr__(self):\n    if self._has_ids:\n        return (\n            get_obj_repr(\n                self,\n                (\"name\", \"lb\", \"ub\"),\n                size=self.data.height,\n                dimensions=self.shape,\n            )\n            + \"\\n\"\n            + self.to_expr().to_str()\n        )\n    else:\n        return get_obj_repr(\n            self,\n            (\"name\", \"lb\", \"ub\"),\n            size=self.data.height,\n            dimensions=self.shape,\n            added_to_model=False,\n        )\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Variable.get_id_column_name","title":"<code>get_id_column_name()</code>  <code>classmethod</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>@classmethod\ndef get_id_column_name(cls):\n    return VAR_KEY\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Variable.next","title":"<code>next(dim, wrap_around=False)</code>","text":"<p>Creates an expression where the variable at each index is the next variable in the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>str</code> <p>The dimension over which to shift the variable.</p> required <code>wrap_around</code> <code>bool</code> <p>If True, the last index in the dimension is connected to the first index.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n&gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n&gt;&gt;&gt; # Fails because the dimensions are not the same\n&gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\nTraceback (most recent call last):\n...\npyoframe.constants.PyoframeError: Failed to add expressions:\n&lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\nDue to error:\nDataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n\u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n\u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n\u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\n...     \"time\"\n... )\n&lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n</code></pre> <pre><code>&gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\n...     \"time\", wrap_around=True\n... )\n&lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n[00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n[00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n[06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n[06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n[12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n[12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n[18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n[18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n</code></pre> Source code in <code>pyoframe/core.py</code> <pre><code>def next(self, dim: str, wrap_around: bool = False) -&gt; Expression:\n    \"\"\"\n    Creates an expression where the variable at each index is the next variable in the specified dimension.\n\n    Parameters:\n        dim:\n            The dimension over which to shift the variable.\n        wrap_around:\n            If True, the last index in the dimension is connected to the first index.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; time_dim = pd.DataFrame({\"time\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]})\n        &gt;&gt;&gt; space_dim = pd.DataFrame({\"city\": [\"Toronto\", \"Berlin\"]})\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.bat_charge = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; m.bat_flow = pf.Variable(time_dim, space_dim)\n        &gt;&gt;&gt; # Fails because the dimensions are not the same\n        &gt;&gt;&gt; m.bat_charge + m.bat_flow == m.bat_charge.next(\"time\")\n        Traceback (most recent call last):\n        ...\n        pyoframe.constants.PyoframeError: Failed to add expressions:\n        &lt;Expression size=8 dimensions={'time': 4, 'city': 2} terms=16&gt; + &lt;Expression size=6 dimensions={'city': 2, 'time': 3} terms=6&gt;\n        Due to error:\n        Dataframe has unmatched values. If this is intentional, use .drop_unmatched() or .keep_unmatched()\n        shape: (2, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 time  \u2506 city    \u2506 time_right \u2506 city_right \u2502\n        \u2502 ---   \u2506 ---     \u2506 ---        \u2506 ---        \u2502\n        \u2502 str   \u2506 str     \u2506 str        \u2506 str        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 18:00 \u2506 Toronto \u2506 null       \u2506 null       \u2502\n        \u2502 18:00 \u2506 Berlin  \u2506 null       \u2506 null       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow).drop_unmatched() == m.bat_charge.next(\n        ...     \"time\"\n        ... )\n        &lt;Constraint sense='=' size=6 dimensions={'time': 3, 'city': 2} terms=18&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n\n        &gt;&gt;&gt; (m.bat_charge + m.bat_flow) == m.bat_charge.next(\n        ...     \"time\", wrap_around=True\n        ... )\n        &lt;Constraint sense='=' size=8 dimensions={'time': 4, 'city': 2} terms=24&gt;\n        [00:00,Berlin]: bat_charge[00:00,Berlin] + bat_flow[00:00,Berlin] - bat_charge[06:00,Berlin] = 0\n        [00:00,Toronto]: bat_charge[00:00,Toronto] + bat_flow[00:00,Toronto] - bat_charge[06:00,Toronto] = 0\n        [06:00,Berlin]: bat_charge[06:00,Berlin] + bat_flow[06:00,Berlin] - bat_charge[12:00,Berlin] = 0\n        [06:00,Toronto]: bat_charge[06:00,Toronto] + bat_flow[06:00,Toronto] - bat_charge[12:00,Toronto] = 0\n        [12:00,Berlin]: bat_charge[12:00,Berlin] + bat_flow[12:00,Berlin] - bat_charge[18:00,Berlin] = 0\n        [12:00,Toronto]: bat_charge[12:00,Toronto] + bat_flow[12:00,Toronto] - bat_charge[18:00,Toronto] = 0\n        [18:00,Berlin]: bat_charge[18:00,Berlin] + bat_flow[18:00,Berlin] - bat_charge[00:00,Berlin] = 0\n        [18:00,Toronto]: bat_charge[18:00,Toronto] + bat_flow[18:00,Toronto] - bat_charge[00:00,Toronto] = 0\n    \"\"\"\n\n    wrapped = self.data.select(dim).unique(maintain_order=True).sort(by=dim)\n    wrapped = wrapped.with_columns(pl.col(dim).shift(-1).alias(\"__next\"))\n    if wrap_around:\n        wrapped = wrapped.with_columns(pl.col(\"__next\").fill_null(pl.first(dim)))\n    else:\n        wrapped = wrapped.drop_nulls(dim)\n\n    expr = self.to_expr()\n    data = expr.data.rename({dim: \"__prev\"})\n\n    data = data.join(\n        wrapped, left_on=\"__prev\", right_on=\"__next\", how=\"inner\"\n    ).drop([\"__prev\", \"__next\"], strict=False)\n    return expr._new(data)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Variable.on_add_to_model","title":"<code>on_add_to_model(model, name)</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def on_add_to_model(self, model, name):\n    super().on_add_to_model(model, name)\n    self._assign_ids()\n    if self._lb_expr is not None:\n        setattr(model, f\"{name}_lb\", self._lb_expr &lt;= self)\n\n    if self._ub_expr is not None:\n        setattr(model, f\"{name}_ub\", self &lt;= self._ub_expr)\n\n    if self._equals is not None:\n        setattr(model, f\"{name}_equals\", self == self._equals)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.Variable.to_expr","title":"<code>to_expr()</code>","text":"Source code in <code>pyoframe/core.py</code> <pre><code>def to_expr(self) -&gt; Expression:\n    self._assert_has_ids()\n    return self._new(self.data.drop(SOLUTION_KEY, strict=False))\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.sum","title":"<code>sum(over, expr=None)</code>","text":"<pre><code>sum(over: Union[str, Sequence[str]], expr: SupportsToExpr) -&gt; 'Expression'\n</code></pre><pre><code>sum(over: SupportsToExpr) -&gt; 'Expression'\n</code></pre> <p>Sum an expression over specified dimensions. If no dimensions are specified, the sum is taken over all of the expression's dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = pl.DataFrame(\n...     {\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"place\": [\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Vancouver\",\n...             \"Vancouver\",\n...         ],\n...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n...     }\n... ).to_expr()\n&gt;&gt;&gt; expr\n&lt;Expression size=5 dimensions={'time': 3, 'place': 2} terms=5&gt;\n[mon,Toronto]: 1000000\n[tue,Toronto]: 3000000\n[wed,Toronto]: 2000000\n[mon,Vancouver]: 1000000\n[tue,Vancouver]: 2000000\n&gt;&gt;&gt; pf.sum(\"time\", expr)\n&lt;Expression size=2 dimensions={'place': 2} terms=2&gt;\n[Toronto]: 6000000\n[Vancouver]: 3000000\n&gt;&gt;&gt; pf.sum(expr)\n&lt;Expression size=1 dimensions={} terms=1&gt;\n9000000\n</code></pre> <p>If the given dimensions don't exist, an error will be raised:</p> <pre><code>&gt;&gt;&gt; pf.sum(\"city\", expr)\nTraceback (most recent call last):\n...\nAssertionError: Cannot sum over ['city'] as it is not in ['time', 'place']\n</code></pre> See also <p>pyoframe.sum_by for summing over all dimensions except those that are specified.</p> Source code in <code>pyoframe/core.py</code> <pre><code>def sum(\n    over: Union[str, Sequence[str], SupportsToExpr],\n    expr: Optional[SupportsToExpr] = None,\n) -&gt; \"Expression\":\n    \"\"\"\n    Sum an expression over specified dimensions.\n    If no dimensions are specified, the sum is taken over all of the expression's dimensions.\n\n    Examples:\n        &gt;&gt;&gt; expr = pl.DataFrame(\n        ...     {\n        ...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n        ...         \"place\": [\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Vancouver\",\n        ...             \"Vancouver\",\n        ...         ],\n        ...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n        ...     }\n        ... ).to_expr()\n        &gt;&gt;&gt; expr\n        &lt;Expression size=5 dimensions={'time': 3, 'place': 2} terms=5&gt;\n        [mon,Toronto]: 1000000\n        [tue,Toronto]: 3000000\n        [wed,Toronto]: 2000000\n        [mon,Vancouver]: 1000000\n        [tue,Vancouver]: 2000000\n        &gt;&gt;&gt; pf.sum(\"time\", expr)\n        &lt;Expression size=2 dimensions={'place': 2} terms=2&gt;\n        [Toronto]: 6000000\n        [Vancouver]: 3000000\n        &gt;&gt;&gt; pf.sum(expr)\n        &lt;Expression size=1 dimensions={} terms=1&gt;\n        9000000\n\n        If the given dimensions don't exist, an error will be raised:\n\n        &gt;&gt;&gt; pf.sum(\"city\", expr)\n        Traceback (most recent call last):\n        ...\n        AssertionError: Cannot sum over ['city'] as it is not in ['time', 'place']\n\n    See also:\n        [pyoframe.sum_by][] for summing over all dimensions _except_ those that are specified.\n    \"\"\"\n    if expr is None:\n        assert isinstance(over, SupportsMath)\n        over = over.to_expr()\n        all_dims = over.dimensions\n        if all_dims is None:\n            raise ValueError(\n                \"Cannot sum over dimensions with an expression with no dimensions.\"\n            )\n        return over.sum(all_dims)\n    else:\n        assert isinstance(over, (str, Sequence))\n        return expr.to_expr().sum(over)\n</code></pre>"},{"location":"reference/internal/core/#pyoframe.core.sum_by","title":"<code>sum_by(by, expr)</code>","text":"<p>Like <code>pf.sum()</code>, but the sum is taken over all dimensions except those specified in <code>by</code> (just like a <code>group_by</code> operation).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expr = pl.DataFrame(\n...     {\n...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n...         \"place\": [\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Toronto\",\n...             \"Vancouver\",\n...             \"Vancouver\",\n...         ],\n...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n...     }\n... ).to_expr()\n&gt;&gt;&gt; expr\n&lt;Expression size=5 dimensions={'time': 3, 'place': 2} terms=5&gt;\n[mon,Toronto]: 1000000\n[tue,Toronto]: 3000000\n[wed,Toronto]: 2000000\n[mon,Vancouver]: 1000000\n[tue,Vancouver]: 2000000\n&gt;&gt;&gt; pf.sum_by(\"place\", expr)\n&lt;Expression size=2 dimensions={'place': 2} terms=2&gt;\n[Toronto]: 6000000\n[Vancouver]: 3000000\n&gt;&gt;&gt; total_sum = pf.sum_by([], expr)\n&gt;&gt;&gt; total_sum\n&lt;Expression size=1 dimensions={} terms=1&gt;\n9000000\n</code></pre> <p>If the specified dimensions don't exist, an error will be raised:</p> <pre><code>&gt;&gt;&gt; pf.sum_by(\"city\", expr)\nTraceback (most recent call last):\n...\nAssertionError: Cannot sum by ['city'] because the expression's dimensions are ['time', 'place'].\n</code></pre> <pre><code>&gt;&gt;&gt; pf.sum_by(\"time\", total_sum)\nTraceback (most recent call last):\n...\nAssertionError: Cannot sum by ['time'] because the expression has no dimensions.\n</code></pre> See also <p>pyoframe.sum for summing over specified dimensions.</p> Source code in <code>pyoframe/core.py</code> <pre><code>def sum_by(by: Union[str, Sequence[str]], expr: SupportsToExpr) -&gt; \"Expression\":\n    \"\"\"\n    Like [`pf.sum()`][pyoframe.sum], but the sum is taken over all dimensions except those specified in `by` (just like a `group_by` operation).\n\n    Examples:\n        &gt;&gt;&gt; expr = pl.DataFrame(\n        ...     {\n        ...         \"time\": [\"mon\", \"tue\", \"wed\", \"mon\", \"tue\"],\n        ...         \"place\": [\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Toronto\",\n        ...             \"Vancouver\",\n        ...             \"Vancouver\",\n        ...         ],\n        ...         \"tiktok_posts\": [1e6, 3e6, 2e6, 1e6, 2e6],\n        ...     }\n        ... ).to_expr()\n        &gt;&gt;&gt; expr\n        &lt;Expression size=5 dimensions={'time': 3, 'place': 2} terms=5&gt;\n        [mon,Toronto]: 1000000\n        [tue,Toronto]: 3000000\n        [wed,Toronto]: 2000000\n        [mon,Vancouver]: 1000000\n        [tue,Vancouver]: 2000000\n        &gt;&gt;&gt; pf.sum_by(\"place\", expr)\n        &lt;Expression size=2 dimensions={'place': 2} terms=2&gt;\n        [Toronto]: 6000000\n        [Vancouver]: 3000000\n        &gt;&gt;&gt; total_sum = pf.sum_by([], expr)\n        &gt;&gt;&gt; total_sum\n        &lt;Expression size=1 dimensions={} terms=1&gt;\n        9000000\n\n        If the specified dimensions don't exist, an error will be raised:\n\n        &gt;&gt;&gt; pf.sum_by(\"city\", expr)\n        Traceback (most recent call last):\n        ...\n        AssertionError: Cannot sum by ['city'] because the expression's dimensions are ['time', 'place'].\n\n        &gt;&gt;&gt; pf.sum_by(\"time\", total_sum)\n        Traceback (most recent call last):\n        ...\n        AssertionError: Cannot sum by ['time'] because the expression has no dimensions.\n\n    See also:\n        [pyoframe.sum][] for summing over specified dimensions.\n    \"\"\"\n    if isinstance(by, str):\n        by = [by]\n    expr = expr.to_expr()\n    dimensions = expr.dimensions\n    assert dimensions is not None, (\n        f\"Cannot sum by {by} because the expression has no dimensions.\"\n    )\n    assert set(by) &lt;= set(dimensions), (\n        f\"Cannot sum by {by} because the expression's dimensions are {dimensions}.\"\n    )\n    remaining_dims = [dim for dim in dimensions if dim not in by]\n    return sum(over=remaining_dims, expr=expr)\n</code></pre>"},{"location":"reference/internal/model/","title":"model","text":"<p>Classes:</p> Name Description <code>Model</code> <p>The object that holds all the variables, constraints, and the objective.</p>"},{"location":"reference/internal/model/#pyoframe.model.Model","title":"<code>Model(name=None, solver=None, solver_env=None, use_var_names=False, sense=None)</code>","text":"<p>The object that holds all the variables, constraints, and the objective.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the model. Currently it is not used for much.</p> <code>None</code> <code>solver</code> <code>SUPPORTED_SOLVER_TYPES | Solver | None</code> <p>The solver to use. If <code>None</code>, <code>Config.default_solver</code> will be used. If <code>Config.default_solver</code> has not been set (<code>None</code>), Pyoframe will try to detect whichever solver is already installed.</p> <code>None</code> <code>solver_env</code> <code>Optional[Dict[str, str]]</code> <p>Gurobi only: a dictionary of parameters to set when creating the Gurobi environment.</p> <code>None</code> <code>use_var_names</code> <code>bool</code> <p>Whether to pass variable names to the solver. Set to <code>True</code> if you'd like outputs from e.g. <code>Model.write()</code> to be legible. Does not work with HiGHS (see here).</p> <code>False</code> <code>sense</code> <code>Union[ObjSense, ObjSenseValue, None]</code> <p>Either \"min\" or \"max\". Indicates whether it's a minmization or maximization problem. Typically, this parameter can be omitted (<code>None</code>) as it will automatically be set when the objective is set using <code>.minimize</code> or <code>.maximize</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable()\n&gt;&gt;&gt; m.my_constraint = m.X &lt;= 10\n&gt;&gt;&gt; m\n&lt;Model vars=1 constrs=1 objective=False&gt;\n</code></pre> <p>Try setting the Gurobi license:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\n...     solver=\"gurobi\",\n...     solver_env=dict(ComputeServer=\"myserver\", ServerPassword=\"mypassword\"),\n... )\nTraceback (most recent call last):\n...\nRuntimeError: Could not resolve host: myserver (code 6, command POST http://myserver/api/v1/cluster/jobs)\n</code></pre> <p>Methods:</p> Name Description <code>__del__</code> <code>__repr__</code> <code>__setattr__</code> <code>compute_IIS</code> <p>Computes the Irreducible Infeasible Set (IIS) of the model.</p> <code>convert_to_fixed</code> <p>Turns a mixed integer program into a continuous one by fixing</p> <code>create_poi_model</code> <code>dispose</code> <p>Disposes of the model and cleans up the solver environment.</p> <code>optimize</code> <p>Optimize the model using your selected solver (e.g. Gurobi, HiGHS).</p> <code>write</code> <p>Output the model to a file.</p> <p>Attributes:</p> Name Type Description <code>attr</code> <p>An object that allows reading and writing model attributes.</p> <code>binary_variables</code> <code>Iterable[Variable]</code> <p>Examples:</p> <code>constraints</code> <code>integer_variables</code> <code>Iterable[Variable]</code> <p>Examples:</p> <code>maximize</code> <code>minimize</code> <code>name</code> <code>objective</code> <code>params</code> <code>Container</code> <p>An object that allows reading and writing solver-specific parameters.</p> <code>sense</code> <code>solver_name</code> <code>use_var_names</code> <code>var_map</code> <code>variables</code> <code>List[Variable]</code> Source code in <code>pyoframe/model.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    solver: SUPPORTED_SOLVER_TYPES | Solver | None = None,\n    solver_env: Optional[Dict[str, str]] = None,\n    use_var_names: bool = False,\n    sense: Union[ObjSense, ObjSenseValue, None] = None,\n):\n    self.poi, self.solver = Model.create_poi_model(solver, solver_env)\n    self.solver_name = self.solver.name\n    self._variables: List[Variable] = []\n    self._constraints: List[Constraint] = []\n    self.sense = ObjSense(sense) if sense is not None else None\n    self._objective: Optional[Objective] = None\n    self.var_map = (\n        NamedVariableMapper(Variable) if Config.print_uses_variable_names else None\n    )\n    self.name = name\n\n    self._params = Container(self._set_param, self._get_param)\n    self._attr = Container(self._set_attr, self._get_attr)\n    self._use_var_names = use_var_names\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.attr","title":"<code>attr</code>  <code>property</code>","text":"<p>An object that allows reading and writing model attributes.</p> <p>Several model attributes are common across all solvers making it easy to switch between solvers (see supported attributes for Gurobi, HiGHS, and Ipopt).</p> <p>We additionally support all of Gurobi's attributes when using Gurobi.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable(lb=1, ub=1, vtype=\"integer\")\n&gt;&gt;&gt; m.attr.Silent = True  # Prevent solver output from being printed\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus\n&lt;TerminationStatusCode.OPTIMAL: 2&gt;\n</code></pre> <p>Some attributes, like <code>NumVars</code>, are solver-specific.</p> <pre><code>&gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n&gt;&gt;&gt; m.attr.NumConstrs\n0\n&gt;&gt;&gt; m = pf.Model(solver=\"highs\")\n&gt;&gt;&gt; m.attr.NumConstrs\nTraceback (most recent call last):\n...\nKeyError: 'NumConstrs'\n</code></pre> See also <p>Variable.attr for setting variable attributes and Constraint.attr for setting constraint attributes.</p>"},{"location":"reference/internal/model/#pyoframe.model.Model.binary_variables","title":"<code>binary_variables</code>  <code>property</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.binary_variables))\n1\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.constraints","title":"<code>constraints</code>  <code>property</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.integer_variables","title":"<code>integer_variables</code>  <code>property</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.INTEGER)\n&gt;&gt;&gt; m.Y = pf.Variable()\n&gt;&gt;&gt; len(list(m.integer_variables))\n1\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.maximize","title":"<code>maximize</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.minimize","title":"<code>minimize</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.objective","title":"<code>objective</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.params","title":"<code>params</code>  <code>property</code>","text":"<p>An object that allows reading and writing solver-specific parameters.</p> <p>See the list of available parameters for Gurobi, HiGHS, and Ipopt.</p> <p>Examples:</p> <p>For example, if you'd like to use Gurobi's barrier method, you can set the <code>Method</code> parameter:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n&gt;&gt;&gt; m.params.Method = 2\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.sense","title":"<code>sense = ObjSense(sense) if sense is not None else None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.solver_name","title":"<code>solver_name = self.solver.name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.use_var_names","title":"<code>use_var_names</code>  <code>property</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.var_map","title":"<code>var_map = NamedVariableMapper(Variable) if Config.print_uses_variable_names else None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.variables","title":"<code>variables</code>  <code>property</code>","text":""},{"location":"reference/internal/model/#pyoframe.model.Model.__del__","title":"<code>__del__()</code>","text":"Source code in <code>pyoframe/model.py</code> <pre><code>def __del__(self):\n    # This ensures that the model is closed *before* the environment is. This avoids the Gurobi warning:\n    #   Warning: environment still referenced so free is deferred (Continue to use WLS)\n    # I include the hasattr check to avoid errors in case __init__ failed and poi was never set.\n    if hasattr(self, \"poi\"):\n        self.poi.close()\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pyoframe/model.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return get_obj_repr(\n        self,\n        name=self.name,\n        vars=len(self.variables),\n        constrs=len(self.constraints),\n        objective=bool(self.objective),\n    )\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.__setattr__","title":"<code>__setattr__(__name, __value)</code>","text":"Source code in <code>pyoframe/model.py</code> <pre><code>def __setattr__(self, __name: str, __value: Any) -&gt; None:\n    if __name not in Model._reserved_attributes and not isinstance(\n        __value, (ModelElement, pl.DataFrame, pd.DataFrame)\n    ):\n        raise PyoframeError(\n            f\"Cannot set attribute '{__name}' on the model because it isn't of type ModelElement (e.g. Variable, Constraint, ...)\"\n        )\n\n    if (\n        isinstance(__value, ModelElement)\n        and __name not in Model._reserved_attributes\n    ):\n        if isinstance(__value, ModelElementWithId):\n            assert not hasattr(self, __name), (\n                f\"Cannot create {__name} since it was already created.\"\n            )\n\n        __value.on_add_to_model(self, __name)\n\n        if isinstance(__value, Variable):\n            self._variables.append(__value)\n            if self.var_map is not None:\n                self.var_map.add(__value)\n        elif isinstance(__value, Constraint):\n            self._constraints.append(__value)\n    return super().__setattr__(__name, __value)\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.compute_IIS","title":"<code>compute_IIS()</code>","text":"<p>Computes the Irreducible Infeasible Set (IIS) of the model.</p> <p>Gurobi only</p> <p>This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n&gt;&gt;&gt; m.X = pf.Variable(lb=0, ub=2)\n&gt;&gt;&gt; m.Y = pf.Variable(lb=0, ub=2)\n&gt;&gt;&gt; m.bad_constraint = m.X &gt;= 3\n&gt;&gt;&gt; m.minimize = m.X + m.Y\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.attr.TerminationStatus\n&lt;TerminationStatusCode.INFEASIBLE: 3&gt;\n&gt;&gt;&gt; m.bad_constraint.attr.IIS\nTraceback (most recent call last):\n...\nRuntimeError: Unable to retrieve attribute 'IISConstr'\n&gt;&gt;&gt; m.compute_IIS()\n&gt;&gt;&gt; m.bad_constraint.attr.IIS\nTrue\n</code></pre> Source code in <code>pyoframe/model.py</code> <pre><code>@for_solvers(\"gurobi\", \"copt\")\ndef compute_IIS(self):\n    \"\"\"\n    Computes the Irreducible Infeasible Set (IIS) of the model.\n\n    !!! warning \"Gurobi only\"\n        This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.Y = pf.Variable(lb=0, ub=2)\n        &gt;&gt;&gt; m.bad_constraint = m.X &gt;= 3\n        &gt;&gt;&gt; m.minimize = m.X + m.Y\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.attr.TerminationStatus\n        &lt;TerminationStatusCode.INFEASIBLE: 3&gt;\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        Traceback (most recent call last):\n        ...\n        RuntimeError: Unable to retrieve attribute 'IISConstr'\n        &gt;&gt;&gt; m.compute_IIS()\n        &gt;&gt;&gt; m.bad_constraint.attr.IIS\n        True\n    \"\"\"\n    self.poi.computeIIS()\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.convert_to_fixed","title":"<code>convert_to_fixed()</code>","text":"<p>Turns a mixed integer program into a continuous one by fixing all the integer and binary variables to their solution values.</p> <p>Gurobi only</p> <p>This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n&gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0)\n&gt;&gt;&gt; m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0)\n&gt;&gt;&gt; m.Z = pf.Variable(lb=0)\n&gt;&gt;&gt; m.my_constraint = m.X + m.Y + m.Z &lt;= 10\n&gt;&gt;&gt; m.maximize = 3 * m.X + 2 * m.Y + m.Z\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.X.solution, m.Y.solution, m.Z.solution\n(1, 9, 0.0)\n&gt;&gt;&gt; m.my_constraint.dual\nTraceback (most recent call last):\n...\nRuntimeError: Unable to retrieve attribute 'Pi'\n&gt;&gt;&gt; m.convert_to_fixed()\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.my_constraint.dual\n1.0\n</code></pre> <p>Only works for Gurobi:</p> <pre><code>&gt;&gt;&gt; m = pf.Model(\"max\", solver=\"highs\")\n&gt;&gt;&gt; m.convert_to_fixed()\nTraceback (most recent call last):\n...\nNotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.\n</code></pre> Source code in <code>pyoframe/model.py</code> <pre><code>@for_solvers(\"gurobi\")\ndef convert_to_fixed(self) -&gt; None:\n    \"\"\"\n    Turns a mixed integer program into a continuous one by fixing\n    all the integer and binary variables to their solution values.\n\n    !!! warning \"Gurobi only\"\n        This method only works with the Gurobi solver. Open an issue if you'd like to see support for other solvers.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model(solver=\"gurobi\")\n        &gt;&gt;&gt; m.X = pf.Variable(vtype=pf.VType.BINARY, lb=0)\n        &gt;&gt;&gt; m.Y = pf.Variable(vtype=pf.VType.INTEGER, lb=0)\n        &gt;&gt;&gt; m.Z = pf.Variable(lb=0)\n        &gt;&gt;&gt; m.my_constraint = m.X + m.Y + m.Z &lt;= 10\n        &gt;&gt;&gt; m.maximize = 3 * m.X + 2 * m.Y + m.Z\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.X.solution, m.Y.solution, m.Z.solution\n        (1, 9, 0.0)\n        &gt;&gt;&gt; m.my_constraint.dual\n        Traceback (most recent call last):\n        ...\n        RuntimeError: Unable to retrieve attribute 'Pi'\n        &gt;&gt;&gt; m.convert_to_fixed()\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.my_constraint.dual\n        1.0\n\n        Only works for Gurobi:\n\n        &gt;&gt;&gt; m = pf.Model(\"max\", solver=\"highs\")\n        &gt;&gt;&gt; m.convert_to_fixed()\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: Method 'convert_to_fixed' is not implemented for solver 'highs'.\n    \"\"\"\n    self.poi._converttofixed()\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.create_poi_model","title":"<code>create_poi_model(solver, solver_env)</code>  <code>classmethod</code>","text":"Source code in <code>pyoframe/model.py</code> <pre><code>@classmethod\ndef create_poi_model(\n    cls, solver: Optional[str | Solver], solver_env: Optional[Dict[str, str]]\n):\n    if solver is None:\n        if Config.default_solver is None:\n            for solver_option in SUPPORTED_SOLVERS:\n                try:\n                    return cls.create_poi_model(solver_option, solver_env)\n                except RuntimeError:\n                    pass\n            raise ValueError(\n                'Could not automatically find a solver. Is one installed? If so, specify which one: e.g. Model(solver=\"gurobi\")'\n            )\n        else:\n            solver = Config.default_solver\n\n    if isinstance(solver, str):\n        solver = solver.lower()\n        for s in SUPPORTED_SOLVERS:\n            if s.name == solver:\n                solver = s\n                break\n        else:\n            raise ValueError(\n                f\"Unsupported solver: '{solver}'. Supported solvers are: {', '.join(s.name for s in SUPPORTED_SOLVERS)}.\"\n            )\n\n    if solver.name == \"gurobi\":\n        from pyoptinterface import gurobi\n\n        if solver_env is None:\n            env = gurobi.Env()\n        else:\n            env = gurobi.Env(empty=True)\n            for key, value in solver_env.items():\n                env.set_raw_parameter(key, value)\n            env.start()\n        model = gurobi.Model(env)\n    elif solver.name == \"highs\":\n        from pyoptinterface import highs\n\n        model = highs.Model()\n    elif solver.name == \"ipopt\":\n        try:\n            from pyoptinterface import ipopt\n        except ModuleNotFoundError as e:  # pragma: no cover\n            raise ModuleNotFoundError(\n                \"Failed to import the Ipopt solver. Did you run `pip install pyoptinterface[ipopt]`?\"\n            ) from e\n\n        try:\n            model = ipopt.Model()\n        except RuntimeError as e:  # pragma: no cover\n            if \"IPOPT library is not loaded\" in str(e):\n                raise RuntimeError(\n                    \"Could not find the Ipopt solver. Are you sure you've properly installed it and added it to your PATH?\"\n                ) from e\n            raise e\n    else:\n        raise ValueError(\n            f\"Solver {solver} not recognized or supported.\"\n        )  # pragma: no cover\n\n    constant_var = model.add_variable(lb=1, ub=1, name=\"ONE\")\n    if constant_var.index != CONST_TERM:\n        raise ValueError(\n            \"The first variable should have index 0.\"\n        )  # pragma: no cover\n    return model, solver\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.dispose","title":"<code>dispose()</code>","text":"<p>Disposes of the model and cleans up the solver environment.</p> <p>When using Gurobi compute server, this cleanup will ensure your run is not marked as 'ABORTED'.</p> <p>Note that once the model is disposed, it cannot be used anymore.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.X = pf.Variable(ub=1)\n&gt;&gt;&gt; m.maximize = m.X\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.X.solution\n1.0\n&gt;&gt;&gt; m.dispose()\n</code></pre> Source code in <code>pyoframe/model.py</code> <pre><code>def dispose(self):\n    \"\"\"\n    Disposes of the model and cleans up the solver environment.\n\n    When using Gurobi compute server, this cleanup will\n    ensure your run is not marked as 'ABORTED'.\n\n    Note that once the model is disposed, it cannot be used anymore.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.X = pf.Variable(ub=1)\n        &gt;&gt;&gt; m.maximize = m.X\n        &gt;&gt;&gt; m.optimize()\n        &gt;&gt;&gt; m.X.solution\n        1.0\n        &gt;&gt;&gt; m.dispose()\n    \"\"\"\n    env = None\n    if hasattr(self.poi, \"_env\"):\n        env = self.poi._env\n    self.poi.close()\n    if env is not None:\n        env.close()\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.optimize","title":"<code>optimize()</code>","text":"<p>Optimize the model using your selected solver (e.g. Gurobi, HiGHS).</p> Source code in <code>pyoframe/model.py</code> <pre><code>def optimize(self):\n    \"\"\"\n    Optimize the model using your selected solver (e.g. Gurobi, HiGHS).\n    \"\"\"\n    self.poi.optimize()\n</code></pre>"},{"location":"reference/internal/model/#pyoframe.model.Model.write","title":"<code>write(file_path, pretty=False)</code>","text":"<p>Output the model to a file.</p> <p>Typical usage includes writing the solution to a <code>.sol</code> file as well as writing the problem to a <code>.lp</code> or <code>.mps</code> file. Set <code>use_var_names</code> in your model constructor to <code>True</code> if you'd like the output to contain human-readable names (useful for debugging).</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[Path, str]</code> <p>The path to the file to write to.</p> required <code>pretty</code> <code>bool</code> <p>Only used when writing .sol files in HiGHS. If <code>True</code>, will use HiGH's pretty print columnar style which contains more information.</p> <code>False</code> Source code in <code>pyoframe/model.py</code> <pre><code>def write(self, file_path: Union[Path, str], pretty: bool = False):\n    \"\"\"\n    Output the model to a file.\n\n    Typical usage includes writing the solution to a `.sol` file as well as writing the problem to a `.lp` or `.mps` file.\n    Set `use_var_names` in your model constructor to `True` if you'd like the output to contain human-readable names (useful for debugging).\n\n    Parameters:\n        file_path:\n            The path to the file to write to.\n        pretty:\n            Only used when writing .sol files in HiGHS. If `True`, will use HiGH's pretty print columnar style which contains more information.\n    \"\"\"\n    self.solver.check_supports_write()\n\n    file_path = Path(file_path)\n    file_path.parent.mkdir(parents=True, exist_ok=True)\n\n    kwargs = {}\n    if self.solver.name == \"highs\":\n        if self.use_var_names:\n            self.params.write_solution_style = 1\n        kwargs[\"pretty\"] = pretty\n    self.poi.write(str(file_path), **kwargs)\n</code></pre>"},{"location":"reference/internal/model_element/","title":"model_element","text":"<p>Classes:</p> Name Description <code>ModelElement</code> <code>ModelElementWithId</code> <p>Provides a method that assigns a unique ID to each row in a DataFrame.</p> <code>SupportPolarsMethodMixin</code>"},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement","title":"<code>ModelElement(data, **kwargs)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>__len__</code> <code>on_add_to_model</code> <p>Attributes:</p> Name Type Description <code>data</code> <code>DataFrame</code> <code>dimensions</code> <code>Optional[List[str]]</code> <p>The names of the data's dimensions.</p> <code>dimensions_unsafe</code> <code>List[str]</code> <p>Same as <code>dimensions</code> but returns an empty list if there are no dimensions instead of None.</p> <code>friendly_name</code> <code>str</code> <code>name</code> <code>shape</code> <code>Dict[str, int]</code> <p>The number of indices in each dimension.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>def __init__(self, data: pl.DataFrame, **kwargs) -&gt; None:\n    # Sanity checks, no duplicate column names\n    assert len(data.columns) == len(set(data.columns)), (\n        \"Duplicate column names found.\"\n    )\n\n    cols = _get_dimensions(data)\n    if cols is None:\n        cols = []\n    cols += [col for col in RESERVED_COL_KEYS if col in data.columns]\n\n    # Reorder columns to keep things consistent\n    data = data.select(cols)\n\n    # Cast to proper dtype\n    if COEF_KEY in data.columns:\n        data = data.cast({COEF_KEY: pl.Float64})\n    if VAR_KEY in data.columns:\n        data = data.cast({VAR_KEY: KEY_TYPE})\n    if QUAD_VAR_KEY in data.columns:\n        data = data.cast({QUAD_VAR_KEY: KEY_TYPE})\n\n    self._data = data\n    self._model: Optional[Model] = None\n    self.name = None\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement.data","title":"<code>data</code>  <code>property</code>","text":""},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement.dimensions","title":"<code>dimensions</code>  <code>property</code>","text":"<p>The names of the data's dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # A variable with no dimensions\n&gt;&gt;&gt; pf.Variable().dimensions\n</code></pre> <pre><code>&gt;&gt;&gt; # A variable with dimensions of \"hour\" and \"city\"\n&gt;&gt;&gt; pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... ).dimensions\n['hour', 'city']\n</code></pre>"},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement.dimensions_unsafe","title":"<code>dimensions_unsafe</code>  <code>property</code>","text":"<p>Same as <code>dimensions</code> but returns an empty list if there are no dimensions instead of None. When unsure, use <code>dimensions</code> instead since the type checker forces users to handle the None case (no dimensions).</p>"},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement.friendly_name","title":"<code>friendly_name</code>  <code>property</code>","text":""},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement.name","title":"<code>name = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>The number of indices in each dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # A variable with no dimensions\n&gt;&gt;&gt; pf.Variable().shape\n{}\n&gt;&gt;&gt; # A variable with dimensions of \"hour\" and \"city\"\n&gt;&gt;&gt; pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... ).shape\n{'hour': 4, 'city': 3}\n</code></pre>"},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement.__len__","title":"<code>__len__()</code>","text":"Source code in <code>pyoframe/model_element.py</code> <pre><code>def __len__(self) -&gt; int:\n    dims = self.dimensions\n    if dims is None:\n        return 1\n    return self.data.select(dims).n_unique()\n</code></pre>"},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElement.on_add_to_model","title":"<code>on_add_to_model(model, name)</code>","text":"Source code in <code>pyoframe/model_element.py</code> <pre><code>def on_add_to_model(self, model: \"Model\", name: str):\n    self.name = name\n    self._model = model\n</code></pre>"},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElementWithId","title":"<code>ModelElementWithId(data, **kwargs)</code>","text":"<p>               Bases: <code>ModelElement</code></p> <p>Provides a method that assigns a unique ID to each row in a DataFrame. IDs start at 1 and go up consecutively. No zero ID is assigned since it is reserved for the constant variable term. IDs are only unique for the subclass since different subclasses have different counters.</p> <p>Methods:</p> Name Description <code>get_id_column_name</code> <p>Returns the name of the column containing the IDs.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>def __init__(self, data: pl.DataFrame, **kwargs) -&gt; None:\n    # Sanity checks, no duplicate column names\n    assert len(data.columns) == len(set(data.columns)), (\n        \"Duplicate column names found.\"\n    )\n\n    cols = _get_dimensions(data)\n    if cols is None:\n        cols = []\n    cols += [col for col in RESERVED_COL_KEYS if col in data.columns]\n\n    # Reorder columns to keep things consistent\n    data = data.select(cols)\n\n    # Cast to proper dtype\n    if COEF_KEY in data.columns:\n        data = data.cast({COEF_KEY: pl.Float64})\n    if VAR_KEY in data.columns:\n        data = data.cast({VAR_KEY: KEY_TYPE})\n    if QUAD_VAR_KEY in data.columns:\n        data = data.cast({QUAD_VAR_KEY: KEY_TYPE})\n\n    self._data = data\n    self._model: Optional[Model] = None\n    self.name = None\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/internal/model_element/#pyoframe.model_element.ModelElementWithId.get_id_column_name","title":"<code>get_id_column_name()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Returns the name of the column containing the IDs.</p> Source code in <code>pyoframe/model_element.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_id_column_name(cls) -&gt; str:\n    \"\"\"\n    Returns the name of the column containing the IDs.\n    \"\"\"\n</code></pre>"},{"location":"reference/internal/model_element/#pyoframe.model_element.SupportPolarsMethodMixin","title":"<code>SupportPolarsMethodMixin</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>pick</code> <p>Filters elements by the given criteria and then drops the filtered dimensions.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>estimated_size</code> <code>filter</code> <code>rename</code> <code>with_columns</code>"},{"location":"reference/internal/model_element/#pyoframe.model_element.SupportPolarsMethodMixin.data","title":"<code>data</code>  <code>abstractmethod</code> <code>property</code>","text":""},{"location":"reference/internal/model_element/#pyoframe.model_element.SupportPolarsMethodMixin.estimated_size","title":"<code>estimated_size = _support_polars_method('estimated_size')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/model_element/#pyoframe.model_element.SupportPolarsMethodMixin.filter","title":"<code>filter = _support_polars_method('filter')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/model_element/#pyoframe.model_element.SupportPolarsMethodMixin.rename","title":"<code>rename = _support_polars_method('rename')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/model_element/#pyoframe.model_element.SupportPolarsMethodMixin.with_columns","title":"<code>with_columns = _support_polars_method('with_columns')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/model_element/#pyoframe.model_element.SupportPolarsMethodMixin.pick","title":"<code>pick(**kwargs)</code>","text":"<p>Filters elements by the given criteria and then drops the filtered dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.v = pf.Variable(\n...     [\n...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n...     ]\n... )\n&gt;&gt;&gt; m.v.pick(hour=\"06:00\")\n&lt;Expression size=3 dimensions={'city': 3} terms=3&gt;\n[Toronto]: v[06:00,Toronto]\n[Berlin]: v[06:00,Berlin]\n[Paris]: v[06:00,Paris]\n&gt;&gt;&gt; m.v.pick(hour=\"06:00\", city=\"Toronto\")\n&lt;Expression size=1 dimensions={} terms=1&gt;\nv[06:00,Toronto]\n</code></pre> Source code in <code>pyoframe/model_element.py</code> <pre><code>def pick(self, **kwargs):\n    \"\"\"\n    Filters elements by the given criteria and then drops the filtered dimensions.\n\n    Examples:\n        &gt;&gt;&gt; m = pf.Model()\n        &gt;&gt;&gt; m.v = pf.Variable(\n        ...     [\n        ...         {\"hour\": [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]},\n        ...         {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]},\n        ...     ]\n        ... )\n        &gt;&gt;&gt; m.v.pick(hour=\"06:00\")\n        &lt;Expression size=3 dimensions={'city': 3} terms=3&gt;\n        [Toronto]: v[06:00,Toronto]\n        [Berlin]: v[06:00,Berlin]\n        [Paris]: v[06:00,Paris]\n        &gt;&gt;&gt; m.v.pick(hour=\"06:00\", city=\"Toronto\")\n        &lt;Expression size=1 dimensions={} terms=1&gt;\n        v[06:00,Toronto]\n    \"\"\"\n    return self._new(self.data.filter(**kwargs).drop(kwargs.keys()))\n</code></pre>"},{"location":"reference/internal/monkey_patch/","title":"monkey_patch","text":"<p>Functions:</p> Name Description <code>patch_dataframe_libraries</code> <p>Applies two patches to the DataFrame and Series classes of both pandas and polars.</p>"},{"location":"reference/internal/monkey_patch/#pyoframe.monkey_patch.patch_dataframe_libraries","title":"<code>patch_dataframe_libraries()</code>","text":"<p>Applies two patches to the DataFrame and Series classes of both pandas and polars. 1) Patches arithmetic operators (e.g. <code>__add__</code>) such that operations between DataFrames/Series and <code>Expressionable</code>s     are not supported (i.e. <code>return NotImplemented</code>). This leads Python to try the reverse operation (e.g. <code>__radd__</code>)     which is supported by the <code>Expressionable</code> class. 2) Adds a <code>to_expr</code> method to DataFrame/Series that allows them to be converted to an <code>Expression</code> object.     Series become dataframes and dataframes become expressions where everything but the last column are treated as dimensions.</p> Source code in <code>pyoframe/monkey_patch.py</code> <pre><code>def patch_dataframe_libraries():\n    \"\"\"\n    Applies two patches to the DataFrame and Series classes of both pandas and polars.\n    1) Patches arithmetic operators (e.g. `__add__`) such that operations between DataFrames/Series and `Expressionable`s\n        are not supported (i.e. `return NotImplemented`). This leads Python to try the reverse operation (e.g. `__radd__`)\n        which is supported by the `Expressionable` class.\n    2) Adds a `to_expr` method to DataFrame/Series that allows them to be converted to an `Expression` object.\n        Series become dataframes and dataframes become expressions where everything but the last column are treated as dimensions.\n    \"\"\"\n    _patch_class(pd.DataFrame)\n    _patch_class(pd.Series)\n    _patch_class(pl.DataFrame)\n    _patch_class(pl.Series)\n    pl.DataFrame.to_expr = _dataframe_to_expr\n    pl.Series.to_expr = lambda self: self.to_frame().to_expr()\n    pd.DataFrame.to_expr = lambda self: pl.from_pandas(self).to_expr()\n    pd.Series.to_expr = lambda self: self.to_frame().reset_index().to_expr()\n</code></pre>"},{"location":"reference/internal/objective/","title":"objective","text":"<p>Classes:</p> Name Description <code>Objective</code> <p>Examples:</p>"},{"location":"reference/internal/objective/#pyoframe.objective.Objective","title":"<code>Objective(expr, _constructive=False)</code>","text":"<p>               Bases: <code>Expression</code></p> <p>Examples:</p> <p>An <code>Objective</code> is automatically created when an <code>Expression</code> is assigned to <code>.minimize</code> or <code>.maximize</code></p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.A, m.B = pf.Variable(lb=0), pf.Variable(lb=0)\n&gt;&gt;&gt; m.con = m.A + m.B &lt;= 10\n&gt;&gt;&gt; m.maximize = 2 * m.B + 4\n&gt;&gt;&gt; m.maximize\n&lt;Objective size=1 dimensions={} terms=2&gt;\nobjective: 2 B +4\n</code></pre> <p>The objective value can be retrieved with from the solver once the model is solved using <code>.value</code>.</p> <pre><code>&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.maximize.value\n24.0\n</code></pre> <p>Objectives support <code>+=</code> and <code>-=</code> operators.</p> <pre><code>&gt;&gt;&gt; m.maximize += 3 * m.A\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.A.solution, m.B.solution\n(10.0, 0.0)\n&gt;&gt;&gt; m.maximize -= 2 * m.A\n&gt;&gt;&gt; m.optimize()\n&gt;&gt;&gt; m.A.solution, m.B.solution\n(0.0, 10.0)\n</code></pre> <p>Objectives cannot be created from dimensioned expressions since an objective must be a single expression.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.dimensioned_variable = pf.Variable(\n...     {\"city\": [\"Toronto\", \"Berlin\", \"Paris\"]}\n... )\n&gt;&gt;&gt; m.maximize = m.dimensioned_variable\nTraceback (most recent call last):\n...\nValueError: Objective cannot be created from a dimensioned expression. Did you forget to use pf.sum()?\n</code></pre> <p>Objectives cannot be overwritten.</p> <pre><code>&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.A = pf.Variable(lb=0)\n&gt;&gt;&gt; m.maximize = 2 * m.A\n&gt;&gt;&gt; m.maximize = 3 * m.A\nTraceback (most recent call last):\n...\nValueError: An objective already exists. Use += or -= to modify it.\n</code></pre> <p>Methods:</p> Name Description <code>__iadd__</code> <code>__isub__</code> <code>on_add_to_model</code> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The value of the objective function (only available after solving the model).</p> Source code in <code>pyoframe/objective.py</code> <pre><code>def __init__(\n    self, expr: SupportsToExpr | int | float, _constructive: bool = False\n) -&gt; None:\n    self._constructive = _constructive\n    if isinstance(expr, (int, float)):\n        expr = Expression.constant(expr)\n    else:\n        expr = expr.to_expr()\n    super().__init__(expr.data)\n    self._model = expr._model\n    if self.dimensions is not None:\n        raise ValueError(\n            \"Objective cannot be created from a dimensioned expression. Did you forget to use pf.sum()?\"\n        )\n</code></pre>"},{"location":"reference/internal/objective/#pyoframe.objective.Objective.value","title":"<code>value</code>  <code>property</code>","text":"<p>The value of the objective function (only available after solving the model). This value is obtained by directly querying the solver.</p>"},{"location":"reference/internal/objective/#pyoframe.objective.Objective.__iadd__","title":"<code>__iadd__(other)</code>","text":"Source code in <code>pyoframe/objective.py</code> <pre><code>def __iadd__(self, other):\n    return Objective(self + other, _constructive=True)\n</code></pre>"},{"location":"reference/internal/objective/#pyoframe.objective.Objective.__isub__","title":"<code>__isub__(other)</code>","text":"Source code in <code>pyoframe/objective.py</code> <pre><code>def __isub__(self, other):\n    return Objective(self - other, _constructive=True)\n</code></pre>"},{"location":"reference/internal/objective/#pyoframe.objective.Objective.on_add_to_model","title":"<code>on_add_to_model(model, name)</code>","text":"Source code in <code>pyoframe/objective.py</code> <pre><code>def on_add_to_model(self, model, name):\n    super().on_add_to_model(model, name)\n    assert self._model is not None\n    if self._model.sense is None:\n        raise ValueError(\n            \"Can't set an objective without specifying the sense. Did you use .objective instead of .minimize or .maximize ?\"\n        )\n\n    kwargs = {}\n    if (\n        not self._model.solver.supports_objective_sense\n        and self._model.sense == ObjSense.MAX\n    ):\n        poi_expr = (-self).to_poi()\n        kwargs[\"sense\"] = poi.ObjectiveSense.Minimize\n    else:\n        poi_expr = self.to_poi()\n        kwargs[\"sense\"] = self._model.sense.to_poi()\n    self._model.poi.set_objective(poi_expr, **kwargs)\n</code></pre>"},{"location":"reference/internal/util/","title":"util","text":"<p>File containing utility functions and classes.</p> <p>Classes:</p> Name Description <code>Container</code> <p>A placeholder object that makes it easy to set and get attributes. Used in Model.attr and Model.params, for example.</p> <code>FuncArgs</code> <code>NamedVariableMapper</code> <p>Maps variables to a string representation using the object's name and dimensions.</p> <p>Functions:</p> Name Description <code>cast_coef_to_string</code> <p>Converts column <code>column_name</code> of the dataframe <code>df</code> to a string. Rounds to <code>Config.print_float_precision</code> decimal places if not None.</p> <code>concat_dimensions</code> <p>Returns a new DataFrame with the column 'concated_dim'. Reserved columns are ignored.</p> <code>dataframe_to_tupled_list</code> <p>Converts a dataframe into a list of tuples. Used to print a Set to the console. See examples for behaviour.</p> <code>for_solvers</code> <p>Decorator that limits the function to only be called when the solver is in the <code>only</code> list.</p> <code>get_obj_repr</code> <p>Helper function to generate repr strings for classes. See usage for examples.</p> <code>parse_inputs_as_iterable</code> <p>Converts a parameter *x: Any | Iteraable[Any] to a single Iterable[Any] object.</p> <code>unwrap_single_values</code> <p>Decorator for functions that return DataFrames. Returned dataframes with a single value will instead return the value.</p>"},{"location":"reference/internal/util/#pyoframe.util.Container","title":"<code>Container(setter, getter)</code>","text":"<p>A placeholder object that makes it easy to set and get attributes. Used in Model.attr and Model.params, for example.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = {}\n&gt;&gt;&gt; params = Container(\n...     setter=lambda n, v: x.__setitem__(n, v), getter=lambda n: x[n]\n... )\n&gt;&gt;&gt; params.a = 1\n&gt;&gt;&gt; params.b = 2\n&gt;&gt;&gt; params.a\n1\n&gt;&gt;&gt; params.b\n2\n</code></pre> <p>Methods:</p> Name Description <code>__getattr__</code> <code>__setattr__</code> Source code in <code>pyoframe/util.py</code> <pre><code>def __init__(self, setter, getter):\n    self._setter = setter\n    self._getter = getter\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.Container.__getattr__","title":"<code>__getattr__(name)</code>","text":"Source code in <code>pyoframe/util.py</code> <pre><code>def __getattr__(self, name: str) -&gt; Any:\n    if name.startswith(\"_\"):  # pragma: no cover\n        return super().__getattribute__(name)\n    return self._getter(name)\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.Container.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"Source code in <code>pyoframe/util.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    if name.startswith(\"_\"):  # pragma: no cover\n        return super().__setattr__(name, value)\n    self._setter(name, value)\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.FuncArgs","title":"<code>FuncArgs(args, kwargs=dict())</code>  <code>dataclass</code>","text":"<p>Attributes:</p> Name Type Description <code>args</code> <code>List</code> <code>kwargs</code> <code>Dict</code>"},{"location":"reference/internal/util/#pyoframe.util.FuncArgs.args","title":"<code>args</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/util/#pyoframe.util.FuncArgs.kwargs","title":"<code>kwargs = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/util/#pyoframe.util.NamedVariableMapper","title":"<code>NamedVariableMapper(cls)</code>","text":"<p>Maps variables to a string representation using the object's name and dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; m = pf.Model()\n&gt;&gt;&gt; m.foo = pf.Variable(pl.DataFrame({\"t\": range(4)}))\n&gt;&gt;&gt; pf.sum(m.foo)\n&lt;Expression size=1 dimensions={} terms=4&gt;\nfoo[0] + foo[1] + foo[2] + foo[3]\n</code></pre> <p>Methods:</p> Name Description <code>add</code> <code>apply</code> <p>Attributes:</p> Name Type Description <code>CONST_TERM_NAME</code> <code>NAME_COL</code> <code>mapping_registry</code> Source code in <code>pyoframe/util.py</code> <pre><code>def __init__(self, cls: Type[\"ModelElementWithId\"]) -&gt; None:\n    self._ID_COL = VAR_KEY\n    self.mapping_registry = pl.DataFrame(\n        {self._ID_COL: [], self.NAME_COL: []},\n        schema={self._ID_COL: pl.UInt32, self.NAME_COL: pl.String},\n    )\n    self._extend_registry(\n        pl.DataFrame(\n            {self._ID_COL: [CONST_TERM], self.NAME_COL: [self.CONST_TERM_NAME]},\n            schema={self._ID_COL: pl.UInt32, self.NAME_COL: pl.String},\n        )\n    )\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.NamedVariableMapper.CONST_TERM_NAME","title":"<code>CONST_TERM_NAME = '_ONE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/util/#pyoframe.util.NamedVariableMapper.NAME_COL","title":"<code>NAME_COL = '__name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/internal/util/#pyoframe.util.NamedVariableMapper.mapping_registry","title":"<code>mapping_registry = pl.DataFrame({self._ID_COL: [], self.NAME_COL: []}, schema={self._ID_COL: pl.UInt32, self.NAME_COL: pl.String})</code>  <code>instance-attribute</code>","text":""},{"location":"reference/internal/util/#pyoframe.util.NamedVariableMapper.add","title":"<code>add(element)</code>","text":"Source code in <code>pyoframe/util.py</code> <pre><code>def add(self, element: \"Variable\") -&gt; None:\n    self._extend_registry(self._element_to_map(element))\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.NamedVariableMapper.apply","title":"<code>apply(df, to_col, id_col)</code>","text":"Source code in <code>pyoframe/util.py</code> <pre><code>def apply(\n    self,\n    df: pl.DataFrame,\n    to_col: str,\n    id_col: str,\n) -&gt; pl.DataFrame:\n    return df.join(\n        self.mapping_registry,\n        how=\"left\",\n        validate=\"m:1\",\n        left_on=id_col,\n        right_on=self._ID_COL,\n    ).rename({self.NAME_COL: to_col})\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.cast_coef_to_string","title":"<code>cast_coef_to_string(df, column_name=COEF_KEY, drop_ones=True)</code>","text":"<p>Converts column <code>column_name</code> of the dataframe <code>df</code> to a string. Rounds to <code>Config.print_float_precision</code> decimal places if not None.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame.</p> required <code>column_name</code> <code>str</code> <p>The name of the column to be casted.</p> <code>COEF_KEY</code> <code>drop_ones</code> <code>bool</code> <p>If True, 1s are replaced with an empty string for non-constant terms.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1.0, -2.0, 1.0, 4.0], VAR_KEY: [1, 2, 0, 4]})\n&gt;&gt;&gt; cast_coef_to_string(df, \"x\")\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 x   \u2506 __variable_id \u2502\n\u2502 --- \u2506 ---           \u2502\n\u2502 str \u2506 i64           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 +   \u2506 1             \u2502\n\u2502 -2  \u2506 2             \u2502\n\u2502 +1  \u2506 0             \u2502\n\u2502 +4  \u2506 4             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def cast_coef_to_string(\n    df: pl.DataFrame, column_name: str = COEF_KEY, drop_ones: bool = True\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Converts column `column_name` of the dataframe `df` to a string. Rounds to `Config.print_float_precision` decimal places if not None.\n\n    Parameters:\n        df:\n            The input DataFrame.\n        column_name:\n            The name of the column to be casted.\n        drop_ones:\n            If True, 1s are replaced with an empty string for non-constant terms.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1.0, -2.0, 1.0, 4.0], VAR_KEY: [1, 2, 0, 4]})\n        &gt;&gt;&gt; cast_coef_to_string(df, \"x\")\n        shape: (4, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 x   \u2506 __variable_id \u2502\n        \u2502 --- \u2506 ---           \u2502\n        \u2502 str \u2506 i64           \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 +   \u2506 1             \u2502\n        \u2502 -2  \u2506 2             \u2502\n        \u2502 +1  \u2506 0             \u2502\n        \u2502 +4  \u2506 4             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    df = df.with_columns(\n        pl.col(column_name).abs(),\n        _sign=pl.when(pl.col(column_name) &lt; 0).then(pl.lit(\"-\")).otherwise(pl.lit(\"+\")),\n    )\n\n    if Config.float_to_str_precision is not None:\n        df = df.with_columns(pl.col(column_name).round(Config.float_to_str_precision))\n\n    df = df.with_columns(\n        pl.when(pl.col(column_name) == pl.col(column_name).floor())\n        .then(pl.col(column_name).cast(pl.Int64).cast(pl.String))\n        .otherwise(pl.col(column_name).cast(pl.String))\n        .alias(column_name)\n    )\n\n    if drop_ones:\n        condition = pl.col(column_name) == str(1)\n        if VAR_KEY in df.columns:\n            condition = condition &amp; (pl.col(VAR_KEY) != CONST_TERM)\n        df = df.with_columns(\n            pl.when(condition)\n            .then(pl.lit(\"\"))\n            .otherwise(pl.col(column_name))\n            .alias(column_name)\n        )\n    else:\n        df = df.with_columns(pl.col(column_name).cast(pl.Utf8))\n    return df.with_columns(pl.concat_str(\"_sign\", column_name).alias(column_name)).drop(\n        \"_sign\"\n    )\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.concat_dimensions","title":"<code>concat_dimensions(df, prefix=None, keep_dims=True, ignore_columns=RESERVED_COL_KEYS, replace_spaces=True, to_col='concated_dim')</code>","text":"<p>Returns a new DataFrame with the column 'concated_dim'. Reserved columns are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame.</p> required <code>prefix</code> <code>Optional[str]</code> <p>The prefix to be added to the concated dimension.</p> <code>None</code> <code>keep_dims</code> <code>bool</code> <p>If True, the original dimensions are kept in the new DataFrame.</p> <code>True</code> <code>replace_spaces</code> <p>bool, optional If True, replaces spaces with underscores.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"dim1\": [1, 2, 3, 1, 2, 3],\n...         \"dim2\": [\"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\"],\n...     }\n... )\n&gt;&gt;&gt; concat_dimensions(df)\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 str  \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 Y    \u2506 [1,Y]        \u2502\n\u2502 2    \u2506 Y    \u2506 [2,Y]        \u2502\n\u2502 3    \u2506 Y    \u2506 [3,Y]        \u2502\n\u2502 1    \u2506 N    \u2506 [1,N]        \u2502\n\u2502 2    \u2506 N    \u2506 [2,N]        \u2502\n\u2502 3    \u2506 N    \u2506 [3,N]        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 str  \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 Y    \u2506 x[1,Y]       \u2502\n\u2502 2    \u2506 Y    \u2506 x[2,Y]       \u2502\n\u2502 3    \u2506 Y    \u2506 x[3,Y]       \u2502\n\u2502 1    \u2506 N    \u2506 x[1,N]       \u2502\n\u2502 2    \u2506 N    \u2506 x[2,N]       \u2502\n\u2502 3    \u2506 N    \u2506 x[3,N]       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; concat_dimensions(df, keep_dims=False)\nshape: (6, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 concated_dim \u2502\n\u2502 ---          \u2502\n\u2502 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1,Y]        \u2502\n\u2502 [2,Y]        \u2502\n\u2502 [3,Y]        \u2502\n\u2502 [1,N]        \u2502\n\u2502 [2,N]        \u2502\n\u2502 [3,N]        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; # Properly handles cases with no dimensions and ignores reserved columns\n&gt;&gt;&gt; df = pl.DataFrame({VAR_KEY: [1, 2]})\n&gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 __variable_id \u2506 concated_dim \u2502\n\u2502 ---           \u2506 ---          \u2502\n\u2502 i64           \u2506 str          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1             \u2506 x            \u2502\n\u2502 2             \u2506 x            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def concat_dimensions(\n    df: pl.DataFrame,\n    prefix: Optional[str] = None,\n    keep_dims: bool = True,\n    ignore_columns: Sequence[str] = RESERVED_COL_KEYS,\n    replace_spaces: bool = True,\n    to_col: str = \"concated_dim\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Returns a new DataFrame with the column 'concated_dim'. Reserved columns are ignored.\n\n    Parameters:\n        df:\n            The input DataFrame.\n        prefix:\n            The prefix to be added to the concated dimension.\n        keep_dims:\n            If True, the original dimensions are kept in the new DataFrame.\n        replace_spaces : bool, optional\n            If True, replaces spaces with underscores.\n\n    Examples:\n        &gt;&gt;&gt; import polars as pl\n        &gt;&gt;&gt; df = pl.DataFrame(\n        ...     {\n        ...         \"dim1\": [1, 2, 3, 1, 2, 3],\n        ...         \"dim2\": [\"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\"],\n        ...     }\n        ... )\n        &gt;&gt;&gt; concat_dimensions(df)\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n        \u2502 ---  \u2506 ---  \u2506 ---          \u2502\n        \u2502 i64  \u2506 str  \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 Y    \u2506 [1,Y]        \u2502\n        \u2502 2    \u2506 Y    \u2506 [2,Y]        \u2502\n        \u2502 3    \u2506 Y    \u2506 [3,Y]        \u2502\n        \u2502 1    \u2506 N    \u2506 [1,N]        \u2502\n        \u2502 2    \u2506 N    \u2506 [2,N]        \u2502\n        \u2502 3    \u2506 N    \u2506 [3,N]        \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\n        shape: (6, 3)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 dim1 \u2506 dim2 \u2506 concated_dim \u2502\n        \u2502 ---  \u2506 ---  \u2506 ---          \u2502\n        \u2502 i64  \u2506 str  \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1    \u2506 Y    \u2506 x[1,Y]       \u2502\n        \u2502 2    \u2506 Y    \u2506 x[2,Y]       \u2502\n        \u2502 3    \u2506 Y    \u2506 x[3,Y]       \u2502\n        \u2502 1    \u2506 N    \u2506 x[1,N]       \u2502\n        \u2502 2    \u2506 N    \u2506 x[2,N]       \u2502\n        \u2502 3    \u2506 N    \u2506 x[3,N]       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; concat_dimensions(df, keep_dims=False)\n        shape: (6, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 concated_dim \u2502\n        \u2502 ---          \u2502\n        \u2502 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 [1,Y]        \u2502\n        \u2502 [2,Y]        \u2502\n        \u2502 [3,Y]        \u2502\n        \u2502 [1,N]        \u2502\n        \u2502 [2,N]        \u2502\n        \u2502 [3,N]        \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; # Properly handles cases with no dimensions and ignores reserved columns\n        &gt;&gt;&gt; df = pl.DataFrame({VAR_KEY: [1, 2]})\n        &gt;&gt;&gt; concat_dimensions(df, prefix=\"x\")\n        shape: (2, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 __variable_id \u2506 concated_dim \u2502\n        \u2502 ---           \u2506 ---          \u2502\n        \u2502 i64           \u2506 str          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 1             \u2506 x            \u2502\n        \u2502 2             \u2506 x            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    if prefix is None:\n        prefix = \"\"\n    dimensions = [col for col in df.columns if col not in ignore_columns]\n    if dimensions:\n        query = pl.concat_str(\n            pl.lit(prefix + \"[\"),\n            pl.concat_str(*dimensions, separator=\",\"),\n            pl.lit(\"]\"),\n        )\n    else:\n        query = pl.lit(prefix)\n\n    df = df.with_columns(query.alias(to_col))\n\n    if replace_spaces:\n        df = df.with_columns(pl.col(to_col).str.replace_all(\" \", \"_\"))\n\n    if not keep_dims:\n        df = df.drop(*dimensions)\n\n    return df\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.dataframe_to_tupled_list","title":"<code>dataframe_to_tupled_list(df, num_max_elements=None)</code>","text":"<p>Converts a dataframe into a list of tuples. Used to print a Set to the console. See examples for behaviour.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; dataframe_to_tupled_list(df)\n'[1, 2, 3, 4, 5]'\n&gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n'[1, 2, 3, ...]'\n</code></pre> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5], \"y\": [2, 3, 4, 5, 6]})\n&gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n'[(1, 2), (2, 3), (3, 4), ...]'\n</code></pre> Source code in <code>pyoframe/util.py</code> <pre><code>def dataframe_to_tupled_list(\n    df: pl.DataFrame, num_max_elements: Optional[int] = None\n) -&gt; str:\n    \"\"\"\n    Converts a dataframe into a list of tuples. Used to print a Set to the console. See examples for behaviour.\n\n    Examples:\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5]})\n        &gt;&gt;&gt; dataframe_to_tupled_list(df)\n        '[1, 2, 3, 4, 5]'\n        &gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n        '[1, 2, 3, ...]'\n\n        &gt;&gt;&gt; df = pl.DataFrame({\"x\": [1, 2, 3, 4, 5], \"y\": [2, 3, 4, 5, 6]})\n        &gt;&gt;&gt; dataframe_to_tupled_list(df, 3)\n        '[(1, 2), (2, 3), (3, 4), ...]'\n    \"\"\"\n    elipse = False\n    if num_max_elements is not None:\n        if len(df) &gt; num_max_elements:\n            elipse = True\n            df = df.head(num_max_elements)\n\n    res = (row for row in df.iter_rows())\n    if len(df.columns) == 1:\n        res = (row[0] for row in res)\n\n    res = str(list(res))\n    if elipse:\n        res = res[:-1] + \", ...]\"\n    return res\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.for_solvers","title":"<code>for_solvers(*solvers)</code>","text":"<p>Decorator that limits the function to only be called when the solver is in the <code>only</code> list.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def for_solvers(*solvers: str):\n    \"\"\"\n    Decorator that limits the function to only be called when the solver is in the `only` list.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self.solver.name not in solvers:\n                raise NotImplementedError(\n                    f\"Method '{func.__name__}' is not implemented for solver '{self.solver}'.\"\n                )\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.get_obj_repr","title":"<code>get_obj_repr(obj, _props=(), **kwargs)</code>","text":"<p>Helper function to generate repr strings for classes. See usage for examples.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def get_obj_repr(obj: object, _props: Iterable[str] = (), **kwargs):\n    \"\"\"\n    Helper function to generate __repr__ strings for classes. See usage for examples.\n    \"\"\"\n    props = {prop: getattr(obj, prop) for prop in _props}\n    props_str = \" \".join(f\"{k}={v}\" for k, v in props.items() if v is not None)\n    if props_str:\n        props_str += \" \"\n    kwargs_str = \" \".join(f\"{k}={v}\" for k, v in kwargs.items() if v is not None)\n    return f\"&lt;{obj.__class__.__name__} {props_str}{kwargs_str}&gt;\"\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.parse_inputs_as_iterable","title":"<code>parse_inputs_as_iterable(*inputs)</code>","text":"<p>Converts a parameter *x: Any | Iteraable[Any] to a single Iterable[Any] object. This is helpful to support these two ways of passing arguments:     - foo([1, 2, 3])     - foo(1, 2, 3)</p> <p>Inspired from the polars library.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def parse_inputs_as_iterable(\n    *inputs: Union[Any, Iterable[Any]],\n) -&gt; Iterable[Any]:\n    \"\"\"\n    Converts a parameter *x: Any | Iteraable[Any] to a single Iterable[Any] object.\n    This is helpful to support these two ways of passing arguments:\n        - foo([1, 2, 3])\n        - foo(1, 2, 3)\n\n    Inspired from the polars library.\n    \"\"\"\n    if not inputs:\n        return []\n\n    # Treat elements of a single iterable as separate inputs\n    if len(inputs) == 1 and _is_iterable(inputs[0]):\n        return inputs[0]\n\n    return inputs\n</code></pre>"},{"location":"reference/internal/util/#pyoframe.util.unwrap_single_values","title":"<code>unwrap_single_values(func)</code>","text":"<p>Decorator for functions that return DataFrames. Returned dataframes with a single value will instead return the value.</p> Source code in <code>pyoframe/util.py</code> <pre><code>def unwrap_single_values(func):\n    \"\"\"Decorator for functions that return DataFrames. Returned dataframes with a single value will instead return the value.\"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        if isinstance(result, pl.DataFrame) and result.shape == (1, 1):\n            return result.item()\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"why-pyoframe/","title":"Why Pyoframe?","text":"<p>Pyoframe is better than alternatives libraries due to speed,  memory and readability. See for yourself:</p> <p></p>"},{"location":"why-pyoframe/#why-not-pyoframe","title":"Why not Pyoframe?","text":"<p>Our library still has some limitations:</p> <ul> <li>No support for quadratic objectives (for now, help us out!)</li> <li>Only supports Gurobi (for now, help us out!)</li> </ul>"},{"location":"why-pyoframe/why-pyoframe/","title":"Why PyoFrame?","text":""}]}